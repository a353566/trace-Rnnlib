func_extract_an_archive	build-aux\ltmain.sh	/^func_extract_an_archive ()$/;"	f
func_extract_archives	build-aux\ltmain.sh	/^func_extract_archives ()$/;"	f
func_infer_tag	build-aux\ltmain.sh	/^func_infer_tag ()$/;"	f
func_mktempdir	build-aux\ltmain.sh	/^func_mktempdir ()$/;"	f
func_win32_libid	build-aux\ltmain.sh	/^func_win32_libid ()$/;"	f
HAVE_INTTYPES_H	config.h	5;"	d
HAVE_LIBM	config.h	8;"	d
HAVE_LIBNETCDF	config.h	11;"	d
HAVE_LIBNETCDF_C__	config.h	14;"	d
HAVE_LIBSTDC__	config.h	17;"	d
HAVE_MALLOC_H	config.h	20;"	d
HAVE_MEMORY_H	config.h	23;"	d
HAVE_STDINT_H	config.h	26;"	d
HAVE_STDLIB_H	config.h	29;"	d
HAVE_STRINGS_H	config.h	32;"	d
HAVE_STRING_H	config.h	35;"	d
HAVE_SYS_STAT_H	config.h	38;"	d
HAVE_SYS_TYPES_H	config.h	41;"	d
HAVE_TIME_H	config.h	44;"	d
HAVE_UNISTD_H	config.h	47;"	d
PACKAGE	config.h	50;"	d
PACKAGE_BUGREPORT	config.h	53;"	d
PACKAGE_NAME	config.h	56;"	d
PACKAGE_STRING	config.h	59;"	d
PACKAGE_TARNAME	config.h	62;"	d
PACKAGE_VERSION	config.h	65;"	d
STDC_HEADERS	config.h	68;"	d
VERSION	config.h	71;"	d
Image	examples\arabic_offline_handwriting\arabic_offline.py	/^from PIL import Image$/;"	i
OptionParser	examples\arabic_offline_handwriting\arabic_offline.py	/^from optparse import OptionParser$/;"	i
asciiStr	examples\arabic_offline_handwriting\arabic_offline.py	/^							asciiStr = w.encode('ascii', "backslashreplace")$/;"	v
convertToPrimaries	examples\arabic_offline_handwriting\arabic_offline.py	/^def convertToPrimaries (labelString):$/;"	f
data	examples\arabic_offline_handwriting\arabic_offline.py	/^					data = words[1].split(';')$/;"	v
dims	examples\arabic_offline_handwriting\arabic_offline.py	/^		dims = (image.size[1], image.size[0])$/;"	v
file	examples\arabic_offline_handwriting\arabic_offline.py	/^file = netcdf_helpers.NetCDFFile(outputFilename, 'w')$/;"	v
filenames	examples\arabic_offline_handwriting\arabic_offline.py	/^filenames = file(inputFilename).readlines()$/;"	v
fname	examples\arabic_offline_handwriting\arabic_offline.py	/^	fname = f.strip()$/;"	v
image	examples\arabic_offline_handwriting\arabic_offline.py	/^		image = Image.open(fname)$/;"	v
image	examples\arabic_offline_handwriting\arabic_offline.py	/^	image = Image.open(filename).transpose(Image.FLIP_TOP_BOTTOM).transpose(Image.ROTATE_270)$/;"	v
inputFilename	examples\arabic_offline_handwriting\arabic_offline.py	/^inputFilename = args[0]$/;"	v
inputMean	examples\arabic_offline_handwriting\arabic_offline.py	/^inputMean = 226.8663$/;"	v
inputStd	examples\arabic_offline_handwriting\arabic_offline.py	/^inputStd = 81.62196$/;"	v
inputs	examples\arabic_offline_handwriting\arabic_offline.py	/^inputs = zeros((totalLen,1), 'f')$/;"	v
lab	examples\arabic_offline_handwriting\arabic_offline.py	/^									lab = w[:ligChar]$/;"	v
lab	examples\arabic_offline_handwriting\arabic_offline.py	/^									lab = w[len(ligatureString):]$/;"	v
lab	examples\arabic_offline_handwriting\arabic_offline.py	/^								lab = w$/;"	v
lab	examples\arabic_offline_handwriting\arabic_offline.py	/^							lab = lab[0] + lab[1:].replace('1','').replace('2','')$/;"	v
lab	examples\arabic_offline_handwriting\arabic_offline.py	/^			lab = l.split('*')[1].strip()$/;"	v
labels	examples\arabic_offline_handwriting\arabic_offline.py	/^	labels = []$/;"	v
labels	examples\arabic_offline_handwriting\arabic_offline.py	/^	labels = list(labels)$/;"	v
labels	examples\arabic_offline_handwriting\arabic_offline.py	/^	labels = set()$/;"	v
ligChar	examples\arabic_offline_handwriting\arabic_offline.py	/^							ligChar = w.find(ligatureString)$/;"	v
ligatureString	examples\arabic_offline_handwriting\arabic_offline.py	/^ligatureString = 'llL'$/;"	v
netcdf_helpers	examples\arabic_offline_handwriting\arabic_offline.py	/^import netcdf_helpers$/;"	i
offset	examples\arabic_offline_handwriting\arabic_offline.py	/^offset = 0$/;"	v
oldStart	examples\arabic_offline_handwriting\arabic_offline.py	/^							oldStart = match.start()$/;"	v
oldStart	examples\arabic_offline_handwriting\arabic_offline.py	/^						oldStart = 0$/;"	v
outputFilename	examples\arabic_offline_handwriting\arabic_offline.py	/^outputFilename = args[1]$/;"	v
parser	examples\arabic_offline_handwriting\arabic_offline.py	/^parser = OptionParser()$/;"	v
re	examples\arabic_offline_handwriting\arabic_offline.py	/^import re$/;"	i
seqDims	examples\arabic_offline_handwriting\arabic_offline.py	/^seqDims = []$/;"	v
seqLengths	examples\arabic_offline_handwriting\arabic_offline.py	/^seqLengths = []$/;"	v
seqTags	examples\arabic_offline_handwriting\arabic_offline.py	/^seqTags = []$/;"	v
sys	examples\arabic_offline_handwriting\arabic_offline.py	/^import sys$/;"	i
targetString	examples\arabic_offline_handwriting\arabic_offline.py	/^						targetString = wordTarget$/;"	v
targetString	examples\arabic_offline_handwriting\arabic_offline.py	/^					targetString = ""$/;"	v
targetString	examples\arabic_offline_handwriting\arabic_offline.py	/^					targetString = targetString.strip()$/;"	v
targetStrings	examples\arabic_offline_handwriting\arabic_offline.py	/^targetStrings = []$/;"	v
totalLen	examples\arabic_offline_handwriting\arabic_offline.py	/^totalLen = sum(seqLengths)$/;"	v
transcript	examples\arabic_offline_handwriting\arabic_offline.py	/^							transcript = transcriptNumFlip$/;"	v
transcript	examples\arabic_offline_handwriting\arabic_offline.py	/^							transcript = transcript[::-1]$/;"	v
transcript	examples\arabic_offline_handwriting\arabic_offline.py	/^						transcript= data[1].split(':')[1].decode("cp1256")$/;"	v
transcript	examples\arabic_offline_handwriting\arabic_offline.py	/^						transcript= data[2].split(':')[1].split('|')[:-1]$/;"	v
transcript	examples\arabic_offline_handwriting\arabic_offline.py	/^                                                        transcript = transcript[::-1]$/;"	v
transcriptNumFlip	examples\arabic_offline_handwriting\arabic_offline.py	/^						transcriptNumFlip = ""$/;"	v
truFile	examples\arabic_offline_handwriting\arabic_offline.py	/^			truFile = open(truFilename)$/;"	v
truFilename	examples\arabic_offline_handwriting\arabic_offline.py	/^		truFilename = fname.replace('tif','tru')$/;"	v
wordTarget	examples\arabic_offline_handwriting\arabic_offline.py	/^					wordTarget = data[0].split(':')[1]$/;"	v
wordTargetStrings	examples\arabic_offline_handwriting\arabic_offline.py	/^wordTargetStrings = []$/;"	v
words	examples\arabic_offline_handwriting\arabic_offline.py	/^				words = l.split()$/;"	v
OptionParser	examples\arabic_online_handwriting\arabic_online.py	/^from optparse import OptionParser$/;"	i
file	examples\arabic_online_handwriting\arabic_online.py	/^file = netcdf_helpers.NetCDFFile(ncFilename, 'w')$/;"	v
inkmlfile	examples\arabic_online_handwriting\arabic_online.py	/^	inkmlfile = l.strip()$/;"	v
inputFilename	examples\arabic_online_handwriting\arabic_online.py	/^inputFilename = args [0]$/;"	v
inputMeans	examples\arabic_online_handwriting\arabic_online.py	/^inputMeans = array([511.8343, 102.7592, 0.03199977])$/;"	v
inputStds	examples\arabic_online_handwriting\arabic_online.py	/^inputStds = array([134.0498, 24.34094, 0.1758981])$/;"	v
inputs	examples\arabic_online_handwriting\arabic_online.py	/^inputs = ((array(inputs)-inputMeans)\/inputStds).tolist()$/;"	v
inputs	examples\arabic_online_handwriting\arabic_online.py	/^inputs = []$/;"	v
label	examples\arabic_online_handwriting\arabic_online.py	/^				label = c.encode('unicode_escape')$/;"	v
labels	examples\arabic_online_handwriting\arabic_online.py	/^labels = ['*', '0', '1', '2', '6', '7', '8', '9', 'V', '\\\\u0621', '\\\\u0622', '\\\\u0623', '\\\\u0625', '\\\\u0626', '\\\\u0627', '\\\\u0628', '\\\\u0629', '\\\\u062a', '\\\\u062b', '\\\\u062c', '\\\\u062d', '\\\\u062e', '\\\\u062f', '\\\\u0630', '\\\\u0631', '\\\\u0632', '\\\\u0633', '\\\\u0634', '\\\\u0635', '\\\\u0636', '\\\\u0637', '\\\\u0638', '\\\\u0639', '\\\\u063a', '\\\\u0641', '\\\\u0642', '\\\\u0643', '\\\\u0644', '\\\\u0645', '\\\\u0646', '\\\\u0647', '\\\\u0648', '\\\\u0649', '\\\\u064a', '\\\\u0651']$/;"	v
ncFilename	examples\arabic_online_handwriting\arabic_online.py	/^ncFilename = args[1]$/;"	v
netcdf_helpers	examples\arabic_online_handwriting\arabic_online.py	/^import netcdf_helpers$/;"	i
oldlen	examples\arabic_online_handwriting\arabic_online.py	/^		oldlen = len(inputs)$/;"	v
os	examples\arabic_online_handwriting\arabic_online.py	/^import os$/;"	i
parse	examples\arabic_online_handwriting\arabic_online.py	/^from xml.dom.minidom import parse$/;"	i
parser	examples\arabic_online_handwriting\arabic_online.py	/^parser = OptionParser()$/;"	v
pt	examples\arabic_online_handwriting\arabic_online.py	/^				pt = coords.split()$/;"	v
seqDims	examples\arabic_online_handwriting\arabic_online.py	/^seqDims = []$/;"	v
seqLengths	examples\arabic_online_handwriting\arabic_online.py	/^seqLengths = []$/;"	v
seqTags	examples\arabic_online_handwriting\arabic_online.py	/^seqTags = []$/;"	v
sys	examples\arabic_online_handwriting\arabic_online.py	/^import sys$/;"	i
targetStrings	examples\arabic_online_handwriting\arabic_online.py	/^targetStrings = []$/;"	v
ts	examples\arabic_online_handwriting\arabic_online.py	/^			ts = ""$/;"	v
ts	examples\arabic_online_handwriting\arabic_online.py	/^			ts = ts.strip()$/;"	v
upxfile	examples\arabic_online_handwriting\arabic_online.py	/^		upxfile = inkmlfile.replace('inkml', 'upx')$/;"	v
word	examples\arabic_online_handwriting\arabic_online.py	/^			word = parse(upxfile).getElementsByTagName('hwData')[0].getElementsByTagName('label')[0].getElementsByTagName('alternate')[0].getAttribute('value').strip().replace(' ','*')$/;"	v
wordTargetStrings	examples\arabic_online_handwriting\arabic_online.py	/^wordTargetStrings = []$/;"	v
wts	examples\arabic_online_handwriting\arabic_online.py	/^			wts = word.encode('unicode_escape')$/;"	v
Image	examples\farsi_offline_handwriting\farsi_chars.py	/^from PIL import Image$/;"	i
OptionParser	examples\farsi_offline_handwriting\farsi_chars.py	/^from optparse import OptionParser$/;"	i
bigIm	examples\farsi_offline_handwriting\farsi_chars.py	/^		bigIm = Image.new(im.mode, (w,h), 255)$/;"	v
dims	examples\farsi_offline_handwriting\farsi_chars.py	/^				dims = (im.size[1], im.size[0])$/;"	v
dims	examples\farsi_offline_handwriting\farsi_chars.py	/^				dims = (max(padDims[0], im.size[1]), max(padDims[1], im.size[0]))$/;"	v
file	examples\farsi_offline_handwriting\farsi_chars.py	/^file = netcdf_helpers.NetCDFFile(ncFilename, 'w')$/;"	v
filenames	examples\farsi_offline_handwriting\farsi_chars.py	/^filenames = []$/;"	v
fname	examples\farsi_offline_handwriting\farsi_chars.py	/^	fname = line.strip()$/;"	v
h	examples\farsi_offline_handwriting\farsi_chars.py	/^		h = max(padDims[1], im.size[1])$/;"	v
im	examples\farsi_offline_handwriting\farsi_chars.py	/^			im = Image.open(fname)$/;"	v
im	examples\farsi_offline_handwriting\farsi_chars.py	/^		im = bigIm$/;"	v
im	examples\farsi_offline_handwriting\farsi_chars.py	/^	im = Image.open(tag).transpose(Image.FLIP_TOP_BOTTOM).transpose(Image.ROTATE_270).convert('L')$/;"	v
inputFilename	examples\farsi_offline_handwriting\farsi_chars.py	/^inputFilename = args[0]$/;"	v
inputMean	examples\farsi_offline_handwriting\farsi_chars.py	/^ 	inputMean = 244.2604$/;"	v
inputMean	examples\farsi_offline_handwriting\farsi_chars.py	/^ 	inputMean = 247.2425$/;"	v
inputStd	examples\farsi_offline_handwriting\farsi_chars.py	/^	inputStd = 29.01598$/;"	v
inputStd	examples\farsi_offline_handwriting\farsi_chars.py	/^	inputStd = 30.54056$/;"	v
inputlines	examples\farsi_offline_handwriting\farsi_chars.py	/^inputlines = file(inputFilename).readlines()$/;"	v
inputs	examples\farsi_offline_handwriting\farsi_chars.py	/^inputs = zeros((sum(seqLengths), 1), 'f')$/;"	v
label	examples\farsi_offline_handwriting\farsi_chars.py	/^				label = fname.split('\/')[-1][:2]$/;"	v
label	examples\farsi_offline_handwriting\farsi_chars.py	/^				label = labels[0]$/;"	v
labels	examples\farsi_offline_handwriting\farsi_chars.py	/^	labels = [str(x).rjust(2,'0') for x in range(1,35)]$/;"	v
labels	examples\farsi_offline_handwriting\farsi_chars.py	/^	labels = [str(x).rjust(2,'0') for x in range(35,47)]$/;"	v
ncFilename	examples\farsi_offline_handwriting\farsi_chars.py	/^ncFilename = args[1]$/;"	v
netcdf_helpers	examples\farsi_offline_handwriting\farsi_chars.py	/^import netcdf_helpers$/;"	i
offset	examples\farsi_offline_handwriting\farsi_chars.py	/^offset = 0$/;"	v
padDims	examples\farsi_offline_handwriting\farsi_chars.py	/^padDims = (95, 77)$/;"	v
parser	examples\farsi_offline_handwriting\farsi_chars.py	/^parser = OptionParser()$/;"	v
seqDims	examples\farsi_offline_handwriting\farsi_chars.py	/^seqDims = []$/;"	v
seqLengths	examples\farsi_offline_handwriting\farsi_chars.py	/^seqLengths = []$/;"	v
seqTags	examples\farsi_offline_handwriting\farsi_chars.py	/^seqTags = []$/;"	v
sys	examples\farsi_offline_handwriting\farsi_chars.py	/^import sys$/;"	i
targetStrings	examples\farsi_offline_handwriting\farsi_chars.py	/^targetStrings = []$/;"	v
w	examples\farsi_offline_handwriting\farsi_chars.py	/^		w = max(padDims[0], im.size[0])$/;"	v
Identity	src\ActivationFunctions.hpp	/^struct Identity$/;"	s
Logistic	src\ActivationFunctions.hpp	/^struct Logistic$/;"	s
Max2min0	src\ActivationFunctions.hpp	/^struct Max2min0$/;"	s
Maxmin1	src\ActivationFunctions.hpp	/^struct Maxmin1$/;"	s
Maxmin2	src\ActivationFunctions.hpp	/^struct Maxmin2$/;"	s
Softsign	src\ActivationFunctions.hpp	/^struct Softsign$/;"	s
Tanh	src\ActivationFunctions.hpp	/^struct Tanh$/;"	s
_INCLUDED_ActivationFunctions_h	src\ActivationFunctions.hpp	19;"	d
deriv	src\ActivationFunctions.hpp	/^	static real_t deriv(real_t y)$/;"	f	struct:Identity
deriv	src\ActivationFunctions.hpp	/^	static real_t deriv(real_t y)$/;"	f	struct:Logistic
deriv	src\ActivationFunctions.hpp	/^	static real_t deriv(real_t y)$/;"	f	struct:Max2min0
deriv	src\ActivationFunctions.hpp	/^	static real_t deriv(real_t y)$/;"	f	struct:Maxmin1
deriv	src\ActivationFunctions.hpp	/^	static real_t deriv(real_t y)$/;"	f	struct:Maxmin2
deriv	src\ActivationFunctions.hpp	/^	static real_t deriv(real_t y)$/;"	f	struct:Softsign
deriv	src\ActivationFunctions.hpp	/^	static real_t deriv(real_t y)$/;"	f	struct:Tanh
fn	src\ActivationFunctions.hpp	/^	static real_t fn(real_t x)$/;"	f	struct:Identity
fn	src\ActivationFunctions.hpp	/^	static real_t fn(real_t x)$/;"	f	struct:Logistic
fn	src\ActivationFunctions.hpp	/^	static real_t fn(real_t x)$/;"	f	struct:Max2min0
fn	src\ActivationFunctions.hpp	/^	static real_t fn(real_t x)$/;"	f	struct:Maxmin1
fn	src\ActivationFunctions.hpp	/^	static real_t fn(real_t x)$/;"	f	struct:Maxmin2
fn	src\ActivationFunctions.hpp	/^	static real_t fn(real_t x)$/;"	f	struct:Softsign
fn	src\ActivationFunctions.hpp	/^	static real_t fn(real_t x)$/;"	f	struct:Tanh
second_deriv	src\ActivationFunctions.hpp	/^	static real_t second_deriv(real_t y)$/;"	f	struct:Identity
second_deriv	src\ActivationFunctions.hpp	/^	static real_t second_deriv(real_t y)$/;"	f	struct:Logistic
second_deriv	src\ActivationFunctions.hpp	/^	static real_t second_deriv(real_t y)$/;"	f	struct:Max2min0
second_deriv	src\ActivationFunctions.hpp	/^	static real_t second_deriv(real_t y)$/;"	f	struct:Maxmin1
second_deriv	src\ActivationFunctions.hpp	/^	static real_t second_deriv(real_t y)$/;"	f	struct:Maxmin2
second_deriv	src\ActivationFunctions.hpp	/^	static real_t second_deriv(real_t y)$/;"	f	struct:Softsign
second_deriv	src\ActivationFunctions.hpp	/^	static real_t second_deriv(real_t y)$/;"	f	struct:Tanh
BiasLayer	src\BiasLayer.hpp	/^	BiasLayer():$/;"	f	struct:BiasLayer
BiasLayer	src\BiasLayer.hpp	/^struct BiasLayer: public Layer$/;"	s
_INCLUDED_BiasLayer_h	src\BiasLayer.hpp	19;"	d
acts	src\BiasLayer.hpp	/^	View<real_t> acts;$/;"	m	struct:BiasLayer
errors	src\BiasLayer.hpp	/^	View<real_t> errors;$/;"	m	struct:BiasLayer
out_acts	src\BiasLayer.hpp	/^	const View<real_t> out_acts(const vector<int>& coords)$/;"	f	struct:BiasLayer
out_errs	src\BiasLayer.hpp	/^	const View<real_t> out_errs(const vector<int>& coords)$/;"	f	struct:BiasLayer
output	src\BiasLayer.hpp	/^	void output() {$/;"	f	struct:BiasLayer
~BiasLayer	src\BiasLayer.hpp	/^	~BiasLayer(){}$/;"	f	struct:BiasLayer
BlockLayer	src\BlockLayer.hpp	/^	BlockLayer(Layer* src, const vector<size_t>& blockshape):$/;"	f	struct:BlockLayer
BlockLayer	src\BlockLayer.hpp	/^struct BlockLayer: public Layer$/;"	s
_INCLUDED_BlockLayer_h	src\BlockLayer.hpp	19;"	d
blockIterator	src\BlockLayer.hpp	/^	CVI blockIterator;			\/\/ CoordIterator<const vector<size_t> > 走訪一個 block 會用到的區域範圍$/;"	m	struct:BlockLayer
blockOffset	src\BlockLayer.hpp	/^	vector<int> blockOffset;$/;"	m	struct:BlockLayer
blockShape	src\BlockLayer.hpp	/^	vector<size_t> blockShape;	\/\/ Shape 3,4$/;"	m	struct:BlockLayer
feed_back	src\BlockLayer.hpp	/^	void feed_back(const vector<int>& outCoords)$/;"	f	struct:BlockLayer
feed_forward	src\BlockLayer.hpp	/^	void feed_forward(const vector<int>& outCoords)$/;"	f	struct:BlockLayer
inCoords	src\BlockLayer.hpp	/^	vector<int> inCoords;$/;"	m	struct:BlockLayer
outSeqShape	src\BlockLayer.hpp	/^	vector<size_t> outSeqShape;$/;"	m	struct:BlockLayer
output	src\BlockLayer.hpp	/^	void output() {$/;"	f	struct:BlockLayer
print	src\BlockLayer.hpp	/^	void print(ostream& out = cout) const$/;"	f	struct:BlockLayer
sourceSize	src\BlockLayer.hpp	/^	size_t sourceSize;			\/\/ 宣告時 會去取得 src 的 outputSize，所以 Layer creat 時不會主動做出這個數值$/;"	m	struct:BlockLayer
start_sequence	src\BlockLayer.hpp	/^	void start_sequence()$/;"	f	struct:BlockLayer
BinaryClassificationLayer	src\ClassificationLayer.hpp	/^	BinaryClassificationLayer(ostream& out, const string& name, size_t numSeqDims, const vector<string>& labels):$/;"	f	struct:BinaryClassificationLayer
BinaryClassificationLayer	src\ClassificationLayer.hpp	/^struct BinaryClassificationLayer: public ClassificationLayer, public NeuronLayer<Logistic>$/;"	s
ClassificationLayer	src\ClassificationLayer.hpp	/^	ClassificationLayer(ostream& o, const vector<string>& labs):$/;"	f	struct:ClassificationLayer
ClassificationLayer	src\ClassificationLayer.hpp	/^struct ClassificationLayer: public NetworkOutput$/;"	s
MulticlassClassificationLayer	src\ClassificationLayer.hpp	/^	MulticlassClassificationLayer(ostream& out, const string& name, size_t numSeqDims, const vector<string>& labels):$/;"	f	struct:MulticlassClassificationLayer
MulticlassClassificationLayer	src\ClassificationLayer.hpp	/^struct MulticlassClassificationLayer: public ClassificationLayer, public SoftmaxLayer$/;"	s
_INCLUDED_ClassificationLayer_h	src\ClassificationLayer.hpp	19;"	d
calculate_errors	src\ClassificationLayer.hpp	/^	real_t calculate_errors(const DataSequence& seq)$/;"	f	struct:ClassificationLayer
class_prob	src\ClassificationLayer.hpp	/^	real_t class_prob(int pt, int index) const$/;"	f	struct:BinaryClassificationLayer
class_prob	src\ClassificationLayer.hpp	/^	real_t class_prob(int pt, int index) const$/;"	f	struct:MulticlassClassificationLayer
confusionMatrix	src\ClassificationLayer.hpp	/^	vector<vector<int> > confusionMatrix;$/;"	m	struct:ClassificationLayer
labels	src\ClassificationLayer.hpp	/^	Vector<string> labels;$/;"	m	struct:ClassificationLayer
make_classification_layer	src\ClassificationLayer.hpp	/^ClassificationLayer* make_classification_layer(ostream& out, const string& name, size_t numSeqDims, const vector<string>& labels)$/;"	f
numErrorsByClass	src\ClassificationLayer.hpp	/^	vector<int> numErrorsByClass;$/;"	m	struct:ClassificationLayer
numTargetsByClass	src\ClassificationLayer.hpp	/^	vector<int> numTargetsByClass;$/;"	m	struct:ClassificationLayer
out	src\ClassificationLayer.hpp	/^	ostream& out;$/;"	m	struct:ClassificationLayer
output_class	src\ClassificationLayer.hpp	/^	int output_class(int pt) const$/;"	f	struct:BinaryClassificationLayer
output_class	src\ClassificationLayer.hpp	/^	int output_class(int pt) const$/;"	f	struct:MulticlassClassificationLayer
outputs	src\ClassificationLayer.hpp	/^	vector<int> outputs;$/;"	m	struct:ClassificationLayer
set_error	src\ClassificationLayer.hpp	/^	real_t set_error(int pt, int targetClass)$/;"	f	struct:BinaryClassificationLayer
set_error	src\ClassificationLayer.hpp	/^	real_t set_error(int pt, int targetClass)$/;"	f	struct:MulticlassClassificationLayer
targets	src\ClassificationLayer.hpp	/^	SeqBuffer<int> targets;$/;"	m	struct:ClassificationLayer
CollapseLayer	src\CollapseLayer.hpp	/^	CollapseLayer(Layer* src, Layer* des, const vector<bool>& activDims = empty_list_of<bool>()):$/;"	f	struct:CollapseLayer
CollapseLayer	src\CollapseLayer.hpp	/^struct CollapseLayer: public Layer$/;"	s
_INCLUDED_CollapseLayer_h	src\CollapseLayer.hpp	19;"	d
activeDims	src\CollapseLayer.hpp	/^	vector<bool> activeDims;$/;"	m	struct:CollapseLayer
feed_back	src\CollapseLayer.hpp	/^	void feed_back(const vector<int>& coords)$/;"	f	struct:CollapseLayer
feed_forward	src\CollapseLayer.hpp	/^	void feed_forward(const vector<int>& coords)$/;"	f	struct:CollapseLayer
get_out_coords	src\CollapseLayer.hpp	/^	vector<int> get_out_coords(const vector<int>& inCoords)$/;"	f	struct:CollapseLayer
outSeqShape	src\CollapseLayer.hpp	/^	vector<size_t> outSeqShape;$/;"	m	struct:CollapseLayer
output	src\CollapseLayer.hpp	/^	void output() {$/;"	f	struct:CollapseLayer
start_sequence	src\CollapseLayer.hpp	/^	virtual void start_sequence()$/;"	f	struct:CollapseLayer
ConfigFile	src\ConfigFile.hpp	/^	ConfigFile(const string& fname, char readLineChar = '_'):$/;"	f	struct:ConfigFile
ConfigFile	src\ConfigFile.hpp	/^struct ConfigFile$/;"	s
_INCLUDED_ConfigFile_h	src\ConfigFile.hpp	19;"	d
contains	src\ConfigFile.hpp	/^	bool contains(const string& name) const$/;"	f	struct:ConfigFile
filename	src\ConfigFile.hpp	/^	string filename;$/;"	m	struct:ConfigFile
get	src\ConfigFile.hpp	/^	template<class T> T get(const string& name)$/;"	f	struct:ConfigFile
get	src\ConfigFile.hpp	/^	template<class T> T get(const string& name, const T& defaultVal)$/;"	f	struct:ConfigFile
get_array	src\ConfigFile.hpp	/^	template<class T> Vector<Vector<T> > get_array(const string& name, const char delim1 = ';', const char delim2 = ',')$/;"	f	struct:ConfigFile
get_array	src\ConfigFile.hpp	/^	template<class T> Vector<Vector<T> > get_array(const string& name, const string& defaultStr, size_t length, const char delim1 = ';', const char delim2 = ',')$/;"	f	struct:ConfigFile
get_list	src\ConfigFile.hpp	/^	template<class T> Vector<T> get_list(const string& name, const T& defaultVal, size_t length, const char delim = ',')$/;"	f	struct:ConfigFile
get_list	src\ConfigFile.hpp	/^	template<class T> Vector<T> get_list(const string& name, const char delim = ',')$/;"	f	struct:ConfigFile
operator <<	src\ConfigFile.hpp	/^static ostream& operator << (ostream& out, const ConfigFile& conf)$/;"	f
params	src\ConfigFile.hpp	/^	map<string, string> params;$/;"	m	struct:ConfigFile
remove	src\ConfigFile.hpp	/^	bool remove(const string& name)$/;"	f	struct:ConfigFile
set_val	src\ConfigFile.hpp	/^	template<class T> const T& set_val(const string& name, const T& val, bool valUsed = true)$/;"	f	struct:ConfigFile
used	src\ConfigFile.hpp	/^	set<string> used;$/;"	m	struct:ConfigFile
warn_unused	src\ConfigFile.hpp	/^	void warn_unused(ostream& out, bool removeUnused = true)$/;"	f	struct:ConfigFile
Connection	src\Connection.hpp	/^	Connection(const string& name, Layer* f, Layer* t):$/;"	f	struct:Connection
Connection	src\Connection.hpp	/^struct Connection: public Named$/;"	s
_INCLUDED_Connection_h	src\Connection.hpp	19;"	d
feed_back	src\Connection.hpp	/^	virtual void feed_back(const vector<int>& coords){}$/;"	f	struct:Connection
feed_forward	src\Connection.hpp	/^	virtual void feed_forward(const vector<int>& coords){}$/;"	f	struct:Connection
from	src\Connection.hpp	/^	Layer* from;$/;"	m	struct:Connection
num_weights	src\Connection.hpp	/^	virtual size_t num_weights() const {return 0;}$/;"	f	struct:Connection
operator <<	src\Connection.hpp	/^static ostream& operator <<(ostream& out, const Connection& c)$/;"	f
print	src\Connection.hpp	/^	virtual void print(ostream& out) const{}$/;"	f	struct:Connection
to	src\Connection.hpp	/^	Layer* to;$/;"	m	struct:Connection
update_derivs	src\Connection.hpp	/^	virtual void update_derivs(const vector<int>& coords){}$/;"	f	struct:Connection
weights	src\Connection.hpp	/^	virtual const View<real_t> weights(){return View<real_t>();}$/;"	f	struct:Connection
~Connection	src\Connection.hpp	/^	virtual ~Connection(){}$/;"	f	struct:Connection
Set	src\Container.hpp	/^	Set()$/;"	f	struct:Set
Set	src\Container.hpp	/^	Set(const View<T>& v)$/;"	f	struct:Set
Set	src\Container.hpp	/^	Set(const vector<T>& v)$/;"	f	struct:Set
Set	src\Container.hpp	/^template<class T> struct Set: public set<T>$/;"	s
Vector	src\Container.hpp	/^	Vector()$/;"	f	struct:Vector
Vector	src\Container.hpp	/^	Vector(const View<const T>& v)$/;"	f	struct:Vector
Vector	src\Container.hpp	/^	Vector(const vector<T>& v):$/;"	f	struct:Vector
Vector	src\Container.hpp	/^	Vector(size_t n):$/;"	f	struct:Vector
Vector	src\Container.hpp	/^	Vector(size_t n, const T& t):$/;"	f	struct:Vector
Vector	src\Container.hpp	/^template<class T> struct Vector: public vector<T>$/;"	s
View	src\Container.hpp	/^	View(T* first = 0, T* second = 0):$/;"	f	struct:View
View	src\Container.hpp	/^	View(pair<T*, T*>& p):$/;"	f	struct:View
View	src\Container.hpp	/^template<class T> struct View: public sub_range<pair <T*, T*> >$/;"	s
_INCLUDED_Container_h	src\Container.hpp	19;"	d
at	src\Container.hpp	/^	T& at(size_t i)$/;"	f	struct:View
at	src\Container.hpp	/^	const T& at(size_t i) const$/;"	f	struct:View
extend	src\Container.hpp	/^	template<class R> Set<T>& extend(const R& r)$/;"	f	struct:Set
extend	src\Container.hpp	/^	template<class R> Vector<T>& extend(const R& r)$/;"	f	struct:Vector
grow	src\Container.hpp	/^	Vector<T>& grow(size_t length)$/;"	f	struct:Vector
operator +=	src\Container.hpp	/^	Set& operator +=(const T& val) $/;"	f	struct:Set
operator =	src\Container.hpp	/^	template<class R> Vector<T>& operator =(const R& r)$/;"	f	struct:Vector
operator =	src\Container.hpp	/^	template<class R> const View<T>& operator =(const R& r) const$/;"	f	struct:View
operator =	src\Container.hpp	/^  	template<class R> Set<T>& operator =(const R& r)$/;"	f	struct:Set
pop_front	src\Container.hpp	/^	T& pop_front()$/;"	f	struct:Vector
push_front	src\Container.hpp	/^	void push_front(const T& t)$/;"	f	struct:Vector
replicate	src\Container.hpp	/^	Vector<T> replicate(size_t times) const$/;"	f	struct:Vector
shrink	src\Container.hpp	/^	Vector<T>& shrink(size_t length)$/;"	f	struct:Vector
slice	src\Container.hpp	/^	View slice(int first = 0, int last = numeric_limits<int>::max())$/;"	f	struct:View
slice	src\Container.hpp	/^	View slice(pair<int, int>& r)$/;"	f	struct:View
slice	src\Container.hpp	/^	View<T> slice(int first = 0, int last = numeric_limits<int>::max())$/;"	f	struct:Vector
slice	src\Container.hpp	/^	View<T> slice(pair<int, int>& r)$/;"	f	struct:Vector
slice	src\Container.hpp	/^	const View slice(int first = 0, int last = numeric_limits<int>::max()) const$/;"	f	struct:View
slice	src\Container.hpp	/^	const View slice(pair<int, int>& r) const$/;"	f	struct:View
slice	src\Container.hpp	/^	const View<T> slice(int first = 0, int last = numeric_limits<int>::max()) const$/;"	f	struct:Vector
slice	src\Container.hpp	/^	const View<T> slice(pair<int, int>& r) const$/;"	f	struct:Vector
to	src\Container.hpp	/^	template<class T2> Vector<T2> to() const$/;"	f	struct:Vector
to	src\Container.hpp	/^	template<class T2> Vector<T2> to() const$/;"	f	struct:View
CopyConnection	src\CopyConnection.hpp	/^	CopyConnection(Layer* f, Layer* t):$/;"	f	struct:CopyConnection
CopyConnection	src\CopyConnection.hpp	/^struct CopyConnection: public Connection$/;"	s
_INCLUDED_CopyConnection_h	src\CopyConnection.hpp	19;"	d
feed_back	src\CopyConnection.hpp	/^	void feed_back(const vector<int>& coords)$/;"	f	struct:CopyConnection
feed_forward	src\CopyConnection.hpp	/^	void feed_forward(const vector<int>& coords)$/;"	f	struct:CopyConnection
print	src\CopyConnection.hpp	/^	void print(ostream& out) const$/;"	f	struct:CopyConnection
~CopyConnection	src\CopyConnection.hpp	/^	virtual ~CopyConnection(){}$/;"	f	struct:CopyConnection
display	src\DataExporter.cpp	/^void DataExportHandler::display(const string& path) const$/;"	f	class:DataExportHandler
load	src\DataExporter.cpp	/^void DataExportHandler::load(ConfigFile& conf, ostream& out)$/;"	f	class:DataExportHandler
save	src\DataExporter.cpp	/^void DataExportHandler::save(ostream& out) const$/;"	f	class:DataExportHandler
CONST_EXPORT_IT	src\DataExporter.hpp	/^typedef map<string, DataExporter*>::const_iterator CONST_EXPORT_IT;$/;"	t
CONST_VAL_IT	src\DataExporter.hpp	/^typedef map<string, Val*>::const_iterator CONST_VAL_IT;$/;"	t
DISPLAY	src\DataExporter.hpp	29;"	d
DataExportHandler	src\DataExporter.hpp	/^struct DataExportHandler$/;"	s
DataExporter	src\DataExporter.hpp	/^	DataExporter(const string& name):$/;"	f	struct:DataExporter
DataExporter	src\DataExporter.hpp	/^struct DataExporter: public Named$/;"	s
EXPORT_IT	src\DataExporter.hpp	/^typedef map<string, DataExporter*>::iterator EXPORT_IT;$/;"	t
PSPDE	src\DataExporter.hpp	/^typedef pair<const string, DataExporter*> PSPDE;$/;"	t
PSPV	src\DataExporter.hpp	/^typedef pair<const string, Val*> PSPV;$/;"	t
ParamVal	src\DataExporter.hpp	/^	ParamVal(T& p):$/;"	f	struct:ParamVal
ParamVal	src\DataExporter.hpp	/^template <typename T> struct ParamVal: public Val$/;"	s
RangeVal	src\DataExporter.hpp	/^	RangeVal(const R& r):$/;"	f	struct:RangeVal
RangeVal	src\DataExporter.hpp	/^template <typename R> struct RangeVal: public Val$/;"	s
SAVE	src\DataExporter.hpp	28;"	d
SeqBufferVal	src\DataExporter.hpp	/^	SeqBufferVal(const SeqBuffer<T>& a, const vector<string>* labs = 0):$/;"	f	struct:SeqBufferVal
SeqBufferVal	src\DataExporter.hpp	/^template <typename T> struct SeqBufferVal: public Val$/;"	s
VAL_IT	src\DataExporter.hpp	/^typedef map<string, Val*>::iterator VAL_IT;$/;"	t
Val	src\DataExporter.hpp	/^struct Val$/;"	s
_INCLUDED_DataExporter_h	src\DataExporter.hpp	19;"	d
array	src\DataExporter.hpp	/^	const SeqBuffer<T>& array;$/;"	m	struct:SeqBufferVal
dataExporters	src\DataExporter.hpp	/^	map<string, DataExporter*> dataExporters;$/;"	m	struct:DataExportHandler
delete_val	src\DataExporter.hpp	/^	void delete_val(map<string, Val*>& vals, const string& name)$/;"	f	struct:DataExporter
display	src\DataExporter.hpp	/^	template <typename T> void display(const SeqBuffer<T>& array, const string& name, const vector<string>* labels = 0)$/;"	f	struct:DataExporter
displayVals	src\DataExporter.hpp	/^	map<string, Val*> displayVals;$/;"	m	struct:DataExporter
instance	src\DataExporter.hpp	/^	static DataExportHandler& instance()$/;"	f	struct:DataExportHandler
labels	src\DataExporter.hpp	/^	const vector<string>* labels;$/;"	m	struct:SeqBufferVal
load	src\DataExporter.hpp	/^	bool load(ConfigFile& conf, ostream& out = cout)$/;"	f	struct:DataExporter
load	src\DataExporter.hpp	/^	bool load(istream& in, ostream& out = cout)$/;"	f	struct:ParamVal
load	src\DataExporter.hpp	/^	bool load(istream& in, ostream& out = cout)$/;"	f	struct:RangeVal
load	src\DataExporter.hpp	/^	virtual bool load(istream& in, ostream& out = cout)$/;"	f	struct:Val
operator <<	src\DataExporter.hpp	/^static ostream& operator << (ostream& out, const DataExportHandler& de)$/;"	f
operator <<	src\DataExporter.hpp	/^static ostream& operator <<(ostream& out, const DataExporter& d)$/;"	f
operator <<	src\DataExporter.hpp	/^static ostream& operator <<(ostream& out, const Val& v)$/;"	f
operator >>	src\DataExporter.hpp	/^static istream& operator >>(istream& in, Val& v)$/;"	f
param	src\DataExporter.hpp	/^	T& param;$/;"	m	struct:ParamVal
print	src\DataExporter.hpp	/^	void print(ostream& out) const$/;"	f	struct:ParamVal
print	src\DataExporter.hpp	/^	void print(ostream& out) const$/;"	f	struct:RangeVal
print	src\DataExporter.hpp	/^	void print(ostream& out) const$/;"	f	struct:SeqBufferVal
range	src\DataExporter.hpp	/^	R range;$/;"	m	struct:RangeVal
save	src\DataExporter.hpp	/^	template<typename T> void save(T& param, const string& name)$/;"	f	struct:DataExporter
save	src\DataExporter.hpp	/^	void save(ostream& out) const$/;"	f	struct:DataExporter
saveVals	src\DataExporter.hpp	/^	map<string, Val*> saveVals;$/;"	m	struct:DataExporter
save_range	src\DataExporter.hpp	/^	template<typename R> void save_range(const R& range, const string& name)$/;"	f	struct:DataExporter
~DataExporter	src\DataExporter.hpp	/^	~DataExporter()$/;"	f	struct:DataExporter
~Val	src\DataExporter.hpp	/^	virtual ~Val(){}$/;"	f	struct:Val
DataSequence	src\DataSequence.hpp	/^	DataSequence(const DataSequence& ds):$/;"	f	struct:DataSequence
DataSequence	src\DataSequence.hpp	/^	DataSequence(size_t inputDepth = 0, size_t targetPattDepth = 0):$/;"	f	struct:DataSequence
DataSequence	src\DataSequence.hpp	/^struct DataSequence$/;"	s
_INCLUDED_DataSequence_h	src\DataSequence.hpp	19;"	d
importance	src\DataSequence.hpp	/^	SeqBuffer<real_t> importance;$/;"	m	struct:DataSequence
inputClasses	src\DataSequence.hpp	/^	SeqBuffer<int> inputClasses;$/;"	m	struct:DataSequence
inputs	src\DataSequence.hpp	/^	SeqBuffer<real_t> inputs;$/;"	m	struct:DataSequence
label_seq_to_str	src\DataSequence.hpp	/^template<class R> static string label_seq_to_str(const R& labelSeq, const vector<string>& alphabet, const string& delim = " ")$/;"	f
num_timesteps	src\DataSequence.hpp	/^	size_t num_timesteps() const$/;"	f	struct:DataSequence
operator <<	src\DataSequence.hpp	/^static ostream& operator <<(ostream& out, const DataSequence& seq)$/;"	f
print	src\DataSequence.hpp	/^	void print(ostream& out, vector<string>* targetLabels = 0, vector<string>* inputLabels = 0) const$/;"	f	struct:DataSequence
str_to_label_seq	src\DataSequence.hpp	/^static vector<int> str_to_label_seq(const string& labelSeqString, const vector<string>& alphabet)$/;"	f
tag	src\DataSequence.hpp	/^	string tag;$/;"	m	struct:DataSequence
targetClasses	src\DataSequence.hpp	/^	SeqBuffer<int> targetClasses;$/;"	m	struct:DataSequence
targetLabelSeq	src\DataSequence.hpp	/^	vector<int> targetLabelSeq;$/;"	m	struct:DataSequence
targetPatterns	src\DataSequence.hpp	/^	SeqBuffer<real_t> targetPatterns;$/;"	m	struct:DataSequence
targetWordSeq	src\DataSequence.hpp	/^	vector<string> targetWordSeq;$/;"	m	struct:DataSequence
DatasetErrors	src\DatasetErrors.hpp	/^	DatasetErrors(){}$/;"	f	struct:DatasetErrors
DatasetErrors	src\DatasetErrors.hpp	/^struct DatasetErrors$/;"	s
PSPIDE	src\DatasetErrors.hpp	/^typedef pair<const string, pair<int, DatasetErrors> > PSPIDE;$/;"	t
_INCLUDED_DatasetErrors_h	src\DatasetErrors.hpp	19;"	d
add_error	src\DatasetErrors.hpp	/^	void add_error(string name, real_t error, real_t normFactor = 1)$/;"	f	struct:DatasetErrors
add_seq_errors	src\DatasetErrors.hpp	/^	void add_seq_errors(const map<string, real_t>& seqErrors, const map<string, real_t>& seqNorms)$/;"	f	struct:DatasetErrors
clear	src\DatasetErrors.hpp	/^	void clear()$/;"	f	struct:DatasetErrors
errors	src\DatasetErrors.hpp	/^	map<string, real_t> errors;$/;"	m	struct:DatasetErrors
normFactors	src\DatasetErrors.hpp	/^	map<string, real_t> normFactors;$/;"	m	struct:DatasetErrors
normalise	src\DatasetErrors.hpp	/^	void normalise()$/;"	f	struct:DatasetErrors
operator <<	src\DatasetErrors.hpp	/^static ostream& operator << (ostream& out, const DatasetErrors& de)$/;"	f
percentErrors	src\DatasetErrors.hpp	/^	static set<string> percentErrors;$/;"	m	struct:DatasetErrors
percentErrors	src\DatasetErrors.hpp	/^set<string> DatasetErrors::percentErrors = list_of("classificationError")("wordError")("labelError")("seqError")("deletions")("insertions")("substitutions")("ratio");$/;"	m	class:DatasetErrors
percent_error	src\DatasetErrors.hpp	/^	bool percent_error(const string& err) const$/;"	f	struct:DatasetErrors
print	src\DatasetErrors.hpp	/^	void print(ostream& out) const$/;"	f	struct:DatasetErrors
FullConnection	src\FullConnection.hpp	/^	FullConnection(Layer* f, Layer* t, const vector<int>& d = empty_list_of<int>(), FullConnection* s = 0):$/;"	f	struct:FullConnection
FullConnection	src\FullConnection.hpp	/^struct FullConnection: public Connection$/;"	s
_INCLUDED_FullConnection_h	src\FullConnection.hpp	19;"	d
add_delay	src\FullConnection.hpp	/^	const vector<int>* add_delay(const vector<int>& toCoords)$/;"	f	struct:FullConnection
delay	src\FullConnection.hpp	/^	vector<int> delay;$/;"	m	struct:FullConnection
delayedCoords	src\FullConnection.hpp	/^	vector<int> delayedCoords;$/;"	m	struct:FullConnection
derivs	src\FullConnection.hpp	/^	const View<real_t> derivs()$/;"	f	struct:FullConnection
feed_back	src\FullConnection.hpp	/^	void feed_back(const vector<int>& toCoords)$/;"	f	struct:FullConnection
feed_forward	src\FullConnection.hpp	/^	void feed_forward(const vector<int>& toCoords)$/;"	f	struct:FullConnection
make_name	src\FullConnection.hpp	/^	static const string& make_name(Layer* f, Layer* t, const vector<int>& d)$/;"	f	struct:FullConnection
num_weights	src\FullConnection.hpp	/^	size_t num_weights() const$/;"	f	struct:FullConnection
paramRange	src\FullConnection.hpp	/^	pair<size_t, size_t> paramRange;$/;"	m	struct:FullConnection
print	src\FullConnection.hpp	/^	void print(ostream& out) const$/;"	f	struct:FullConnection
set_delay	src\FullConnection.hpp	/^	void set_delay(const vector<int>& d)$/;"	f	struct:FullConnection
source	src\FullConnection.hpp	/^	FullConnection* source;$/;"	m	struct:FullConnection
update_derivs	src\FullConnection.hpp	/^	void update_derivs(const vector<int>& toCoords)$/;"	f	struct:FullConnection
weights	src\FullConnection.hpp	/^	const View<real_t> weights()$/;"	f	struct:FullConnection
~FullConnection	src\FullConnection.hpp	/^	~FullConnection(){}$/;"	f	struct:FullConnection
GatherLayer	src\GatherLayer.hpp	/^	GatherLayer(const string& name, vector<Layer*>& srcs):$/;"	f	struct:GatherLayer
GatherLayer	src\GatherLayer.hpp	/^struct GatherLayer: public Layer$/;"	s
_INCLUDED_GatherLayer_h	src\GatherLayer.hpp	19;"	d
feed_back	src\GatherLayer.hpp	/^	void feed_back(const vector<int>& outCoords)$/;"	f	struct:GatherLayer
feed_forward	src\GatherLayer.hpp	/^	void feed_forward(const vector<int>& outCoords)$/;"	f	struct:GatherLayer
get_size	src\GatherLayer.hpp	/^	int get_size(vector<Layer*>& srcs)$/;"	f	struct:GatherLayer
output	src\GatherLayer.hpp	/^	void output() {$/;"	f	struct:GatherLayer
sources	src\GatherLayer.hpp	/^	vector<Layer*> sources;$/;"	m	struct:GatherLayer
GradientCheck	src\GradientCheck.hpp	/^	GradientCheck(ostream& o, Mdrnn* n, const DataSequence& s, unsigned sf = 6, $/;"	f	struct:GradientCheck
GradientCheck	src\GradientCheck.hpp	/^struct GradientCheck$/;"	s
_INCLUDED_GradientCheck_h	src\GradientCheck.hpp	19;"	d
breakOnError	src\GradientCheck.hpp	/^	bool breakOnError;$/;"	m	struct:GradientCheck
check_connection	src\GradientCheck.hpp	/^	bool check_connection(const string& name, int begin, int end)$/;"	f	struct:GradientCheck
check_layer	src\GradientCheck.hpp	/^	bool check_layer(const string& name)$/;"	f	struct:GradientCheck
checked	src\GradientCheck.hpp	/^	map<string, bool> checked;$/;"	m	struct:GradientCheck
conns	src\GradientCheck.hpp	/^	multimap<string, tuple<string, string, int, int> >& conns;$/;"	m	struct:GradientCheck
derivs	src\GradientCheck.hpp	/^	vector<real_t>& derivs;$/;"	m	struct:GradientCheck
net	src\GradientCheck.hpp	/^	Mdrnn* net;$/;"	m	struct:GradientCheck
out	src\GradientCheck.hpp	/^	ostream& out;$/;"	m	struct:GradientCheck
perturbation	src\GradientCheck.hpp	/^	real_t perturbation;$/;"	m	struct:GradientCheck
seq	src\GradientCheck.hpp	/^	const DataSequence& seq;$/;"	m	struct:GradientCheck
sigFigs	src\GradientCheck.hpp	/^	unsigned sigFigs;$/;"	m	struct:GradientCheck
verbose	src\GradientCheck.hpp	/^	bool verbose;$/;"	m	struct:GradientCheck
weights	src\GradientCheck.hpp	/^	vector<real_t>& weights;$/;"	m	struct:GradientCheck
BMISLCI	src\Helpers.hpp	/^typedef bimap<int, string>::left_const_iterator BMISLCI;$/;"	t
BMISR	src\Helpers.hpp	/^typedef bimap<int, string>::relation BMISR;$/;"	t
BMISRCI	src\Helpers.hpp	/^typedef bimap<int, string>::right_const_iterator BMISRCI;$/;"	t
CHECK_STRICT	src\Helpers.hpp	162;"	d
COD	src\Helpers.hpp	63;"	d
COUT	src\Helpers.hpp	/^static ostream& COUT = cout;$/;"	v
DO	src\Helpers.hpp	60;"	d
DOC	src\Helpers.hpp	61;"	d
FOR	src\Helpers.hpp	67;"	d
FROM	src\Helpers.hpp	65;"	d
KL_normal	src\Helpers.hpp	/^static real_t KL_normal(real_t pMean, real_t pVar, real_t qMean, real_t qVar)$/;"	f
LOOP	src\Helpers.hpp	58;"	d
LOOP_BACK	src\Helpers.hpp	59;"	d
MCSPDICI	src\Helpers.hpp	/^typedef map <string, pair<real_t, int> >::const_iterator MCSPDICI;$/;"	t
MCSPDII	src\Helpers.hpp	/^typedef map <string, pair<real_t, int> >::iterator MCSPDII;$/;"	t
MIICI	src\Helpers.hpp	/^typedef map<int, int>::const_iterator MIICI;$/;"	t
MIII	src\Helpers.hpp	/^typedef map<int, int>::iterator MIII;$/;"	t
MORF	src\Helpers.hpp	66;"	d
MSDCI	src\Helpers.hpp	/^typedef map<string, real_t>::const_iterator MSDCI;$/;"	t
MSDI	src\Helpers.hpp	/^typedef map<string, real_t>::iterator MSDI;$/;"	t
MSICI	src\Helpers.hpp	/^typedef map<string, int>::const_iterator MSICI;$/;"	t
MSII	src\Helpers.hpp	/^typedef map<string, int>::iterator MSII;$/;"	t
MSPIDCI	src\Helpers.hpp	/^typedef map<string, pair<int,real_t> >::const_iterator MSPIDCI;$/;"	t
MSPIDI	src\Helpers.hpp	/^typedef map<string, pair<int,real_t> >::iterator MSPIDI;$/;"	t
MSSCI	src\Helpers.hpp	/^typedef map<string, string>::const_iterator MSSCI;$/;"	t
MSSI	src\Helpers.hpp	/^typedef map<string, string>::iterator MSSI;$/;"	t
OD	src\Helpers.hpp	62;"	d
PCSD	src\Helpers.hpp	/^typedef pair<const string, real_t> PCSD;$/;"	t
PII	src\Helpers.hpp	/^typedef pair<int, int> PII;$/;"	t
PIS	src\Helpers.hpp	/^typedef pair<int, string> PIS;$/;"	t
PRINT	src\Helpers.hpp	155;"	d
PRINTN	src\Helpers.hpp	156;"	d
PRINTR	src\Helpers.hpp	159;"	d
PRT	src\Helpers.hpp	157;"	d
PRTN	src\Helpers.hpp	158;"	d
PRTR	src\Helpers.hpp	160;"	d
PSD	src\Helpers.hpp	/^typedef pair<string, real_t> PSD;$/;"	t
PSI	src\Helpers.hpp	/^typedef pair<string, int> PSI;$/;"	t
PSS	src\Helpers.hpp	/^typedef pair<string, string> PSS;$/;"	t
REPEAT	src\Helpers.hpp	64;"	d
ROF	src\Helpers.hpp	68;"	d
SCI	src\Helpers.hpp	/^typedef string::const_iterator SCI;$/;"	t
SI	src\Helpers.hpp	/^typedef string::iterator SI;$/;"	t
TDD	src\Helpers.hpp	/^typedef const tuple<real_t&, real_t&>& TDD;$/;"	t
TDDCF	src\Helpers.hpp	/^typedef const tuple<real_t&, real_t&, real_t>& TDDCF;$/;"	t
TDDD	src\Helpers.hpp	/^typedef const tuple<real_t&, real_t&, real_t&>& TDDD;$/;"	t
TDDDD	src\Helpers.hpp	/^typedef const tuple<real_t&, real_t&, real_t&, real_t&>& TDDDD;$/;"	t
TDDDDD	src\Helpers.hpp	/^typedef const tuple<real_t&, real_t&, real_t&, real_t&, real_t&>& TDDDDD;$/;"	t
TDDF	src\Helpers.hpp	/^typedef const tuple<real_t&, real_t&, real_t&>& TDDF;$/;"	t
TDDI	src\Helpers.hpp	/^typedef const tuple<real_t&, real_t&, int&>& TDDI;$/;"	t
TDL	src\Helpers.hpp	/^typedef const tuple<real_t, Log<real_t>& >& TDL;$/;"	t
TDLL	src\Helpers.hpp	/^typedef const tuple<real_t&, Log<real_t>, Log<real_t> >& TDLL;$/;"	t
TIBI	src\Helpers.hpp	/^typedef const tuple<int&, bool, int>& TIBI;$/;"	t
TID	src\Helpers.hpp	/^typedef const tuple<int, real_t>& TID;$/;"	t
TII	src\Helpers.hpp	/^typedef const tuple<int, int>& TII;$/;"	t
TIS	src\Helpers.hpp	/^typedef const tuple<int, string>& TIS;$/;"	t
TISETI	src\Helpers.hpp	/^typedef const tuple<int, set<int>&>& TISETI;$/;"	t
VBCI	src\Helpers.hpp	/^typedef vector<bool>::const_iterator VBCI;$/;"	t
VBI	src\Helpers.hpp	/^typedef vector<bool>::iterator VBI;$/;"	t
VDCI	src\Helpers.hpp	/^typedef vector<real_t>::const_iterator VDCI;$/;"	t
VDI	src\Helpers.hpp	/^typedef vector<real_t>::iterator VDI;$/;"	t
VDRI	src\Helpers.hpp	/^typedef vector<real_t>::reverse_iterator VDRI;$/;"	t
VFCI	src\Helpers.hpp	/^typedef vector<real_t>::const_iterator VFCI;$/;"	t
VFI	src\Helpers.hpp	/^typedef vector<real_t>::iterator VFI;$/;"	t
VICI	src\Helpers.hpp	/^typedef vector<int>::const_iterator VICI;$/;"	t
VII	src\Helpers.hpp	/^typedef vector<int>::iterator VII;$/;"	t
VIRCI	src\Helpers.hpp	/^typedef vector<int>::const_reverse_iterator VIRCI;$/;"	t
VIRI	src\Helpers.hpp	/^typedef vector<int>::reverse_iterator VIRI;$/;"	t
VMSDCI	src\Helpers.hpp	/^typedef vector< map<string, pair<int,real_t> > >::const_iterator VMSDCI;$/;"	t
VMSDI	src\Helpers.hpp	/^typedef vector<map<string, pair<int,real_t> > >::iterator VMSDI;$/;"	t
VMSDRI	src\Helpers.hpp	/^typedef vector<map<string, pair<int,real_t> > >::reverse_iterator VMSDRI;$/;"	t
VPCFCI	src\Helpers.hpp	/^typedef vector<const real_t*>::const_iterator VPCFCI;$/;"	t
VPCFCRI	src\Helpers.hpp	/^typedef vector<const real_t*>::const_reverse_iterator VPCFCRI;$/;"	t
VPCFI	src\Helpers.hpp	/^typedef vector<const real_t*>::iterator VPCFI;$/;"	t
VSCI	src\Helpers.hpp	/^typedef vector<string>::const_iterator VSCI;$/;"	t
VSI	src\Helpers.hpp	/^typedef vector<string>::iterator VSI;$/;"	t
VSTCI	src\Helpers.hpp	/^typedef vector<size_t>::const_iterator VSTCI;$/;"	t
VUII	src\Helpers.hpp	/^typedef vector<unsigned int>::iterator VUII;$/;"	t
VVDCI	src\Helpers.hpp	/^typedef vector<vector<real_t> >::const_iterator VVDCI;$/;"	t
VVDI	src\Helpers.hpp	/^typedef vector<vector<real_t> >::iterator VVDI;$/;"	t
VVFI	src\Helpers.hpp	/^typedef vector<vector<real_t> >::iterator VVFI;$/;"	t
VVICI	src\Helpers.hpp	/^typedef vector<vector<int> >::const_iterator VVICI;$/;"	t
VVII	src\Helpers.hpp	/^typedef vector<vector<int> >::iterator VVII;$/;"	t
VVIRCI	src\Helpers.hpp	/^typedef vector<vector<int> >::const_reverse_iterator VVIRCI;$/;"	t
VVIRI	src\Helpers.hpp	/^typedef vector<vector<int> >::reverse_iterator VVIRI;$/;"	t
_INCLUDED_Helpers_h	src\Helpers.hpp	19;"	d
abs_sum	src\Helpers.hpp	/^template <class R> static typename range_value<R>::type abs_sum(const R& r)$/;"	f
arg_max	src\Helpers.hpp	/^template <class R> static int arg_max(const R& r)$/;"	f
at	src\Helpers.hpp	/^template<class T1, class T2> static const T2& at(const map<T1, T2>& a, const T1& b)$/;"	f
bits_to_nats	src\Helpers.hpp	/^static real_t bits_to_nats(real_t bits)$/;"	f
bound	src\Helpers.hpp	/^template <class T> static T bound (const T& v, const T& minVal, const T& maxVal)$/;"	f
bound_range	src\Helpers.hpp	/^template <class R> static void bound_range (R& r, const typename boost::range_value<R>::type& minVal, const typename boost::range_value<R>::type& maxVal)$/;"	f
check	src\Helpers.hpp	161;"	d
copy	src\Helpers.hpp	/^template<class R1, class R2> static void copy(const R1& source, R2& dest)$/;"	f
count	src\Helpers.hpp	/^template<class R> static size_t count(const R& r, const typename boost::range_value<R>::type& v)$/;"	f
count_adjacent	src\Helpers.hpp	/^template <class R> static size_t count_adjacent(const R& r)$/;"	f
delete_map	src\Helpers.hpp	/^template<class R> void delete_map(R& r)$/;"	f
delete_range	src\Helpers.hpp	/^template<class R> void delete_range(R& r)$/;"	f
difference	src\Helpers.hpp	/^template <class T1, class T2> static size_t difference(const pair<T1,T2>& p)$/;"	f
disjoint	src\Helpers.hpp	/^template<class T> static bool disjoint(const set<T>& s1, const set<T>& s2)$/;"	f
empty_list_of	src\Helpers.hpp	/^template<class T> static assign_detail::generic_list<T> empty_list_of()$/;"	f
enumerate	src\Helpers.hpp	/^enumerate(R& r)$/;"	f
equal	src\Helpers.hpp	/^template<class R1, class R2> static bool equal(const R1& source, R2& dest)$/;"	f
euclidean_squared	src\Helpers.hpp	/^template <class R1, class R2> typename boost::range_value<R1>::type euclidean_squared(const R1& r1, const R2& r2)$/;"	f
fill	src\Helpers.hpp	/^template<class R> static void fill (R& r, const typename boost::range_value<R>::type& v)$/;"	f
find	src\Helpers.hpp	/^template <class R, class T> static typename range_iterator<R>::type find(R& r, const T& t)$/;"	f
flip	src\Helpers.hpp	/^template <class R> static vector<typename boost::range_value<R>::type>& flip(const R& r)$/;"	f
flood	src\Helpers.hpp	/^template<class R> static void flood(R& r, size_t size, const typename boost::range_value<R>::type& v = 0)$/;"	f
for_each	src\Helpers.hpp	/^template <class R, class UnaryFunction> static UnaryFunction for_each(R& r, UnaryFunction f)$/;"	f
gauss_pdf	src\Helpers.hpp	/^template<class T1, class T2, class T3, class T4> static T1 gauss_pdf(const T2& x, const T3& mean, const T4& stdDev)$/;"	f
in	src\Helpers.hpp	/^template <class R, class T> static bool in(const R& r, const T& t)$/;"	f
in	src\Helpers.hpp	/^template<class T1, class T2> static bool in(const map<T1, T2>& a, const T1& b)$/;"	f
in	src\Helpers.hpp	/^template<class T1, class T2> static bool in(const multimap<T1, T2>& a, const T1& b)$/;"	f
in_closed_interval	src\Helpers.hpp	/^template<class T> static bool in_closed_interval(pair<T,T> interval, T val)$/;"	f
in_left	src\Helpers.hpp	/^template<class T1, class T2> static bool in_left(const bimap<T1, T2>& a, const T1& b)$/;"	f
in_open_interval	src\Helpers.hpp	/^template<class T> static bool in_open_interval(pair<T,T> interval, T val)$/;"	f
in_range	src\Helpers.hpp	/^template <class R> static bool in_range(R& r, size_t n)$/;"	f
in_right	src\Helpers.hpp	/^template<class T1, class T2> static bool in_right(const bimap<T1, T2>& a, const T2& b)$/;"	f
index	src\Helpers.hpp	/^template <class R, class T> static size_t index(const R& r, const T& t)$/;"	f
indices	src\Helpers.hpp	/^template <class R> static integer_range<typename boost::range_size<R>::type> indices(const R& r)$/;"	f
infinity	src\Helpers.hpp	/^static const real_t infinity = numeric_limits<real_t>::infinity();$/;"	v
inner_product	src\Helpers.hpp	/^template<class R1, class R2> static typename range_value<R1>::type inner_product(const R1& a, const R2& b, typename range_value<R1>::type c = 0)$/;"	f
integer	src\Helpers.hpp	/^template<class T> static int integer(const T& t)$/;"	f
intersecting	src\Helpers.hpp	/^template<class T> static bool intersecting(const set<T>& s1, const set<T>& s2)$/;"	f
iota	src\Helpers.hpp	/^template <class T1, class T2> static vector<T1> iota(const T2& t)$/;"	f
iota	src\Helpers.hpp	/^template <class T1, class T2> static vector<T1> iota(const T2& t1, const T2& t2)$/;"	f
last_index	src\Helpers.hpp	/^template <class R> static size_t last_index(R& r)$/;"	f
log_sum	src\Helpers.hpp	/^template <class R> static typename range_value<R>::type log_sum(const R& r)$/;"	f
mark	src\Helpers.hpp	/^static void mark()$/;"	f
max	src\Helpers.hpp	/^template <class R> static typename range_value<R>::type max(const R& r)$/;"	f
mean	src\Helpers.hpp	/^template <class R> static typename range_value<R>::type mean(const R& r)$/;"	f
minmax	src\Helpers.hpp	/^template <class R> pair<typename range_value<R>::type, typename range_value<R>::type> minmax(const R& r)$/;"	f
nats_to_bits	src\Helpers.hpp	/^static real_t nats_to_bits(real_t nats)$/;"	f
natural	src\Helpers.hpp	/^template<class T> static size_t natural(const T& t)$/;"	f
norm	src\Helpers.hpp	/^template <class R> static typename range_value<R>::type norm(const R& r)$/;"	f
nth_last	src\Helpers.hpp	/^template <class R> static typename range_value<R>::type& nth_last(R& r, size_t n = 1)$/;"	f
operator *=	src\Helpers.hpp	/^template<class T1, class T2, class T3, class T4> static void operator *=(map<T1, T2>& a, const map<T3, T4>& b)$/;"	f
operator *=	src\Helpers.hpp	/^template<class T1, class T2, class T3> static void operator *=(map<T1, T2>& a, const T3& b)$/;"	f
operator +	src\Helpers.hpp	/^template<class T1, class T2, class T3> static pair<T1, T2> operator+ (const pair<T1, T2>& a, const T3& b)$/;"	f
operator +=	src\Helpers.hpp	/^template<class T1, class T2, class T3, class T4> static void operator +=(map<T1, T2>& a, const map<T3, T4>& b)$/;"	f
operator +=	src\Helpers.hpp	/^template<class T1, class T2> static void operator+= (pair<T1, T2>& a, const pair<T1, T2>& b)$/;"	f
operator -=	src\Helpers.hpp	/^template<class T1, class T2, class T3, class T4> static void operator -=(map<T1, T2>& a, const map<T3, T4>& b)$/;"	f
operator /=	src\Helpers.hpp	/^template<class T1, class T2, class T3, class T4> static void operator \/=(map<T1, T2>& a, const map<T3, T4>& b)$/;"	f
operator /=	src\Helpers.hpp	/^template<class T1, class T2, class T3> static void operator \/=(map<T1, T2>& a, const T3& b)$/;"	f
operator <<	src\Helpers.hpp	/^template <class C, class Tr, class R> static basic_ostream<C, Tr>& operator <<(basic_ostream<C, Tr>& out, const R& r)$/;"	f
operator <<	src\Helpers.hpp	/^template<class T1, class T2, class T3, class T4, class T5> static ostream& operator << (ostream& out, const tuple<T1, T2, T3, T4, T5>& t)$/;"	f
operator <<	src\Helpers.hpp	/^template<class T1, class T2, class T3, class T4> static ostream& operator << (ostream& out, const tuple<T1, T2, T3, T4>& t)$/;"	f
operator <<	src\Helpers.hpp	/^template<class T1, class T2, class T3, class T4> static ostream& operator <<(ostream& out, const boost::bimaps::relation::structured_pair<T1, T2, T3, T4>& p)$/;"	f
operator <<	src\Helpers.hpp	/^template<class T1, class T2, class T3> static ostream& operator << (ostream& out, const tuple<T1, T2, T3>& t)$/;"	f
operator <<	src\Helpers.hpp	/^template<class T1, class T2> static ostream& operator << (ostream& out, const bimap<T1, T2>& m)$/;"	f
operator <<	src\Helpers.hpp	/^template<class T1, class T2> static ostream& operator << (ostream& out, const pair<T1, T2>& p)$/;"	f
operator <<	src\Helpers.hpp	/^template<class T1, class T2> static ostream& operator << (ostream& out, const tuple<T1, T2>& t)$/;"	f
operator <<	src\Helpers.hpp	/^template<class T1, class T2> static ostream& operator <<(ostream& out, const map<T1, T2*>& m)$/;"	f
operator <<	src\Helpers.hpp	/^template<class T1, class T2> static ostream& operator <<(ostream& out, const map<T1, T2>& m)$/;"	f
operator >>	src\Helpers.hpp	/^template <class C, class Tr, class R> static basic_istream<C, Tr>& operator >>(basic_istream<C, Tr>& in, R& r)$/;"	f
pair_mean	src\Helpers.hpp	/^template<class T1, class T2> static real_t pair_mean(const pair<T1, T2>& p)$/;"	f
pair_product	src\Helpers.hpp	/^template<class T1, class T2> static real_t pair_product(const pair<T1, T2>& p)$/;"	f
pair_sum	src\Helpers.hpp	/^template<class T1, class T2> static real_t pair_sum(const pair<T1, T2>& p)$/;"	f
print	src\Helpers.hpp	/^template<class T1, class T2, class T3, class T4, class T5> static void print(const T1& t1, const T2& t2, const T3& t3, const T4& t4, const T5& t5, ostream& out = cout)$/;"	f
print	src\Helpers.hpp	/^template<class T1, class T2, class T3, class T4> static void print(const T1& t1, const T2& t2, const T3& t3, const T4& t4, ostream& out = cout)$/;"	f
print	src\Helpers.hpp	/^template<class T1, class T2, class T3> static void print(const T1& t1, const T2& t2, const T3& t3, ostream& out = cout)$/;"	f
print	src\Helpers.hpp	/^template<class T1, class T2> static void print(const T1& t1, const T2& t2, ostream& out = cout)$/;"	f
print	src\Helpers.hpp	/^template<class T> static void print(const T& t, ostream& out = cout)$/;"	f
print_bimap	src\Helpers.hpp	/^template<class T1, class T2> void print_bimap (const bimap<T1, T2>& m, ostream& out)$/;"	f
print_left	src\Helpers.hpp	/^template<class T1, class T2> static void print_left(const map<T1, T2>& m, ostream& out = cout, const char delim = ' ')$/;"	f
print_range	src\Helpers.hpp	/^template <class C, class Tr, class R> static void print_range(basic_ostream<C, Tr>& out, const R& r, const basic_string<C, Tr>& delim = " ")$/;"	f
print_range	src\Helpers.hpp	/^template <class C, class Tr, class R> static void print_range(basic_ostream<C, Tr>& out, const R& r, const char delim)$/;"	f
print_right	src\Helpers.hpp	/^template<class T1, class T2> static void print_right(const map<T1, T2>& m, ostream& out = cout, const char delim = ' ')$/;"	f
print_time	src\Helpers.hpp	/^static void print_time(real_t totalSeconds, ostream& out = cout, bool abbrv = false)$/;"	f
prob_t	src\Helpers.hpp	/^typedef Log<real_t> prob_t;$/;"	t
product	src\Helpers.hpp	/^template <class R> static typename range_value<R>::type product(const R& r)$/;"	f
prt_line	src\Helpers.hpp	/^static void prt_line(ostream& out = cout)$/;"	f
range_divide	src\Helpers.hpp	/^template<class R1, class R2, class R3> static void range_divide(R1& a, const R2& b, const R3& c)$/;"	f
range_divide_equals	src\Helpers.hpp	/^template<class R1, class R2> static void range_divide_equals(R1& a, const R2& b)$/;"	f
range_divide_val	src\Helpers.hpp	/^template<class R1, class R2> static void range_divide_val(R1& a, const R2& b, const typename boost::range_value<R1>::type& c)$/;"	f
range_divide_val	src\Helpers.hpp	/^template<class R> static void range_divide_val(R& a, const typename boost::range_value<R>::type& b)$/;"	f
range_indep_gauss_pdf	src\Helpers.hpp	/^template<class T, class R1, class R2, class R3> static T range_indep_gauss_pdf(const R1& variables, const R2& means, const R3& stdDevs)$/;"	f
range_min_size	src\Helpers.hpp	/^template<class R1, class R2, class R3, class R4, class R5> static size_t range_min_size (const R1& a, const R2& b, const R3& c, const R4& d, const R5& e)$/;"	f
range_min_size	src\Helpers.hpp	/^template<class R1, class R2, class R3, class R4> static size_t range_min_size (const R1& a, const R2& b, const R3& c, const R4& d)$/;"	f
range_min_size	src\Helpers.hpp	/^template<class R1, class R2, class R3> static size_t range_min_size (const R1& a, const R2& b, const R3& c)$/;"	f
range_min_size	src\Helpers.hpp	/^template<class R1, class R2> static size_t range_min_size (const R1& a, const R2& b)$/;"	f
range_minus	src\Helpers.hpp	/^template<class R1, class R2, class R3> static void range_minus(R1& a, const R2& b, const R3& c)$/;"	f
range_minus_equals	src\Helpers.hpp	/^template<class R1, class R2> static void range_minus_equals(R1& a, const R2& b)$/;"	f
range_minus_val	src\Helpers.hpp	/^template<class R1, class R2> static void range_minus_val(R1& a, const R2& b, const typename boost::range_value<R2>::type& c)$/;"	f
range_minus_val	src\Helpers.hpp	/^template<class R> static void range_minus_val(R& a, const typename boost::range_value<R>::type& b)$/;"	f
range_multiply	src\Helpers.hpp	/^template<class R1, class R2, class R3> static void range_multiply(R1& a, const R2& b, const R3& c)$/;"	f
range_multiply_add	src\Helpers.hpp	/^template<class R1, class R2, class R3> static void range_multiply_add(R1& a, const R2& b, const R3& c)$/;"	f
range_multiply_equals	src\Helpers.hpp	/^template<class R1, class R2> static void range_multiply_equals(R1& a, const R2& b)$/;"	f
range_multiply_val	src\Helpers.hpp	/^template<class R1, class R2> static void range_multiply_val(R1& a, const R2& b, const typename boost::range_value<R2>::type& c)$/;"	f
range_multiply_val	src\Helpers.hpp	/^template<class R> static void range_multiply_val(R& a, const typename boost::range_value<R>::type& b)$/;"	f
range_negate	src\Helpers.hpp	/^template<class R> static vector<typename boost::range_value<R>::type>& range_negate(const R& r)$/;"	f
range_negate_equals	src\Helpers.hpp	/^template<class R> static void range_negate_equals(R& r)$/;"	f
range_plus	src\Helpers.hpp	/^template<class R1, class R2, class R3> static R1& range_plus(R1& a, const R2& b, const R3& c)$/;"	f
range_plus_equals	src\Helpers.hpp	/^template<class R1, class R2> static void range_plus_equals(R1& a, const R2& b)$/;"	f
range_plus_val	src\Helpers.hpp	/^template<class R1, class R2> static void range_plus_val(R1& a, const R2& b, const typename boost::range_value<R2>::type& c)$/;"	f
range_plus_val	src\Helpers.hpp	/^template<class R> static void range_plus_val(R& a, const typename boost::range_value<R>::type& b)$/;"	f
read	src\Helpers.hpp	/^template<class T> static T read(const string& data)$/;"	f
real	src\Helpers.hpp	/^template<class T> static real_t real(const T& t)$/;"	f
realMax	src\Helpers.hpp	/^static const real_t realMax = numeric_limits<real_t>::max();$/;"	v
realMin	src\Helpers.hpp	/^static const real_t realMin = numeric_limits<real_t>::min();$/;"	v
real_t	src\Helpers.hpp	/^typedef float real_t;$/;"	t
reverse	src\Helpers.hpp	/^template <class R> static void reverse(R& r)$/;"	f
reverse_copy	src\Helpers.hpp	/^template<class R1, class R2> static void reverse_copy(const R1& source, R2& dest)$/;"	f
reverse_sort	src\Helpers.hpp	/^template <class R> static R& reverse_sort(R& r)$/;"	f
runningGradTest	src\Helpers.hpp	/^static bool runningGradTest = false;$/;"	v
select_channels	src\Helpers.hpp	/^template <class R1, class R2> static vector<typename boost::range_value<R1>::type>& select_channels(const R1& r, const R2& channels)$/;"	f
shuffle	src\Helpers.hpp	/^template<class R> static R& shuffle (R& r)$/;"	f
sign	src\Helpers.hpp	/^template<class T> static int sign(const T& t)$/;"	f
sort	src\Helpers.hpp	/^template <class R> static R& sort(R& r)$/;"	f
span	src\Helpers.hpp	/^template <class T1, class T2> static integer_range<T2> span(T1 t1, T2 t2)$/;"	f
span	src\Helpers.hpp	/^template <class T> static integer_range<T> span(T t)$/;"	f
squared	src\Helpers.hpp	/^template<class T> static T squared(const T& t)$/;"	f
std_dev	src\Helpers.hpp	/^template <class R> static typename range_value<R>::type std_dev(const R& r)$/;"	f
str	src\Helpers.hpp	/^template<class T> static string str(const T& t)$/;"	f
sum	src\Helpers.hpp	/^template <class R> static typename range_value<R>::type sum(const R& r)$/;"	f
sum_of_squares	src\Helpers.hpp	/^template <class R1, class R2> static typename range_value<R1>::type sum_of_squares(const R1& r1, const R2& r2)$/;"	f
sum_right	src\Helpers.hpp	/^template<class T1, class T2> static T2 sum_right(const map<T1, T2>& m)$/;"	f
time_stamp	src\Helpers.hpp	/^static string time_stamp(const string& format = "%Y.%m.%d-%H.%M.%S%F%Q")$/;"	f
transform	src\Helpers.hpp	/^template <class R1, class R2, class F> static typename range_iterator<R2>::type transform(const R1& r1, R2& r2, const F& f)$/;"	f
variance	src\Helpers.hpp	/^template <class R> static typename range_value<R>::type variance(const R& r)$/;"	f
vector_assign	src\Helpers.hpp	/^template<class R, class T> void vector_assign(const R& r, vector<T>& v)$/;"	f
verbose	src\Helpers.hpp	/^static bool verbose = false;$/;"	v
warn_unless	src\Helpers.hpp	/^static bool warn_unless (bool condition, const string& str, ostream& out = cout)$/;"	f
zip	src\Helpers.hpp	/^zip(R1& r1, R2& r2)$/;"	f
zip	src\Helpers.hpp	/^zip(R1& r1, R2& r2, R3& r3)$/;"	f
zip	src\Helpers.hpp	/^zip(R1& r1, R2& r2, R3& r3, R4& r4)$/;"	f
zip	src\Helpers.hpp	/^zip(R1& r1, R2& r2, R3& r3, R4& r4, R5& r5)$/;"	f
IdentityLayer	src\IdentityLayer.hpp	/^	IdentityLayer(const string& name, const vector<int>& directions, size_t size):$/;"	f	struct:IdentityLayer
IdentityLayer	src\IdentityLayer.hpp	/^	IdentityLayer(const string& name, size_t numSeqDims, size_t size):$/;"	f	struct:IdentityLayer
IdentityLayer	src\IdentityLayer.hpp	/^struct IdentityLayer: public FlatLayer$/;"	s
_INCLUDED_IdentityLayer_h	src\IdentityLayer.hpp	19;"	d
feed_back	src\IdentityLayer.hpp	/^	void feed_back(const vector<int>& coords)$/;"	f	struct:IdentityLayer
feed_forward	src\IdentityLayer.hpp	/^	void feed_forward(const vector<int>& coords)$/;"	f	struct:IdentityLayer
output	src\IdentityLayer.hpp	/^	void output() {$/;"	f	struct:IdentityLayer
InputLayer	src\InputLayer.hpp	/^	InputLayer(const string& name, size_t numSeqDims, size_t size, const vector<string>& inputLabels):$/;"	f	struct:InputLayer
InputLayer	src\InputLayer.hpp	/^struct InputLayer: public Layer$/;"	s
_INCLUDED_InputLayer_h	src\InputLayer.hpp	19;"	d
copy_inputs	src\InputLayer.hpp	/^	template<typename T> void copy_inputs(const SeqBuffer<T>& inputs)$/;"	f	struct:InputLayer
output	src\InputLayer.hpp	/^	void output() {$/;"	f	struct:InputLayer
~InputLayer	src\InputLayer.hpp	/^	~InputLayer(){}$/;"	f	struct:InputLayer
FlatLayer	src\Layer.hpp	/^	FlatLayer(const string& name, const vector<int>& dirs, size_t size, Layer* src = 0):$/;"	f	struct:FlatLayer
FlatLayer	src\Layer.hpp	/^	FlatLayer(const string& name, size_t numSeqDims, size_t size, Layer* src = 0):$/;"	f	struct:FlatLayer
FlatLayer	src\Layer.hpp	/^struct FlatLayer: public Layer$/;"	s
Layer	src\Layer.hpp	/^	Layer(const string& name, const vector<int>& dirs, size_t inputSize, size_t outputSize, Layer* src = 0):$/;"	f	struct:Layer
Layer	src\Layer.hpp	/^	Layer(const string& name, size_t numSeqDims, size_t inputSize, size_t outputSize, Layer* src = 0):$/;"	f	struct:Layer
Layer	src\Layer.hpp	/^struct Layer: public DataExporter$/;"	s
_INCLUDED_Layer_h	src\Layer.hpp	19;"	d
build	src\Layer.hpp	/^	virtual void build()$/;"	f	struct:Layer
directions	src\Layer.hpp	/^	vector<int> directions;$/;"	m	struct:Layer
feed_back	src\Layer.hpp	/^	virtual void feed_back(const vector<int>& coords){}$/;"	f	struct:Layer
feed_forward	src\Layer.hpp	/^	virtual void feed_forward(const vector<int>& coords){}$/;"	f	struct:Layer
inputActivations	src\Layer.hpp	/^	SeqBuffer<real_t> inputActivations;$/;"	m	struct:Layer
inputErrors	src\Layer.hpp	/^	SeqBuffer<real_t> inputErrors;$/;"	m	struct:Layer
input_seq_begin	src\Layer.hpp	/^	virtual SeqIterator input_seq_begin() const$/;"	f	struct:Layer
input_seq_rbegin	src\Layer.hpp	/^	virtual SeqIterator input_seq_rbegin() const$/;"	f	struct:Layer
input_seq_shape	src\Layer.hpp	/^	virtual const View<const size_t> input_seq_shape() const$/;"	f	struct:Layer
input_size	src\Layer.hpp	/^	virtual size_t input_size() const$/;"	f	struct:Layer
num_seq_dims	src\Layer.hpp	/^	virtual size_t num_seq_dims() const$/;"	f	struct:Layer
operator <<	src\Layer.hpp	/^ostream& operator << (ostream& out, const Layer& l)$/;"	f
out_acts	src\Layer.hpp	/^	virtual const View<real_t> out_acts(const vector<int>& coords)$/;"	f	struct:Layer
out_errs	src\Layer.hpp	/^	virtual const View<real_t> out_errs(const vector<int>& coords)$/;"	f	struct:Layer
output	src\Layer.hpp	/^	virtual void output() {$/;"	f	struct:FlatLayer
output	src\Layer.hpp	/^	virtual void output() {$/;"	f	struct:Layer
outputActivations	src\Layer.hpp	/^	SeqBuffer<real_t> outputActivations;$/;"	m	struct:Layer
outputErrors	src\Layer.hpp	/^	SeqBuffer<real_t> outputErrors;$/;"	m	struct:Layer
output_seq_begin	src\Layer.hpp	/^	virtual SeqIterator output_seq_begin() const$/;"	f	struct:Layer
output_seq_shape	src\Layer.hpp	/^	virtual const View<const size_t> output_seq_shape() const$/;"	f	struct:Layer
output_size	src\Layer.hpp	/^	virtual size_t output_size() const$/;"	f	struct:Layer
print	src\Layer.hpp	/^	virtual void print(ostream& out = cout) const$/;"	f	struct:Layer
reshape_errors	src\Layer.hpp	/^	virtual void reshape_errors()$/;"	f	struct:Layer
source	src\Layer.hpp	/^	Layer* source;$/;"	m	struct:Layer
start_sequence	src\Layer.hpp	/^	virtual void start_sequence()$/;"	f	struct:Layer
update_derivs	src\Layer.hpp	/^	virtual void update_derivs(const vector<int>& coords){}$/;"	f	struct:Layer
weights	src\Layer.hpp	/^	virtual const View<real_t> weights(){return View<real_t>();}$/;"	f	struct:Layer
~Layer	src\Layer.hpp	/^	virtual ~Layer(){}$/;"	f	struct:Layer
Log	src\Log.hpp	/^	Log(T v = 0, bool logScale = false):$/;"	f	class:Log
Log	src\Log.hpp	/^template<class T> class Log$/;"	c
_INCLUDED_Log_h	src\Log.hpp	19;"	d
exp	src\Log.hpp	/^	T exp()$/;"	f	class:Log
expLimit	src\Log.hpp	/^	static const T expLimit;$/;"	m	class:Log
expLimit	src\Log.hpp	/^template <class T> const T Log<T>::expLimit = std::log(expMax);$/;"	m	class:Log
expMax	src\Log.hpp	/^	static const T expMax;$/;"	m	class:Log
expMax	src\Log.hpp	/^template <class T> const T Log<T>::expMax = numeric_limits<T>::max();$/;"	m	class:Log
expMin	src\Log.hpp	/^	static const T expMin;$/;"	m	class:Log
expMin	src\Log.hpp	/^template <class T> const T Log<T>::expMin = numeric_limits<T>::min();$/;"	m	class:Log
expVal	src\Log.hpp	/^	T expVal;$/;"	m	class:Log
log	src\Log.hpp	/^	T log() const$/;"	f	class:Log
logInfinity	src\Log.hpp	/^	static const T logInfinity;$/;"	m	class:Log
logInfinity	src\Log.hpp	/^template <class T> const T Log<T>::logInfinity = 1e100;$/;"	m	class:Log
logVal	src\Log.hpp	/^	T logVal;$/;"	m	class:Log
logZero	src\Log.hpp	/^	static const T logZero;$/;"	m	class:Log
logZero	src\Log.hpp	/^template <class T> const T Log<T>::logZero = -Log<T>::logInfinity;$/;"	m	class:Log
log_add	src\Log.hpp	/^	static T log_add(T x, T y)$/;"	f	class:Log
log_divide	src\Log.hpp	/^	static T log_divide(T x, T y)$/;"	f	class:Log
log_multiply	src\Log.hpp	/^	static T log_multiply(T x, T y)$/;"	f	class:Log
log_subtract	src\Log.hpp	/^	static T log_subtract(T x, T y)$/;"	f	class:Log
operator *	src\Log.hpp	/^template<class T> Log<T> operator *(Log<T> log1, Log<T> log2)$/;"	f
operator *=	src\Log.hpp	/^	Log<T>& operator *=(const Log<T>& l)$/;"	f	class:Log
operator +	src\Log.hpp	/^template<class T> Log<T> operator +(Log<T> log1, Log<T> log2)$/;"	f
operator +=	src\Log.hpp	/^	Log<T>& operator +=(const Log<T>& l)$/;"	f	class:Log
operator -	src\Log.hpp	/^template<class T> Log<T> operator -(Log<T> log1, Log<T> log2)$/;"	f
operator -=	src\Log.hpp	/^	Log<T>& operator -=(const Log<T>& l)$/;"	f	class:Log
operator /	src\Log.hpp	/^template<class T> Log<T> operator \/(Log<T> log1, Log<T> log2)$/;"	f
operator /=	src\Log.hpp	/^	Log<T>& operator \/=(const Log<T>& l)$/;"	f	class:Log
operator <	src\Log.hpp	/^template<class T> bool operator <(Log<T> log1, Log<T> log2)$/;"	f
operator <<	src\Log.hpp	/^template<class T> ostream& operator <<(ostream& out, const Log<T>& l)$/;"	f
operator <=	src\Log.hpp	/^template<class T> bool operator <=(Log<T> log1, Log<T> log2)$/;"	f
operator =	src\Log.hpp	/^	Log<T>& operator =(const Log<T>& l)$/;"	f	class:Log
operator ==	src\Log.hpp	/^template<class T> bool operator ==(Log<T> log1, Log<T> log2)$/;"	f
operator >	src\Log.hpp	/^template<class T> bool operator >(Log<T> log1, Log<T> log2)$/;"	f
operator >=	src\Log.hpp	/^template<class T> bool operator >=(Log<T> log1, Log<T> log2)$/;"	f
operator >>	src\Log.hpp	/^template<class T> istream& operator >>(istream& in, Log<T>& l)$/;"	f
safe_exp	src\Log.hpp	/^	static T safe_exp(T x)$/;"	f	class:Log
safe_log	src\Log.hpp	/^	static T safe_log(T x)$/;"	f	class:Log
LstmLayer	src\LstmLayer.hpp	/^	LstmLayer(const string& name, const vector<int>& directions, size_t nb, size_t cpb = 1, LstmLayer<CI,CO,G>* ps = 0):$/;"	f	struct:LstmLayer
LstmLayer	src\LstmLayer.hpp	/^template <class CI, class CO, class G> struct LstmLayer: public Layer$/;"	s
PEEPS	src\LstmLayer.hpp	24;"	d
_INCLUDED_LstmLayer_h	src\LstmLayer.hpp	19;"	d
cellErrors	src\LstmLayer.hpp	/^	SeqBuffer<real_t> cellErrors;$/;"	m	struct:LstmLayer
cellsPerBlock	src\LstmLayer.hpp	/^	size_t cellsPerBlock;$/;"	m	struct:LstmLayer
delayedCoords	src\LstmLayer.hpp	/^	vector<int> delayedCoords;$/;"	m	struct:LstmLayer
feed_back	src\LstmLayer.hpp	/^	void feed_back(const vector<int>& coords)$/;"	f	struct:LstmLayer
feed_forward	src\LstmLayer.hpp	/^	void feed_forward(const vector<int>& coords)$/;"	f	struct:LstmLayer
forgetGateActs	src\LstmLayer.hpp	/^	SeqBuffer<real_t> forgetGateActs;$/;"	m	struct:LstmLayer
gatesPerBlock	src\LstmLayer.hpp	/^	size_t gatesPerBlock;$/;"	m	struct:LstmLayer
inGateActs	src\LstmLayer.hpp	/^	SeqBuffer<real_t> inGateActs;$/;"	m	struct:LstmLayer
nextCellErrors	src\LstmLayer.hpp	/^	vector<View<real_t> > nextCellErrors;$/;"	m	struct:LstmLayer
nextErrors	src\LstmLayer.hpp	/^	vector<View<real_t> > nextErrors;$/;"	m	struct:LstmLayer
nextFgActs	src\LstmLayer.hpp	/^	vector<View<real_t> > nextFgActs;$/;"	m	struct:LstmLayer
numBlocks	src\LstmLayer.hpp	/^	size_t numBlocks;$/;"	m	struct:LstmLayer
numCells	src\LstmLayer.hpp	/^	size_t numCells;$/;"	m	struct:LstmLayer
oldStates	src\LstmLayer.hpp	/^	vector<View<real_t> > oldStates;$/;"	m	struct:LstmLayer
outGateActs	src\LstmLayer.hpp	/^	SeqBuffer<real_t> outGateActs;$/;"	m	struct:LstmLayer
output	src\LstmLayer.hpp	/^	void output() {$/;"	f	struct:LstmLayer
peepRange	src\LstmLayer.hpp	/^	pair<size_t, size_t> peepRange;$/;"	m	struct:LstmLayer
peepSource	src\LstmLayer.hpp	/^	LstmLayer<CI,CO,G>* peepSource;$/;"	m	struct:LstmLayer
peepsPerBlock	src\LstmLayer.hpp	/^	size_t peepsPerBlock;$/;"	m	struct:LstmLayer
preGateStates	src\LstmLayer.hpp	/^	SeqBuffer<real_t> preGateStates;$/;"	m	struct:LstmLayer
preOutGateActs	src\LstmLayer.hpp	/^	SeqBuffer<real_t> preOutGateActs;$/;"	m	struct:LstmLayer
print	src\LstmLayer.hpp	/^	void print(ostream& out = cout) const$/;"	f	struct:LstmLayer
start_sequence	src\LstmLayer.hpp	/^	void start_sequence()$/;"	f	struct:LstmLayer
stateDelays	src\LstmLayer.hpp	/^	vector<vector<int> > stateDelays;$/;"	m	struct:LstmLayer
states	src\LstmLayer.hpp	/^	SeqBuffer<real_t> states;$/;"	m	struct:LstmLayer
unitsPerBlock	src\LstmLayer.hpp	/^	size_t unitsPerBlock;$/;"	m	struct:LstmLayer
update_derivs	src\LstmLayer.hpp	/^	void update_derivs(const vector<int>& coords)$/;"	f	struct:LstmLayer
weights	src\LstmLayer.hpp	/^	const View<real_t> weights()$/;"	f	struct:LstmLayer
~LstmLayer	src\LstmLayer.hpp	/^	~LstmLayer()$/;"	f	struct:LstmLayer
TeeDev	src\Main.cpp	/^typedef boost::iostreams::tee_device<ostream, ofstream> TeeDev;$/;"	t	file:
TeeStream	src\Main.cpp	/^typedef boost::iostreams::stream<TeeDev> TeeStream;$/;"	t	file:
main	src\Main.cpp	/^int main(int argc, char* argv[])$/;"	f
validDatasets	src\Main.cpp	/^vector<string> validDatasets = list_of<string>("train")("test")("val");$/;"	v
OP_TRACKING	src\Matrix.hpp	21;"	d
_INCLUDED_Matrix_h	src\Matrix.hpp	19;"	d
dot	src\Matrix.hpp	/^static void dot(const real_t *inBegin, const real_t *inEnd, const real_t *M, real_t *out, real_t *outEnd)$/;"	f
dot	src\Matrix.hpp	/^template<class R> static void dot(const R& a, const real_t *M, const R& b)$/;"	f
dot_transpose	src\Matrix.hpp	/^static void dot_transpose(const real_t *in, const real_t *inEnd, const real_t *M, real_t *outBegin, real_t *outEnd)$/;"	f
dot_transpose	src\Matrix.hpp	/^template<class R> static void dot_transpose(const R& a, const real_t *M, const R& b)$/;"	f
dot_transpose_m_squared	src\Matrix.hpp	/^static void dot_transpose_m_squared(const real_t *in, const real_t *inEnd, const real_t *M, real_t *outBegin, real_t *outEnd)$/;"	f
dot_transpose_m_squared	src\Matrix.hpp	/^template<class R> static void dot_transpose_m_squared(const R& a, const real_t *M, const R& b)$/;"	f
elt	src\Matrix.hpp	/^static real_t& elt(View<real_t> M, int x, int y, int width)$/;"	f
matrixOps	src\Matrix.hpp	/^static unsigned long long matrixOps = 0;$/;"	v
outer	src\Matrix.hpp	/^static void outer(const real_t *aBegin, const real_t *aEnd, real_t *M, const real_t *b, const real_t *bEnd)$/;"	f
outer	src\Matrix.hpp	/^template<class R> static void outer(const R& a, real_t *M, const R&b)$/;"	f
outer_a_squared	src\Matrix.hpp	/^static void outer_a_squared(const real_t *aBegin, const real_t *aEnd, real_t *M, const real_t *b, const real_t *bEnd)$/;"	f
outer_a_squared	src\Matrix.hpp	/^template<class R> static void outer_a_squared(const R& a, real_t *M, const R&b)$/;"	f
CONN_IT	src\Mdrnn.hpp	/^typedef multimap<const Layer*, Connection*>::iterator CONN_IT ;$/;"	t
CONST_CONN_IT	src\Mdrnn.hpp	/^typedef multimap<const Layer*, Connection*>::const_iterator CONST_CONN_IT;$/;"	t
CONST_LAYER_IT	src\Mdrnn.hpp	/^typedef vector<Layer*>::const_iterator CONST_LAYER_IT;$/;"	t
LAYER_IT	src\Mdrnn.hpp	/^typedef vector<Layer*>::iterator LAYER_IT;$/;"	t
LEVEL_IT	src\Mdrnn.hpp	/^typedef vector<vector<Layer*> >::iterator LEVEL_IT;$/;"	t
Mdrnn	src\Mdrnn.hpp	/^	Mdrnn(ostream& o, ConfigFile& conf, const DataHeader& data):$/;"	f	struct:Mdrnn
Mdrnn	src\Mdrnn.hpp	/^struct Mdrnn$/;"	s
PLC	src\Mdrnn.hpp	/^typedef pair<const Layer*, Connection*> PLC;$/;"	t
REVERSE_LAYER_IT	src\Mdrnn.hpp	/^typedef vector<Layer*>::reverse_iterator REVERSE_LAYER_IT;$/;"	t
_INCLUDED_Mdrnn_h	src\Mdrnn.hpp	19;"	d
add_bias	src\Mdrnn.hpp	/^	FullConnection* add_bias(Layer* layer)$/;"	f	struct:Mdrnn
add_connection	src\Mdrnn.hpp	/^	Connection* add_connection(Connection* conn)$/;"	f	struct:Mdrnn
add_hidden_layers_to_level	src\Mdrnn.hpp	/^	Layer* add_hidden_layers_to_level(const string& type, int size, bool recurrent, const string& name,$/;"	f	struct:Mdrnn
add_hidden_level	src\Mdrnn.hpp	/^	int add_hidden_level(const string& type, int size, bool recurrent = true, const string& name = "hidden", bool addBias = true)$/;"	f	struct:Mdrnn
add_layer	src\Mdrnn.hpp	/^	Layer* add_layer(Layer* layer, bool addBias = false, bool recurrent = false)$/;"	f	struct:Mdrnn
add_layer	src\Mdrnn.hpp	/^	Layer* add_layer(const string& type, const string& name, int size, $/;"	f	struct:Mdrnn
add_output_layer	src\Mdrnn.hpp	/^	Layer* add_output_layer(NetworkOutput* output, bool addBias = true)$/;"	f	struct:Mdrnn
bias	src\Mdrnn.hpp	/^	BiasLayer bias;$/;"	m	struct:Mdrnn
bidirectional	src\Mdrnn.hpp	/^	vector<bool> bidirectional;		\/\/ 雙向 (numDims)$/;"	m	struct:Mdrnn
build	src\Mdrnn.hpp	/^	virtual void build()$/;"	f	struct:Mdrnn
calculate_errors	src\Mdrnn.hpp	/^	virtual real_t calculate_errors(const DataSequence& seq)$/;"	f	struct:Mdrnn
calculate_output_errors	src\Mdrnn.hpp	/^	virtual real_t calculate_output_errors(const DataSequence& seq)$/;"	f	struct:Mdrnn
collapse_layer	src\Mdrnn.hpp	/^	Layer* collapse_layer(Layer* src, Layer* dest, const vector<bool>& activeDims = empty_list_of<bool>())$/;"	f	struct:Mdrnn
connect_from_hidden_level	src\Mdrnn.hpp	/^	void connect_from_hidden_level(int levelNum, Layer* to)$/;"	f	struct:Mdrnn
connect_layers	src\Mdrnn.hpp	/^	FullConnection* connect_layers(Layer* from, Layer* to, const vector<int>& delay = empty_list_of<int>())$/;"	f	struct:Mdrnn
connect_to_hidden_level	src\Mdrnn.hpp	/^	void connect_to_hidden_level(Layer* from, int levelNum)$/;"	f	struct:Mdrnn
connections	src\Mdrnn.hpp	/^	multimap<const Layer*, Connection*> connections;$/;"	m	struct:Mdrnn
copy_connections	src\Mdrnn.hpp	/^	int copy_connections(Layer* src, Layer* dest, bool mirror = false)$/;"	f	struct:Mdrnn
criteria	src\Mdrnn.hpp	/^	Vector<string> criteria;$/;"	m	struct:Mdrnn
errors	src\Mdrnn.hpp	/^	map<string, real_t> errors;$/;"	m	struct:Mdrnn
feed_back	src\Mdrnn.hpp	/^	virtual void feed_back()$/;"	f	struct:Mdrnn
feed_back_layer	src\Mdrnn.hpp	/^	void feed_back_layer(Layer* layer)$/;"	f	struct:Mdrnn
feed_forward	src\Mdrnn.hpp	/^	virtual void feed_forward(const DataSequence& seq)$/;"	f	struct:Mdrnn
feed_forward_layer	src\Mdrnn.hpp	/^	void feed_forward_layer(Layer* layer)$/;"	f	struct:Mdrnn
gather_level	src\Mdrnn.hpp	/^	Layer* gather_level(const string& name, int levelNum)$/;"	f	struct:Mdrnn
get_input_layer	src\Mdrnn.hpp	/^	Layer* get_input_layer() const$/;"	f	struct:Mdrnn
hiddenLayers	src\Mdrnn.hpp	/^	vector<Layer*> hiddenLayers;	\/\/ 所有的 hiddenLayers 都會在這裡面$/;"	m	struct:Mdrnn
hiddenLevels	src\Mdrnn.hpp	/^	vector<vector<Layer*> > hiddenLevels;$/;"	m	struct:Mdrnn
inputBlock	src\Mdrnn.hpp	/^	vector<size_t> inputBlock;		\/\/ inputBlock Shape 3,4$/;"	m	struct:Mdrnn
inputBlockLayer	src\Mdrnn.hpp	/^	Layer* inputBlockLayer;			\/\/ Data input 連接到 inputBlock 算是第一層，也依照 inputBlock(3,4)大小設置(不過好像還沒有*W過)$/;"	m	struct:Mdrnn
inputLayer	src\Mdrnn.hpp	/^	InputLayer* inputLayer;$/;"	m	struct:Mdrnn
is_mirror	src\Mdrnn.hpp	/^ 	bool is_mirror(const Layer* layer)$/;"	f	struct:Mdrnn
is_recurrent	src\Mdrnn.hpp	/^	bool is_recurrent(const Layer* layer) const$/;"	f	struct:Mdrnn
make_layer_recurrent	src\Mdrnn.hpp	/^	void make_layer_recurrent(Layer* layer)$/;"	f	struct:Mdrnn
normFactors	src\Mdrnn.hpp	/^	map<string, real_t> normFactors;$/;"	m	struct:Mdrnn
num_seq_dims	src\Mdrnn.hpp	/^	size_t num_seq_dims() const$/;"	f	struct:Mdrnn
operator <<	src\Mdrnn.hpp	/^ostream& operator << (ostream& out, const Mdrnn& net)$/;"	f
out	src\Mdrnn.hpp	/^	ostream& out;$/;"	m	struct:Mdrnn
outputLayers	src\Mdrnn.hpp	/^	vector<Layer*> outputLayers;$/;"	m	struct:Mdrnn
outputs	src\Mdrnn.hpp	/^	vector<NetworkOutput*> outputs;$/;"	m	struct:Mdrnn
print	src\Mdrnn.hpp	/^	virtual void print(ostream& out = cout) const$/;"	f	struct:Mdrnn
print_output_shape	src\Mdrnn.hpp	/^	virtual void print_output_shape(ostream& out = cout) const$/;"	f	struct:Mdrnn
recurrentLayers	src\Mdrnn.hpp	/^	vector<Layer*> recurrentLayers;$/;"	m	struct:Mdrnn
symmetry	src\Mdrnn.hpp	/^	vector<bool> symmetry;			\/\/ 對稱 (numDims)$/;"	m	struct:Mdrnn
train	src\Mdrnn.hpp	/^	virtual real_t train(const DataSequence& seq)$/;"	f	struct:Mdrnn
~Mdrnn	src\Mdrnn.hpp	/^	virtual ~Mdrnn()$/;"	f	struct:Mdrnn
MultiArray	src\MultiArray.hpp	/^	MultiArray()$/;"	f	struct:MultiArray
MultiArray	src\MultiArray.hpp	/^	MultiArray(const vector<size_t>& s)$/;"	f	struct:MultiArray
MultiArray	src\MultiArray.hpp	/^	MultiArray(const vector<size_t>& s, const T& fillval)$/;"	f	struct:MultiArray
MultiArray	src\MultiArray.hpp	/^template <class T> struct MultiArray$/;"	s
_INCLUDED_MultiArray_h	src\MultiArray.hpp	19;"	d
assign	src\MultiArray.hpp	/^	template<class T2> void assign(const MultiArray<T2>& a)$/;"	f	struct:MultiArray
at	src\MultiArray.hpp	/^	const View<T> at(const vector<int>& coords)$/;"	f	struct:MultiArray
at	src\MultiArray.hpp	/^	const View<const T> at(const vector<int>& coords) const$/;"	f	struct:MultiArray
data	src\MultiArray.hpp	/^	Vector<T> data;$/;"	m	struct:MultiArray
empty	src\MultiArray.hpp	/^	virtual bool empty() const$/;"	f	struct:MultiArray
fill_data	src\MultiArray.hpp	/^	void fill_data(const T& fillVal)$/;"	f	struct:MultiArray
get	src\MultiArray.hpp	/^	T& get(const vector<int>& coords)$/;"	f	struct:MultiArray
get	src\MultiArray.hpp	/^	const T& get(const vector<int>& coords) const$/;"	f	struct:MultiArray
in_range	src\MultiArray.hpp	/^	bool in_range(const vector<int>& coords) const$/;"	f	struct:MultiArray
num_dims	src\MultiArray.hpp	/^	virtual size_t num_dims() const$/;"	f	struct:MultiArray
offset	src\MultiArray.hpp	/^	size_t offset(const vector<int>& coords) const$/;"	f	struct:MultiArray
operator =	src\MultiArray.hpp	/^	template<class T2> MultiArray<T>& operator=(const MultiArray<T2>& a)$/;"	f	struct:MultiArray
operator ==	src\MultiArray.hpp	/^template <class T> static bool operator ==(const MultiArray<T>& a, const MultiArray<T>& b)$/;"	f
operator []	src\MultiArray.hpp	/^	const View<T> operator[](const vector<int>& coords)$/;"	f	struct:MultiArray
operator []	src\MultiArray.hpp	/^	const View<const T> operator[](const vector<int>& coords) const$/;"	f	struct:MultiArray
reshape	src\MultiArray.hpp	/^	template<class R> void reshape(const R& dims, const T& fillVal)$/;"	f	struct:MultiArray
reshape	src\MultiArray.hpp	/^	template<class R> void reshape(const R& newShape)$/;"	f	struct:MultiArray
resize_data	src\MultiArray.hpp	/^	virtual void resize_data()$/;"	f	struct:MultiArray
shape	src\MultiArray.hpp	/^	Vector<size_t> shape;$/;"	m	struct:MultiArray
size	src\MultiArray.hpp	/^	virtual size_t size() const$/;"	f	struct:MultiArray
strides	src\MultiArray.hpp	/^	vector<size_t> strides;$/;"	m	struct:MultiArray
~MultiArray	src\MultiArray.hpp	/^	virtual ~MultiArray()$/;"	f	struct:MultiArray
MultilayerNet	src\MultilayerNet.hpp	/^	MultilayerNet(ostream& out, ConfigFile& conf, const DataHeader& data):$/;"	f	struct:MultilayerNet
MultilayerNet	src\MultilayerNet.hpp	/^struct MultilayerNet: public Mdrnn$/;"	s
_INCLUDED_MultilayerNet_h	src\MultilayerNet.hpp	19;"	d
Named	src\Named.hpp	/^	Named(const string & n):$/;"	f	struct:Named
Named	src\Named.hpp	/^struct Named$/;"	s
_INCLUDED_NamedObject_h	src\Named.hpp	19;"	d
name	src\Named.hpp	/^	string name;$/;"	m	struct:Named
operator <<	src\Named.hpp	/^static ostream& operator << (ostream& out, const Named& n)$/;"	f
print	src\Named.hpp	/^	void print(ostream& out = cout) const$/;"	f	struct:Named
~Named	src\Named.hpp	/^	virtual ~Named(){}$/;"	f	struct:Named
CONST_SEQ_IT	src\NetcdfDataset.hpp	33;"	d
DataHeader	src\NetcdfDataset.hpp	/^	DataHeader(const string& filename, const string& task, real_t dataFraction):$/;"	f	struct:DataHeader
DataHeader	src\NetcdfDataset.hpp	/^struct DataHeader$/;"	s
DataList	src\NetcdfDataset.hpp	/^	DataList(const vector<string>& filenams, const string& t, bool shuffle, real_t loadFrac):$/;"	f	struct:DataList
DataList	src\NetcdfDataset.hpp	/^struct DataList$/;"	s
NetcdfDataset	src\NetcdfDataset.hpp	/^	NetcdfDataset(const string& fname, const string& t, int seqNum):$/;"	f	struct:NetcdfDataset
NetcdfDataset	src\NetcdfDataset.hpp	/^	NetcdfDataset(const string& fname, const string& t, real_t dataFraction = 1.0):$/;"	f	struct:NetcdfDataset
NetcdfDataset	src\NetcdfDataset.hpp	/^struct NetcdfDataset$/;"	s
SEQ_IT	src\NetcdfDataset.hpp	32;"	d
_INCLUDED_NetcdfDataset_h	src\NetcdfDataset.hpp	19;"	d
clear_seq	src\NetcdfDataset.hpp	/^	void clear_seq()$/;"	f	struct:DataList
dataFraction	src\NetcdfDataset.hpp	/^	real_t dataFraction;$/;"	m	struct:DataList
dataset	src\NetcdfDataset.hpp	/^	NetcdfDataset* dataset;$/;"	m	struct:DataList
datasetIndex	src\NetcdfDataset.hpp	/^	int datasetIndex;$/;"	m	struct:DataList
delete_dataset	src\NetcdfDataset.hpp	/^	void delete_dataset()$/;"	f	struct:DataList
err	src\NetcdfDataset.hpp	/^	NcError err;$/;"	m	struct:NetcdfDataset
filename	src\NetcdfDataset.hpp	/^	string filename;$/;"	m	struct:NetcdfDataset
filenames	src\NetcdfDataset.hpp	/^	vector<string> filenames;$/;"	m	struct:DataList
find_nc_variable	src\NetcdfDataset.hpp	/^bool find_nc_variable(const NcFile& ncf, const string& name)$/;"	f
find_variable	src\NetcdfDataset.hpp	/^	bool find_variable(const string& name)$/;"	f	struct:NetcdfDataset
get_nc_array_step	src\NetcdfDataset.hpp	/^template<class T> static vector<T> get_nc_array_step(const NcFile& ncf, const string& name, int offset = 0, bool required = true)$/;"	f
get_nc_string	src\NetcdfDataset.hpp	/^static string get_nc_string(const NcFile& ncf, const string& name, int offset = 0, bool required = true)$/;"	f
get_offset	src\NetcdfDataset.hpp	/^	pair<int,int> get_offset(int seqNum) const$/;"	f	struct:NetcdfDataset
get_string	src\NetcdfDataset.hpp	/^	string get_string(const string& name, int offset = 0, bool required = true)$/;"	f	struct:NetcdfDataset
header	src\NetcdfDataset.hpp	/^	DataHeader header;	$/;"	m	struct:NetcdfDataset
headers	src\NetcdfDataset.hpp	/^	vector<DataHeader> headers;$/;"	m	struct:DataList
init	src\NetcdfDataset.hpp	/^	void init()$/;"	f	struct:NetcdfDataset
inputLabelCounts	src\NetcdfDataset.hpp	/^	map<string, int> inputLabelCounts;$/;"	m	struct:DataHeader
inputLabelHits	src\NetcdfDataset.hpp	/^	map <string, real_t> inputLabelHits;$/;"	m	struct:DataList
inputLabels	src\NetcdfDataset.hpp	/^	Vector<string> inputLabels;$/;"	m	struct:DataHeader
inputSeqDims	src\NetcdfDataset.hpp	/^	SeqBuffer<int> inputSeqDims;$/;"	m	struct:NetcdfDataset
inputSize	src\NetcdfDataset.hpp	/^	size_t inputSize;$/;"	m	struct:DataHeader
load_array	src\NetcdfDataset.hpp	/^	template<class T> bool load_array(const string& name, vector<T>& dest, bool required = true, int offset = 0, int count = -1)$/;"	f	struct:NetcdfDataset
load_dim	src\NetcdfDataset.hpp	/^	int load_dim(const string& name, bool required = true)$/;"	f	struct:NetcdfDataset
load_nc_array	src\NetcdfDataset.hpp	/^template<class T> static bool load_nc_array(const NcFile& ncf, const string& name, vector<T>& dest, bool required = true, int offset = 0, int count = -1)$/;"	f
load_nc_dim	src\NetcdfDataset.hpp	/^static int load_nc_dim(const NcFile& ncf, const string& name, bool required = true)$/;"	f
load_nc_variable	src\NetcdfDataset.hpp	/^static NcVar* load_nc_variable (const NcFile& ncf, const string& name, bool required = true)$/;"	f
load_sequences	src\NetcdfDataset.hpp	/^	void load_sequences (int first, int last)$/;"	f	struct:NetcdfDataset
load_to_seq_buffer	src\NetcdfDataset.hpp	/^	template<class T, class R> bool load_to_seq_buffer(SeqBuffer<T>& dest, const R& shape, const string& name, bool required = true, int offset = 0, int count = -1)$/;"	f	struct:NetcdfDataset
load_to_seq_buffer_with_depth	src\NetcdfDataset.hpp	/^	template<class T, class R> bool load_to_seq_buffer_with_depth(SeqBuffer<T>& dest, const R& shape, int depth, const string& name, bool required = true, int offset = 0, int count = -1)$/;"	f	struct:NetcdfDataset
load_variable	src\NetcdfDataset.hpp	/^	NcVar* load_variable (const string& name, bool required = true)$/;"	f	struct:NetcdfDataset
nc	src\NetcdfDataset.hpp	/^	NcFile nc;$/;"	m	struct:NetcdfDataset
next_dataset	src\NetcdfDataset.hpp	/^	bool next_dataset()$/;"	f	struct:DataList
next_sequence	src\NetcdfDataset.hpp	/^	DataSequence* next_sequence()$/;"	f	struct:DataList
numDims	src\NetcdfDataset.hpp	/^	int numDims;$/;"	m	struct:DataHeader
numSequences	src\NetcdfDataset.hpp	/^	size_t numSequences;$/;"	m	struct:DataHeader
numSequences	src\NetcdfDataset.hpp	/^	size_t numSequences;$/;"	m	struct:DataList
numTimesteps	src\NetcdfDataset.hpp	/^	size_t numTimesteps;$/;"	m	struct:DataHeader
numTimesteps	src\NetcdfDataset.hpp	/^	size_t numTimesteps;$/;"	m	struct:DataList
operator <<	src\NetcdfDataset.hpp	/^static ostream& operator << (ostream& out, const DataHeader& dh)$/;"	f
operator <<	src\NetcdfDataset.hpp	/^static ostream& operator << (ostream& out, const DataList& dl)$/;"	f
operator <<	src\NetcdfDataset.hpp	/^static ostream& operator << (ostream& out, const NetcdfDataset& d)$/;"	f
operator []	src\NetcdfDataset.hpp	/^	DataSequence& operator[](int n)$/;"	f	struct:NetcdfDataset
outputSize	src\NetcdfDataset.hpp	/^	size_t outputSize;$/;"	m	struct:DataHeader
print	src\NetcdfDataset.hpp	/^	void print(ostream& out = cout) const$/;"	f	struct:DataList
print	src\NetcdfDataset.hpp	/^	void print(ostream& out) const$/;"	f	struct:DataHeader
print	src\NetcdfDataset.hpp	/^	void print(ostream& out) const$/;"	f	struct:NetcdfDataset
seq	src\NetcdfDataset.hpp	/^	DataSequence* seq;$/;"	m	struct:DataList
seqIndex	src\NetcdfDataset.hpp	/^	int seqIndex;$/;"	m	struct:DataList
seq_to_offset	src\NetcdfDataset.hpp	/^	pair<int,int> seq_to_offset(int seqNum) const$/;"	f	struct:NetcdfDataset
sequences	src\NetcdfDataset.hpp	/^	vector<DataSequence*> sequences;$/;"	m	struct:NetcdfDataset
shuffle_sequences	src\NetcdfDataset.hpp	/^	void shuffle_sequences()$/;"	f	struct:NetcdfDataset
shuffled	src\NetcdfDataset.hpp	/^	bool shuffled;$/;"	m	struct:DataList
size	src\NetcdfDataset.hpp	/^	int size() const$/;"	f	struct:DataList
size	src\NetcdfDataset.hpp	/^	int size() const$/;"	f	struct:NetcdfDataset
start	src\NetcdfDataset.hpp	/^	DataSequence* start()$/;"	f	struct:DataList
targetLabelCounts	src\NetcdfDataset.hpp	/^	map <string, real_t> targetLabelCounts;$/;"	m	struct:DataList
targetLabelCounts	src\NetcdfDataset.hpp	/^	map<string, int> targetLabelCounts;	\/\/ 每個單字(app)出現的次數$/;"	m	struct:DataHeader
targetLabels	src\NetcdfDataset.hpp	/^	Vector<string> targetLabels;        \/\/ 共有多少個單字(app)$/;"	m	struct:DataHeader
targetSeqDims	src\NetcdfDataset.hpp	/^	SeqBuffer<int> targetSeqDims;$/;"	m	struct:NetcdfDataset
task	src\NetcdfDataset.hpp	/^	string task;$/;"	m	struct:DataList
task	src\NetcdfDataset.hpp	/^	string task;$/;"	m	struct:NetcdfDataset
timesteps	src\NetcdfDataset.hpp	/^	size_t timesteps() const$/;"	f	struct:NetcdfDataset
totalTargetStringLength	src\NetcdfDataset.hpp	/^	size_t totalTargetStringLength;$/;"	m	struct:DataHeader
totalTargetStringLength	src\NetcdfDataset.hpp	/^	size_t totalTargetStringLength;$/;"	m	struct:DataList
~DataList	src\NetcdfDataset.hpp	/^	~DataList()$/;"	f	struct:DataList
~NetcdfDataset	src\NetcdfDataset.hpp	/^	~NetcdfDataset()$/;"	f	struct:NetcdfDataset
ERR	src\NetworkOutput.hpp	24;"	d
NetworkOutput	src\NetworkOutput.hpp	/^	NetworkOutput(){}$/;"	f	struct:NetworkOutput
NetworkOutput	src\NetworkOutput.hpp	/^struct NetworkOutput$/;"	s
_INCLUDED_NetworkOutput_h	src\NetworkOutput.hpp	19;"	d
calculate_errors	src\NetworkOutput.hpp	/^	virtual real_t calculate_errors(const DataSequence& seq){return realMax;}$/;"	f	struct:NetworkOutput
criteria	src\NetworkOutput.hpp	/^	Vector<string> criteria;$/;"	m	struct:NetworkOutput
errorMap	src\NetworkOutput.hpp	/^	map <string, real_t> errorMap;$/;"	m	struct:NetworkOutput
normFactors	src\NetworkOutput.hpp	/^	map <string, real_t> normFactors;$/;"	m	struct:NetworkOutput
NeuronLayer	src\NeuronLayer.hpp	/^	NeuronLayer(const string& name, const vector<int>& directions, size_t size):$/;"	f	struct:NeuronLayer
NeuronLayer	src\NeuronLayer.hpp	/^	NeuronLayer(const string& name, size_t numDims, size_t size):$/;"	f	struct:NeuronLayer
NeuronLayer	src\NeuronLayer.hpp	/^template <class F> struct NeuronLayer: public FlatLayer$/;"	s
_INCLUDED_NeuronLayer_h	src\NeuronLayer.hpp	19;"	d
feed_back	src\NeuronLayer.hpp	/^	void feed_back(const vector<int>& coords)$/;"	f	struct:NeuronLayer
feed_forward	src\NeuronLayer.hpp	/^	void feed_forward(const vector<int>& coords)$/;"	f	struct:NeuronLayer
init	src\NeuronLayer.hpp	/^	void init()$/;"	f	struct:NeuronLayer
output	src\NeuronLayer.hpp	/^	void output() {$/;"	f	struct:NeuronLayer
~NeuronLayer	src\NeuronLayer.hpp	/^	~NeuronLayer(){}$/;"	f	struct:NeuronLayer
Optimiser	src\Optimiser.hpp	/^	Optimiser(vector<real_t>& weights, vector<real_t>& derivatives):$/;"	f	struct:Optimiser
Optimiser	src\Optimiser.hpp	/^struct Optimiser$/;"	s
_INCLUDED_Optimiser_h	src\Optimiser.hpp	19;"	d
derivs	src\Optimiser.hpp	/^	vector<real_t>& derivs;$/;"	m	struct:Optimiser
operator <<	src\Optimiser.hpp	/^ostream& operator << (ostream& out, const Optimiser& o)$/;"	f
wts	src\Optimiser.hpp	/^	vector<real_t>& wts;$/;"	m	struct:Optimiser
~Optimiser	src\Optimiser.hpp	/^	virtual ~Optimiser(){}$/;"	f	struct:Optimiser
BaseGenType	src\Random.cpp	/^typedef mt19937 BaseGenType;$/;"	t	file:
normal	src\Random.cpp	/^real_t Random::normal()$/;"	f	class:Random
normal	src\Random.cpp	/^real_t Random::normal(real_t dev, real_t mean)$/;"	f	class:Random
set_seed	src\Random.cpp	/^unsigned int Random::set_seed(unsigned int seed)$/;"	f	class:Random
uniform	src\Random.cpp	/^real_t Random::uniform()$/;"	f	class:Random
uniform	src\Random.cpp	/^real_t Random::uniform(real_t range)$/;"	f	class:Random
Random	src\Random.hpp	/^namespace Random$/;"	n
_INCLUDED_Random_h	src\Random.hpp	19;"	d
Rprop	src\Rprop.hpp	/^	Rprop(const string& name, ostream& o, vector<real_t>& weights, vector<real_t>& derivatives, $/;"	f	struct:Rprop
Rprop	src\Rprop.hpp	/^struct Rprop: public DataExporter, public Optimiser$/;"	s
_INCLUDED_Rprop_h	src\Rprop.hpp	19;"	d
build	src\Rprop.hpp	/^	void build()$/;"	f	struct:Rprop
deltas	src\Rprop.hpp	/^	vector<real_t> deltas;$/;"	m	struct:Rprop
etaChange	src\Rprop.hpp	/^	real_t etaChange;$/;"	m	struct:Rprop
etaMin	src\Rprop.hpp	/^	real_t etaMin;$/;"	m	struct:Rprop
etaPlus	src\Rprop.hpp	/^	real_t etaPlus;$/;"	m	struct:Rprop
initDelta	src\Rprop.hpp	/^	real_t initDelta;$/;"	m	struct:Rprop
maxDelta	src\Rprop.hpp	/^	real_t maxDelta;$/;"	m	struct:Rprop
minDelta	src\Rprop.hpp	/^	real_t minDelta;$/;"	m	struct:Rprop
online	src\Rprop.hpp	/^	bool online;$/;"	m	struct:Rprop
out	src\Rprop.hpp	/^	ostream& out;$/;"	m	struct:Rprop
prevAvgDelta	src\Rprop.hpp	/^	real_t prevAvgDelta;$/;"	m	struct:Rprop
prevDerivs	src\Rprop.hpp	/^	vector<real_t> prevDerivs;$/;"	m	struct:Rprop
print	src\Rprop.hpp	/^	void print(ostream& out = cout) const$/;"	f	struct:Rprop
update_weights	src\Rprop.hpp	/^	void update_weights()$/;"	f	struct:Rprop
CVI	src\SeqBuffer.hpp	115;"	d
CoordIterator	src\SeqBuffer.hpp	/^	CoordIterator (const R& sh, const vector<int>& dirs = empty_list_of<int>(), bool reverse = false):$/;"	f	struct:CoordIterator
CoordIterator	src\SeqBuffer.hpp	/^template <class R> struct CoordIterator$/;"	s
SeqBuffer	src\SeqBuffer.hpp	/^	SeqBuffer(const SeqBuffer& sb)$/;"	f	struct:SeqBuffer
SeqBuffer	src\SeqBuffer.hpp	/^	SeqBuffer(const vector<size_t>& shape, size_t dep):$/;"	f	struct:SeqBuffer
SeqBuffer	src\SeqBuffer.hpp	/^	SeqBuffer(size_t dep = 0):$/;"	f	struct:SeqBuffer
SeqBuffer	src\SeqBuffer.hpp	/^template <class T> struct SeqBuffer: public MultiArray<T>$/;"	s
SeqIterator	src\SeqBuffer.hpp	116;"	d
_INCLUDED_SeqBuffer_h	src\SeqBuffer.hpp	19;"	d
at	src\SeqBuffer.hpp	/^	const View<T> at(int coord)$/;"	f	struct:SeqBuffer
at	src\SeqBuffer.hpp	/^	const View<const T> at(int coord) const$/;"	f	struct:SeqBuffer
back	src\SeqBuffer.hpp	/^	const View<T> back(const vector<int>& dirs = empty_list_of<int>())$/;"	f	struct:SeqBuffer
begin	src\SeqBuffer.hpp	/^	SeqIterator begin(const vector<int>& dirs = empty_list_of<int>()) const$/;"	f	struct:SeqBuffer
begin	src\SeqBuffer.hpp	/^	void begin()$/;"	f	struct:CoordIterator
depth	src\SeqBuffer.hpp	/^	size_t depth;$/;"	m	struct:SeqBuffer
directions	src\SeqBuffer.hpp	/^	vector<int> directions;	\/\/ 方向		 : 走的方向$/;"	m	struct:CoordIterator
end	src\SeqBuffer.hpp	/^	bool end;$/;"	m	struct:CoordIterator
front	src\SeqBuffer.hpp	/^	const View<T> front(const vector<int>& dirs = empty_list_of<int>())$/;"	f	struct:SeqBuffer
num_seq_dims	src\SeqBuffer.hpp	/^ 	size_t num_seq_dims() const$/;"	f	struct:SeqBuffer
operator *	src\SeqBuffer.hpp	/^	const vector<int>& operator* () const$/;"	f	struct:CoordIterator
operator ++	src\SeqBuffer.hpp	/^	CoordIterator& operator++ ()$/;"	f	struct:CoordIterator
operator <<	src\SeqBuffer.hpp	/^template <class T> static ostream& operator <<(ostream& out, const SeqBuffer<T>& a)$/;"	f
operator =	src\SeqBuffer.hpp	/^	template<class T2> SeqBuffer<T>& operator =(const SeqBuffer<T2>& a)$/;"	f	struct:SeqBuffer
operator []	src\SeqBuffer.hpp	/^	const View<T> operator[](int coord)$/;"	f	struct:SeqBuffer
operator []	src\SeqBuffer.hpp	/^	const View<const T> operator[](int coord) const$/;"	f	struct:SeqBuffer
print	src\SeqBuffer.hpp	/^	void print(ostream& out) const$/;"	f	struct:SeqBuffer
pt	src\SeqBuffer.hpp	/^	vector<int> pt;			\/\/ shape 的 size : 目前的位置$/;"	m	struct:CoordIterator
rbegin	src\SeqBuffer.hpp	/^	SeqIterator rbegin(const vector<int>& dirs = empty_list_of<int>()) const$/;"	f	struct:SeqBuffer
reshape	src\SeqBuffer.hpp	/^	template<class R> void reshape(const R& newSeqShap, const T& fillval)$/;"	f	struct:SeqBuffer
reshape	src\SeqBuffer.hpp	/^	template<class R> void reshape(const R& newSeqShape)$/;"	f	struct:SeqBuffer
reshape	src\SeqBuffer.hpp	/^	template<class T2> void reshape(const SeqBuffer<T2>& buff)$/;"	f	struct:SeqBuffer
reshape	src\SeqBuffer.hpp	/^	template<class T2> void reshape(const SeqBuffer<T2>& buff, const T& fillVal)$/;"	f	struct:SeqBuffer
reshape_with_depth	src\SeqBuffer.hpp	/^	template<class R> void reshape_with_depth(const R& newSeqShap, size_t dep)$/;"	f	struct:SeqBuffer
reshape_with_depth	src\SeqBuffer.hpp	/^	template<class R> void reshape_with_depth(const R& newSeqShap, size_t dep, const T& fillval)$/;"	f	struct:SeqBuffer
seq_means	src\SeqBuffer.hpp	/^	vector<real_t>& seq_means() const$/;"	f	struct:SeqBuffer
seq_offset	src\SeqBuffer.hpp	/^	int seq_offset(const vector<int>& coords)$/;"	f	struct:SeqBuffer
seq_shape	src\SeqBuffer.hpp	/^	const View<const size_t> seq_shape() const$/;"	f	struct:SeqBuffer
seq_size	src\SeqBuffer.hpp	/^	size_t seq_size() const$/;"	f	struct:SeqBuffer
shape	src\SeqBuffer.hpp	/^	Vector<size_t> shape;	\/\/ Shape 3,4 : 走的區塊大小$/;"	m	struct:CoordIterator
step	src\SeqBuffer.hpp	/^	void step(size_t d)$/;"	f	struct:CoordIterator
~SeqBuffer	src\SeqBuffer.hpp	/^	virtual ~SeqBuffer()$/;"	f	struct:SeqBuffer
SoftmaxLayer	src\SoftmaxLayer.hpp	/^	SoftmaxLayer(const string& name, size_t numSeqDims, const vector<string>& labs):$/;"	f	struct:SoftmaxLayer
SoftmaxLayer	src\SoftmaxLayer.hpp	/^struct SoftmaxLayer: public FlatLayer$/;"	s
_INCLUDED_SoftmaxLayer_h	src\SoftmaxLayer.hpp	19;"	d
feed_back	src\SoftmaxLayer.hpp	/^	void feed_back(const vector<int>& coords)$/;"	f	struct:SoftmaxLayer
feed_forward	src\SoftmaxLayer.hpp	/^	void feed_forward(const vector<int>& coords)$/;"	f	struct:SoftmaxLayer
logActivations	src\SoftmaxLayer.hpp	/^	SeqBuffer<Log<real_t> > logActivations;$/;"	m	struct:SoftmaxLayer
output	src\SoftmaxLayer.hpp	/^	virtual void output() {$/;"	f	struct:SoftmaxLayer
start_sequence	src\SoftmaxLayer.hpp	/^	void start_sequence()$/;"	f	struct:SoftmaxLayer
targetLabels	src\SoftmaxLayer.hpp	/^	vector<string> targetLabels;$/;"	m	struct:SoftmaxLayer
unnormedActivations	src\SoftmaxLayer.hpp	/^	SeqBuffer<real_t> unnormedActivations;$/;"	m	struct:SoftmaxLayer
unnormedlogActivations	src\SoftmaxLayer.hpp	/^	SeqBuffer<Log<real_t> > unnormedlogActivations;$/;"	m	struct:SoftmaxLayer
SteepestDescent	src\SteepestDescent.hpp	/^	SteepestDescent(const string& name, ostream& o, vector<real_t>& weights, vector<real_t>& derivatives, $/;"	f	struct:SteepestDescent
SteepestDescent	src\SteepestDescent.hpp	/^struct SteepestDescent: public DataExporter, public Optimiser$/;"	s
_INCLUDED_SteepestDescent_h	src\SteepestDescent.hpp	19;"	d
build	src\SteepestDescent.hpp	/^	void build()$/;"	f	struct:SteepestDescent
deltas	src\SteepestDescent.hpp	/^	vector<real_t> deltas;$/;"	m	struct:SteepestDescent
learnRate	src\SteepestDescent.hpp	/^	real_t learnRate;$/;"	m	struct:SteepestDescent
momentum	src\SteepestDescent.hpp	/^	real_t momentum;$/;"	m	struct:SteepestDescent
out	src\SteepestDescent.hpp	/^	ostream& out;$/;"	m	struct:SteepestDescent
print	src\SteepestDescent.hpp	/^	void print(ostream& out = cout) const$/;"	f	struct:SteepestDescent
update_weights	src\SteepestDescent.hpp	/^	void update_weights()$/;"	f	struct:SteepestDescent
_INCLUDED_String_h	src\String.hpp	19;"	d
begins	src\String.hpp	/^static bool begins(const string& str, const char* search)$/;"	f
begins	src\String.hpp	/^static bool begins(const string& str, const string& search)$/;"	f
ends	src\String.hpp	/^static bool ends(const string& str, const char* search)$/;"	f
ends	src\String.hpp	/^static bool ends(const string& str, const string& search)$/;"	f
in	src\String.hpp	/^static bool in(const string& str, const char* search)$/;"	f
in	src\String.hpp	/^static bool in(const string& str, const string& search)$/;"	f
int_to_sortable_string	src\String.hpp	/^static string int_to_sortable_string(size_t num, size_t max)$/;"	f
join	src\String.hpp	/^template<class T, class R >static string join(const R& r, const string joinStr = "")$/;"	f
left_pad	src\String.hpp	/^template<class T> string left_pad(const T& val, int width, char fill = '0')$/;"	f
lower	src\String.hpp	/^static const string lower(const string& s)$/;"	f
ordinal	src\String.hpp	/^static string ordinal(size_t n)$/;"	f
split	src\String.hpp	/^template<class T> static Vector<T> split(const string& original, char delim = ' ', size_t maxSplits = 0)$/;"	f
split_with_repeat	src\String.hpp	/^template<class T> static Vector<T> split_with_repeat(const string& original, char delim = ' ', char repeater = '*')$/;"	f
trim	src\String.hpp	/^static void trim(string& str)$/;"	f
StringAlignment	src\StringAlignment.hpp	/^	StringAlignment (const R1& reference_sequence, const R2& test_sequence, $/;"	f	struct:StringAlignment
StringAlignment	src\StringAlignment.hpp	/^template<class R1, class R2> struct StringAlignment$/;"	s
_INCLUDED_StringAlignment_h	src\StringAlignment.hpp	19;"	d
delPenalty	src\StringAlignment.hpp	/^	int delPenalty;$/;"	m	struct:StringAlignment
deletions	src\StringAlignment.hpp	/^	int deletions;$/;"	m	struct:StringAlignment
delsMap	src\StringAlignment.hpp	/^	map<typename boost::range_value<R1>::type, int> delsMap;$/;"	m	struct:StringAlignment
distance	src\StringAlignment.hpp	/^	int distance;	$/;"	m	struct:StringAlignment
insMap	src\StringAlignment.hpp	/^	map<typename boost::range_value<R1>::type, int> insMap;$/;"	m	struct:StringAlignment
insPenalty	src\StringAlignment.hpp	/^	int insPenalty;$/;"	m	struct:StringAlignment
insertions	src\StringAlignment.hpp	/^	int insertions;$/;"	m	struct:StringAlignment
m	src\StringAlignment.hpp	/^	size_t m;$/;"	m	struct:StringAlignment
matrix	src\StringAlignment.hpp	/^	Vector<Vector<int> > matrix;$/;"	m	struct:StringAlignment
n	src\StringAlignment.hpp	/^	size_t n;$/;"	m	struct:StringAlignment
subPenalty	src\StringAlignment.hpp	/^	int subPenalty;$/;"	m	struct:StringAlignment
subsMap	src\StringAlignment.hpp	/^	map<typename boost::range_value<R1>::type, map<typename boost::range_value<R1>::type, int> > subsMap;$/;"	m	struct:StringAlignment
substitutions	src\StringAlignment.hpp	/^	int substitutions;$/;"	m	struct:StringAlignment
~StringAlignment	src\StringAlignment.hpp	/^	~StringAlignment(){}$/;"	f	struct:StringAlignment
Trainer	src\Trainer.hpp	/^	Trainer(ostream& o, Mdrnn* n, ConfigFile& conf, const string& name = "trainer"):$/;"	f	struct:Trainer
Trainer	src\Trainer.hpp	/^struct Trainer: public DataExporter$/;"	s
_INCLUDED_Trainer_h	src\Trainer.hpp	19;"	d
add_input_noise	src\Trainer.hpp	/^	DataSequence* add_input_noise(const DataSequence* seq)$/;"	f	struct:Trainer
apply_distortions	src\Trainer.hpp	/^	const DataSequence* apply_distortions(const DataSequence* seq)$/;"	f	struct:Trainer
batchLearn	src\Trainer.hpp	/^	bool batchLearn;$/;"	m	struct:Trainer
calculate_all_errors	src\Trainer.hpp	/^	void calculate_all_errors()$/;"	f	struct:Trainer
calculate_compression_errors	src\Trainer.hpp	/^	void calculate_compression_errors(DatasetErrors& errors)$/;"	f	struct:Trainer
calculate_errors	src\Trainer.hpp	/^	DatasetErrors& calculate_errors(DataList& data, DatasetErrors& errors)$/;"	f	struct:Trainer
check_for_best	src\Trainer.hpp	/^	bool check_for_best(const DatasetErrors& currentErrors, map<string, pair<int, DatasetErrors> >& bestErrors, int epoch)$/;"	f	struct:Trainer
config	src\Trainer.hpp	/^	ConfigFile& config;$/;"	m	struct:Trainer
criteria	src\Trainer.hpp	/^    Vector<string>& criteria;$/;"	m	struct:Trainer
dataFraction	src\Trainer.hpp	/^	real_t dataFraction;$/;"	m	struct:Trainer
derivs	src\Trainer.hpp	/^	Vector<real_t>& derivs;$/;"	m	struct:Trainer
differentiate	src\Trainer.hpp	/^	real_t differentiate(const DataSequence* seq)$/;"	f	struct:Trainer
distortedWeights	src\Trainer.hpp	/^	vector<real_t> distortedWeights;$/;"	m	struct:Trainer
epoch	src\Trainer.hpp	/^	int epoch;$/;"	m	struct:Trainer
evaluate	src\Trainer.hpp	/^	real_t evaluate(const DataSequence* seq)$/;"	f	struct:Trainer
inputNoiseDev	src\Trainer.hpp	/^	real_t inputNoiseDev;$/;"	m	struct:Trainer
invTrainSeqs	src\Trainer.hpp	/^    real_t invTrainSeqs;$/;"	m	struct:Trainer
l1	src\Trainer.hpp	/^	real_t l1;$/;"	m	struct:Trainer
l2	src\Trainer.hpp	/^	real_t l2;$/;"	m	struct:Trainer
mdl	src\Trainer.hpp	/^	bool mdl;$/;"	m	struct:Trainer
mdlInitStdDev	src\Trainer.hpp	/^	real_t mdlInitStdDev;$/;"	m	struct:Trainer
mdlMlErrors	src\Trainer.hpp	/^    Vector<prob_t> mdlMlErrors;$/;"	m	struct:Trainer
mdlOldDerivs	src\Trainer.hpp	/^	Vector<real_t> mdlOldDerivs;$/;"	m	struct:Trainer
mdlOptimiser	src\Trainer.hpp	/^	Optimiser* mdlOptimiser;$/;"	m	struct:Trainer
mdlPriorMean	src\Trainer.hpp	/^	real_t mdlPriorMean;$/;"	m	struct:Trainer
mdlPriorStdDev	src\Trainer.hpp	/^    real_t mdlPriorStdDev;$/;"	m	struct:Trainer
mdlPriorVariance	src\Trainer.hpp	/^    real_t mdlPriorVariance;$/;"	m	struct:Trainer
mdlSamples	src\Trainer.hpp	/^	int mdlSamples;$/;"	m	struct:Trainer
mdlSeqDerivs	src\Trainer.hpp	/^	Vector<real_t> mdlSeqDerivs;$/;"	m	struct:Trainer
mdlSeqErrors	src\Trainer.hpp	/^	map<string, real_t> mdlSeqErrors;$/;"	m	struct:Trainer
mdlStdDevDerivs	src\Trainer.hpp	/^	Vector<real_t> mdlStdDevDerivs;$/;"	m	struct:Trainer
mdlStdDevs	src\Trainer.hpp	/^	Vector<real_t> mdlStdDevs;$/;"	m	struct:Trainer
mdlSymmetricSampling	src\Trainer.hpp	/^	bool mdlSymmetricSampling;$/;"	m	struct:Trainer
mdlWeight	src\Trainer.hpp	/^	real_t mdlWeight;$/;"	m	struct:Trainer
mdl_calculate_prior_params	src\Trainer.hpp	/^	void mdl_calculate_prior_params()$/;"	f	struct:Trainer
mdl_differentiate	src\Trainer.hpp	/^	void mdl_differentiate(real_t scaleFactor = 1)$/;"	f	struct:Trainer
mdl_evaluate	src\Trainer.hpp	/^	real_t mdl_evaluate()$/;"	f	struct:Trainer
mdl_mean	src\Trainer.hpp	/^	real_t mdl_mean(int i)$/;"	f	struct:Trainer
mdl_ml_error	src\Trainer.hpp	/^	real_t mdl_ml_error()$/;"	f	struct:Trainer
mdl_print_stats	src\Trainer.hpp	/^	void mdl_print_stats()$/;"	f	struct:Trainer
mdl_sample_weights	src\Trainer.hpp	/^	void mdl_sample_weights(int sampleNum)$/;"	f	struct:Trainer
mdl_std_dev	src\Trainer.hpp	/^	real_t mdl_std_dev(int i)$/;"	f	struct:Trainer
mdl_variance	src\Trainer.hpp	/^	real_t mdl_variance(int i)$/;"	f	struct:Trainer
net	src\Trainer.hpp	/^	Mdrnn* net;$/;"	m	struct:Trainer
netErrors	src\Trainer.hpp	/^	map<string, real_t>& netErrors;$/;"	m	struct:Trainer
netNormFactors	src\Trainer.hpp	/^	const map<string, real_t>& netNormFactors;$/;"	m	struct:Trainer
optimiser	src\Trainer.hpp	/^	Optimiser* optimiser;$/;"	m	struct:Trainer
out	src\Trainer.hpp	/^	ostream& out;$/;"	m	struct:Trainer
print_best_errors	src\Trainer.hpp	/^	void print_best_errors(const string& name, const map<string, pair<int, DatasetErrors> >& bestErrors) const$/;"	f	struct:Trainer
print_datasets	src\Trainer.hpp	/^	void print_datasets() const$/;"	f	struct:Trainer
print_distortions	src\Trainer.hpp	/^	bool print_distortions()$/;"	f	struct:Trainer
regularise	src\Trainer.hpp	/^	void regularise(real_t scaleFactor = 1)$/;"	f	struct:Trainer
reset_derivs	src\Trainer.hpp	/^	void reset_derivs()$/;"	f	struct:Trainer
revert_distortions	src\Trainer.hpp	/^	const void revert_distortions()$/;"	f	struct:Trainer
save_data	src\Trainer.hpp	/^	void save_data(const string& filename, ConfigFile& conf)$/;"	f	struct:Trainer
seqsPerWeightUpdate	src\Trainer.hpp	/^	int seqsPerWeightUpdate;$/;"	m	struct:Trainer
task	src\Trainer.hpp	/^	string task;$/;"	m	struct:Trainer
testDistortions	src\Trainer.hpp	/^	bool testDistortions;$/;"	m	struct:Trainer
testErrors	src\Trainer.hpp	/^	DatasetErrors testErrors;$/;"	m	struct:Trainer
testFiles	src\Trainer.hpp	/^	DataList testFiles;$/;"	m	struct:Trainer
train	src\Trainer.hpp	/^	void train(const string& savename)$/;"	f	struct:Trainer
trainErrors	src\Trainer.hpp	/^	DatasetErrors trainErrors;$/;"	m	struct:Trainer
trainFiles	src\Trainer.hpp	/^	DataList trainFiles;$/;"	m	struct:Trainer
update_weights	src\Trainer.hpp	/^	void update_weights()$/;"	f	struct:Trainer
valErrors	src\Trainer.hpp	/^	DatasetErrors valErrors;$/;"	m	struct:Trainer
valFiles	src\Trainer.hpp	/^	DataList valFiles;$/;"	m	struct:Trainer
weightCosts	src\Trainer.hpp	/^	Vector<real_t> weightCosts;$/;"	m	struct:Trainer
weightDistortion	src\Trainer.hpp	/^	real_t weightDistortion;$/;"	m	struct:Trainer
weight_cost	src\Trainer.hpp	/^	real_t weight_cost(int i)$/;"	f	struct:Trainer
wts	src\Trainer.hpp	/^	Vector<real_t>& wts;$/;"	m	struct:Trainer
TranscriptionLayer	src\TranscriptionLayer.hpp	/^	TranscriptionLayer(ostream& o, const string& name, const vector<string>& labs, bool cm = false):$/;"	f	struct:TranscriptionLayer
TranscriptionLayer	src\TranscriptionLayer.hpp	/^struct TranscriptionLayer: public SoftmaxLayer, public NetworkOutput$/;"	s
_INCLUDED_TranscriptionLayer_h	src\TranscriptionLayer.hpp	19;"	d
backwardVariables	src\TranscriptionLayer.hpp	/^	SeqBuffer<Log<real_t> > backwardVariables;$/;"	m	struct:TranscriptionLayer
best_label_seq	src\TranscriptionLayer.hpp	/^	vector<int>& best_label_seq() const$/;"	f	struct:TranscriptionLayer
blank	src\TranscriptionLayer.hpp	/^	int blank;$/;"	m	struct:TranscriptionLayer
calculate_errors	src\TranscriptionLayer.hpp	/^	real_t calculate_errors(const DataSequence& seq)$/;"	f	struct:TranscriptionLayer
confusionMatrix	src\TranscriptionLayer.hpp	/^	bool confusionMatrix;$/;"	m	struct:TranscriptionLayer
dEdYTerms	src\TranscriptionLayer.hpp	/^	vector<Log<real_t> > dEdYTerms;$/;"	m	struct:TranscriptionLayer
forwardVariables	src\TranscriptionLayer.hpp	/^	SeqBuffer<Log<real_t> > forwardVariables;$/;"	m	struct:TranscriptionLayer
make_target_labels	src\TranscriptionLayer.hpp	/^	vector<string> make_target_labels(const vector<string>& labs)$/;"	f	struct:TranscriptionLayer
out	src\TranscriptionLayer.hpp	/^	ostream& out;$/;"	m	struct:TranscriptionLayer
output	src\TranscriptionLayer.hpp	/^	void output() {$/;"	f	struct:TranscriptionLayer
outputLabelSeq	src\TranscriptionLayer.hpp	/^	vector<int> outputLabelSeq;$/;"	m	struct:TranscriptionLayer
path_to_string	src\TranscriptionLayer.hpp	/^	vector<int>& path_to_string(const vector<int>& path) const$/;"	f	struct:TranscriptionLayer
prior_label_prob	src\TranscriptionLayer.hpp	/^	virtual const Log<real_t>& prior_label_prob(int label)$/;"	f	struct:TranscriptionLayer
segment_range	src\TranscriptionLayer.hpp	/^	integer_range<int> segment_range(int time, int totalSegs = -1) const $/;"	f	struct:TranscriptionLayer
totalSegments	src\TranscriptionLayer.hpp	/^	int totalSegments;$/;"	m	struct:TranscriptionLayer
totalTime	src\TranscriptionLayer.hpp	/^	int totalTime;$/;"	m	struct:TranscriptionLayer
~TranscriptionLayer	src\TranscriptionLayer.hpp	/^	virtual ~TranscriptionLayer()$/;"	f	struct:TranscriptionLayer
WC_CONN_IT	src\WeightContainer.hpp	/^typedef multimap<string, tuple<string, string, int, int> >::iterator WC_CONN_IT; $/;"	t
WC_CONN_PAIR	src\WeightContainer.hpp	/^typedef pair<string, tuple<string, string, int, int> > WC_CONN_PAIR;$/;"	t
WeightContainer	src\WeightContainer.hpp	/^	WeightContainer():$/;"	f	struct:WeightContainer
WeightContainer	src\WeightContainer.hpp	/^struct WeightContainer: public DataExporter$/;"	s
_INCLUDED_WeightContainer_h	src\WeightContainer.hpp	19;"	d
build	src\WeightContainer.hpp	/^	void build()$/;"	f	struct:WeightContainer
connections	src\WeightContainer.hpp	/^	multimap<string, tuple<string, string, int, int> > connections;$/;"	m	struct:WeightContainer
derivatives	src\WeightContainer.hpp	/^	Vector<real_t> derivatives;$/;"	m	struct:WeightContainer
get_derivs	src\WeightContainer.hpp	/^	View<real_t> get_derivs(pair<int, int> range)$/;"	f	struct:WeightContainer
get_weights	src\WeightContainer.hpp	/^	View<real_t> get_weights(pair<int, int> range)$/;"	f	struct:WeightContainer
instance	src\WeightContainer.hpp	/^	static WeightContainer& instance()$/;"	f	struct:WeightContainer
link_layers	src\WeightContainer.hpp	/^	void link_layers(const string& fromName, const string& toName, const string& connName = "", int paramBegin = 0, int paramEnd = 0)$/;"	f	struct:WeightContainer
new_parameters	src\WeightContainer.hpp	/^	pair<size_t, size_t> new_parameters(size_t numParams, const string& fromName, const string& toName, const string& connName)$/;"	f	struct:WeightContainer
perturb_weight	src\WeightContainer.hpp	/^void perturb_weight(real_t& weight, real_t stdDev, bool additive = true)$/;"	f
perturb_weights	src\WeightContainer.hpp	/^template <class R> void perturb_weights(R& weights, R& stdDevs, bool additive = true)$/;"	f
perturb_weights	src\WeightContainer.hpp	/^template <class R> void perturb_weights(R& weights, real_t stdDev, bool additive = true)$/;"	f
randomise	src\WeightContainer.hpp	/^	int randomise(real_t range)$/;"	f	struct:WeightContainer
reset_derivs	src\WeightContainer.hpp	/^	void reset_derivs()$/;"	f	struct:WeightContainer
save_by_conns	src\WeightContainer.hpp	/^	void save_by_conns(vector<real_t>& container, const string& nam)$/;"	f	struct:WeightContainer
weights	src\WeightContainer.hpp	/^	Vector<real_t> weights;$/;"	m	struct:WeightContainer
printErrorHelpAndExit	utils\dump_sequence_variables.sh	/^printErrorHelpAndExit()$/;"	f
printHelpAndExit	utils\dump_sequence_variables.sh	/^printHelpAndExit()$/;"	f
OptionParser	utils\dump_weight_matrices.py	/^from optparse import OptionParser$/;"	i
config	utils\dump_weight_matrices.py	/^config = args[0]$/;"	v
connName	utils\dump_weight_matrices.py	/^	connName = connStr.split('_')[1:]$/;"	v
connStr	utils\dump_weight_matrices.py	/^	connStr = words[0]$/;"	v
connections	utils\dump_weight_matrices.py	/^	connections = opt.connections.split(',')$/;"	v
connections	utils\dump_weight_matrices.py	/^	connections = opt.connections.split()$/;"	v
fromLayer	utils\dump_weight_matrices.py	/^		fromLayer = '_'.join(connName[:min(2, toIndex)])$/;"	v
fromLayerSize	utils\dump_weight_matrices.py	/^			fromLayerSize = layerOutputSizes[fromLayer]$/;"	v
hiddenSizes	utils\dump_weight_matrices.py	/^hiddenSizes = re.search('(hiddenSize) (\\S+)', text).group(2).split(',')$/;"	v
inputMatch	utils\dump_weight_matrices.py	/^	inputMatch = re.search('(inputSize) (\\S+)', text)$/;"	v
layerName	utils\dump_weight_matrices.py	/^	layerName = 'hidden_' + str(n)$/;"	v
layerOutputSizes	utils\dump_weight_matrices.py	/^layerOutputSizes = {'bias':1}$/;"	v
out	utils\dump_weight_matrices.py	/^			out = open(config + '_' + connStr, 'w')$/;"	v
parser	utils\dump_weight_matrices.py	/^parser = OptionParser(usage='Usage: %prog [options] <save_file>')$/;"	v
re	utils\dump_weight_matrices.py	/^import re$/;"	i
size	utils\dump_weight_matrices.py	/^		size = int(words[1])$/;"	v
subsampleMatch	utils\dump_weight_matrices.py	/^subsampleMatch = re.search('(subsampleSize) (\\S+)', text)$/;"	v
sys	utils\dump_weight_matrices.py	/^import sys$/;"	i
text	utils\dump_weight_matrices.py	/^text = open(config).read()$/;"	v
toIndex	utils\dump_weight_matrices.py	/^		toIndex = connName.index('to')$/;"	v
toLayer	utils\dump_weight_matrices.py	/^			toLayer = '_'.join(connName[toIndex+1:min(len(connName)-1,toIndex + 3)])$/;"	v
toLayerSize	utils\dump_weight_matrices.py	/^			toLayerSize = size \/ fromLayerSize$/;"	v
vals	utils\dump_weight_matrices.py	/^		vals = words[2:]$/;"	v
weightTypes	utils\dump_weight_matrices.py	/^weightTypes = opt.weightTypes.split()$/;"	v
words	utils\dump_weight_matrices.py	/^	words = l.split()$/;"	v
OptionParser	utils\dump_weights.py	/^from optparse import OptionParser$/;"	i
config	utils\dump_weights.py	/^config = args[0]$/;"	v
connName	utils\dump_weights.py	/^	connName = connStr.split('_')[1:]$/;"	v
connNameStr	utils\dump_weights.py	/^	connNameStr = '_'.join(connName)$/;"	v
connStr	utils\dump_weights.py	/^	connStr = words[0]$/;"	v
connections	utils\dump_weights.py	/^	connections = opt.connections.split()$/;"	v
connections	utils\dump_weights.py	/^connections = None$/;"	v
delimMatch	utils\dump_weights.py	/^	delimMatch = re.search('(labelDelimiter) (\\S+)', text)$/;"	v
end	utils\dump_weights.py	/^				end = start + fromLayerSize$/;"	v
fromLayer	utils\dump_weights.py	/^		fromLayer = '_'.join(connName[:min(2, toIndex)])$/;"	v
fromLayerSize	utils\dump_weights.py	/^			fromLayerSize = layerSizes[fromLayer]$/;"	v
hiddenMatch	utils\dump_weights.py	/^hiddenMatch = re.search('(hiddenSize) (\\S+)', text)$/;"	v
inputDims	utils\dump_weights.py	/^	inputDims = [re.search('(inputSize) (\\S+)', text).group(2)]$/;"	v
inputDims	utils\dump_weights.py	/^	inputDims = opt.inputDims.split()$/;"	v
labelDelim	utils\dump_weights.py	/^		labelDelim = delimMatch.group(2)$/;"	v
layerSizes	utils\dump_weights.py	/^layerSizes = {"bias":1}$/;"	v
out	utils\dump_weights.py	/^			out = open(config + '_' + connNameStr, 'w')$/;"	v
parser	utils\dump_weights.py	/^parser = OptionParser(usage='Usage: %prog [options] <save_file>')$/;"	v
re	utils\dump_weights.py	/^import re$/;"	i
start	utils\dump_weights.py	/^				start = end$/;"	v
start	utils\dump_weights.py	/^			start = 0$/;"	v
subMatch	utils\dump_weights.py	/^subMatch = re.search('(subsampleSize) (\\S+)', text)$/;"	v
sys	utils\dump_weights.py	/^import sys$/;"	i
text	utils\dump_weights.py	/^text = open(config).read().strip()$/;"	v
toIndex	utils\dump_weights.py	/^		toIndex = connName.index('to')$/;"	v
toLayer	utils\dump_weights.py	/^		toLayer = '_'.join(connName[toIndex+1:min(len(connName)-1,toIndex + 3)])$/;"	v
toLayerSize	utils\dump_weights.py	/^			toLayerSize = layerSizes[toLayer]$/;"	v
vals	utils\dump_weights.py	/^		vals = words[2:]$/;"	v
weightTypes	utils\dump_weights.py	/^weightTypes = opt.weightTypes.split()$/;"	v
words	utils\dump_weights.py	/^	words = l.split()$/;"	v
printErrorHelpAndExit	utils\error_test.sh	/^printErrorHelpAndExit()$/;"	f
printHelpAndExit	utils\error_test.sh	/^printHelpAndExit()$/;"	f
printErrorHelpAndExit	utils\gradient_check.sh	/^printErrorHelpAndExit()$/;"	f
printHelpAndExit	utils\gradient_check.sh	/^printHelpAndExit()$/;"	f
printErrorHelpAndExit	utils\jacobian.sh	/^printErrorHelpAndExit()$/;"	f
printHelpAndExit	utils\jacobian.sh	/^printHelpAndExit()$/;"	f
OptionParser	utils\max_jacobian.py	/^from optparse import OptionParser$/;"	i
T	utils\max_jacobian.py	/^T = shape(a)[1]$/;"	v
Z	utils\max_jacobian.py	/^		Z = sum([exp(x) for x in col])$/;"	v
a	utils\max_jacobian.py	/^	a = io.read_array(file(f.strip()), lines=[1,-1])$/;"	v
a	utils\max_jacobian.py	/^a = io.read_array(file(outactsfile), lines=[2,-1])$/;"	v
c	utils\max_jacobian.py	/^		c = c[:-1]$/;"	v
c	utils\max_jacobian.py	/^		c = list(v[:,t])$/;"	v
c	utils\max_jacobian.py	/^	c = list(a[:,t])$/;"	v
col	utils\max_jacobian.py	/^		col = a[:,input]$/;"	v
col	utils\max_jacobian.py	/^		col = v[:,t]$/;"	v
i	utils\max_jacobian.py	/^		i = c.index(max(c))$/;"	v
io	utils\max_jacobian.py	/^from scipy import io$/;"	i
jaclistfile	utils\max_jacobian.py	/^jaclistfile = args[0]$/;"	v
labels	utils\max_jacobian.py	/^labels = file(outactsfile).readline().split()[1:]$/;"	v
m	utils\max_jacobian.py	/^		m = c.index(max(c))$/;"	v
m	utils\max_jacobian.py	/^	m = c.index(max(c))$/;"	v
maxindices	utils\max_jacobian.py	/^maxindices = []$/;"	v
out	utils\max_jacobian.py	/^out = file(outfile, 'w')$/;"	v
outactsfile	utils\max_jacobian.py	/^outactsfile = args[1]$/;"	v
outfile	utils\max_jacobian.py	/^outfile = args[2]$/;"	v
output	utils\max_jacobian.py	/^	output = int(f.split('\/')[-2].split('_')[-1])$/;"	v
parser	utils\max_jacobian.py	/^parser = OptionParser(usage)$/;"	v
usage	utils\max_jacobian.py	/^usage = "usage: %prog [options] jacobian_list_file output_activations_file output_file"$/;"	v
v	utils\max_jacobian.py	/^	v = zeros((T,T),'f')$/;"	v
v	utils\max_jacobian.py	/^	v = zeros((len(labels),T),'f')$/;"	v
OptionParser	utils\min_max.py	/^from optparse import OptionParser$/;"	i
data	utils\min_max.py	/^		data = l.split()$/;"	v
f	utils\min_max.py	/^			f = float(d)$/;"	v
filePattern	utils\min_max.py	/^filePattern = args[0]$/;"	v
filenames	utils\min_max.py	/^filenames = glob.glob(filePattern)$/;"	v
glob	utils\min_max.py	/^import glob$/;"	i
lines	utils\min_max.py	/^	lines = file(f).readlines()$/;"	v
maxVal	utils\min_max.py	/^				maxVal = f$/;"	v
maxVal	utils\min_max.py	/^maxVal = -minVal$/;"	v
minVal	utils\min_max.py	/^				minVal = f$/;"	v
minVal	utils\min_max.py	/^minVal = 100000000.0$/;"	v
parser	utils\min_max.py	/^parser = OptionParser(usage)$/;"	v
usage	utils\min_max.py	/^usage = "usage: %prog input-file"$/;"	v
NetCDFFile	utils\netcdf_helpers.py	/^from Scientific.IO.NetCDF import NetCDFFile$/;"	i
createNcDim	utils\netcdf_helpers.py	/^def createNcDim(ncfile,name,d):$/;"	f
maxLen	utils\netcdf_helpers.py	/^def maxLen(strings):$/;"	f
maxLength	utils\netcdf_helpers.py	/^	maxLength = maxLen(strings) + 1$/;"	v
nullStrings	utils\netcdf_helpers.py	/^	nullStrings = []$/;"	v
OptionParser	utils\normalise_netcdf.py	/^from optparse import OptionParser$/;"	i
Std	utils\normalise_netcdf.py	/^def Std(array,axis):$/;"	f
infile	utils\normalise_netcdf.py	/^infile = netcdf_helpers.NetCDFFile(inputFilename, 'r')$/;"	v
inputFilename	utils\normalise_netcdf.py	/^inputFilename = args[0]$/;"	v
inputMeans	utils\normalise_netcdf.py	/^	inputMeans = array(stdMeanFile.variables[options.inputArrayName+'Means'].getValue())$/;"	v
inputMeans	utils\normalise_netcdf.py	/^	inputMeans=mean(outputArray[:options.maxArraySize],0)$/;"	v
inputStds	utils\normalise_netcdf.py	/^	inputStds = array(stdMeanFile.variables[options.inputArrayName+'Stds'].getValue())$/;"	v
inputStds	utils\normalise_netcdf.py	/^	inputStds=Std(outputArray[:options.maxArraySize],0)$/;"	v
inputVar	utils\normalise_netcdf.py	/^inputVar = infile.variables[options.inputArrayName]$/;"	v
max	utils\normalise_netcdf.py	/^				max = min (offset+step, len(outputArray))$/;"	v
netcdf_helpers	utils\normalise_netcdf.py	/^import netcdf_helpers$/;"	i
offset	utils\normalise_netcdf.py	/^			offset = 0$/;"	v
outfile	utils\normalise_netcdf.py	/^outfile = netcdf_helpers.NetCDFFile(outputFilename, 'w')$/;"	v
outputArray	utils\normalise_netcdf.py	/^	outputArray = inputVar.getValue()$/;"	v
outputArray	utils\normalise_netcdf.py	/^outputArray = zeros(inputVar.shape, 'f')$/;"	v
outputFilename	utils\normalise_netcdf.py	/^outputFilename = args[1]$/;"	v
parser	utils\normalise_netcdf.py	/^parser = OptionParser("usage: %prog input_filename output_filename")$/;"	v
stdMeanFile	utils\normalise_netcdf.py	/^	stdMeanFile = netcdf_helpers.NetCDFFile(options.stdMeanFilename, 'r')$/;"	v
step	utils\normalise_netcdf.py	/^			step = options.maxArraySize$/;"	v
sys	utils\normalise_netcdf.py	/^import sys$/;"	i
printErrorHelpAndExit	utils\normalise_netcdf.sh	/^printErrorHelpAndExit()$/;"	f
printHelpAndExit	utils\normalise_netcdf.sh	/^printHelpAndExit()$/;"	f
OptionParser	utils\plot_errors.py	/^from optparse import OptionParser$/;"	i
allowedErrors	utils\plot_errors.py	/^allowedErrors = opt.errTypes.split()$/;"	v
axes	utils\plot_errors.py	/^		axes = gca()$/;"	v
bestEpochs	utils\plot_errors.py	/^bestEpochs = dict()$/;"	v
epochNum	utils\plot_errors.py	/^		epochNum = int(l.split()[1])$/;"	v
epochNum	utils\plot_errors.py	/^epochNum = -1$/;"	v
errVal	utils\plot_errors.py	/^				errVal = float(words[1].strip('%'))$/;"	v
errWord	utils\plot_errors.py	/^			errWord = words[0]$/;"	v
errorType	utils\plot_errors.py	/^			errorType = ""$/;"	v
errorType	utils\plot_errors.py	/^			errorType = "test"$/;"	v
errorType	utils\plot_errors.py	/^			errorType = "train"$/;"	v
errorType	utils\plot_errors.py	/^			errorType = "validation"$/;"	v
errorType	utils\plot_errors.py	/^errorType = ""$/;"	v
errors	utils\plot_errors.py	/^errors = dict()$/;"	v
filename	utils\plot_errors.py	/^filename = args[0]$/;"	v
lab	utils\plot_errors.py	/^					lab = "best "+best[0]$/;"	v
lab	utils\plot_errors.py	/^					lab = "best network"$/;"	v
lines	utils\plot_errors.py	/^lines = file(filename, 'r').readlines()$/;"	v
parser	utils\plot_errors.py	/^parser = OptionParser(usage)$/;"	v
re	utils\plot_errors.py	/^import re$/;"	i
usage	utils\plot_errors.py	/^usage = "usage: %prog log_file"$/;"	v
words	utils\plot_errors.py	/^	words = l.split()$/;"	v
yRange	utils\plot_errors.py	/^		yRange = [axis()[2], axis()[3]]$/;"	v
Image	utils\plot_variables.py	/^from PIL import Image$/;"	i
OptionParser	utils\plot_variables.py	/^from optparse import OptionParser$/;"	i
arrays	utils\plot_variables.py	/^					arrays = [numpy.array(data[i]),numpy.array(data[i+1]),numpy.array(data[i+2])]$/;"	v
axes	utils\plot_variables.py	/^	axes = axes()$/;"	v
b	utils\plot_variables.py	/^			b = data[2::3]$/;"	v
blockArea	utils\plot_variables.py	/^				blockArea = numpy.product(blockDims)$/;"	v
blockDims	utils\plot_variables.py	/^			blockDims = numpy.array(opt.blockDims.split(',')).astype(int)$/;"	v
blockIndex	utils\plot_variables.py	/^								blockIndex = 0$/;"	v
colors	utils\plot_variables.py	/^	colors = []$/;"	v
colourDepth	utils\plot_variables.py	/^							colourDepth = 1$/;"	v
colourDepth	utils\plot_variables.py	/^							colourDepth = 3$/;"	v
d	utils\plot_variables.py	/^			d = int(d)$/;"	v
data	utils\plot_variables.py	/^				data = newData$/;"	v
data	utils\plot_variables.py	/^			data = newData$/;"	v
data	utils\plot_variables.py	/^			data = r_[r,g,b]$/;"	v
data	utils\plot_variables.py	/^	data = array(newdata)$/;"	v
data	utils\plot_variables.py	/^	data = data[:5]$/;"	v
data	utils\plot_variables.py	/^	data = data[opt.min:]$/;"	v
data	utils\plot_variables.py	/^	data = data[opt.min:opt.max]$/;"	v
data	utils\plot_variables.py	/^	data = newdata$/;"	v
data	utils\plot_variables.py	/^data = file(infilename)$/;"	v
data	utils\plot_variables.py	/^data = loadtxt(infilename, skiprows = numRowsToSkip)$/;"	v
dimensions	utils\plot_variables.py	/^dimensions = []$/;"	v
fig	utils\plot_variables.py	/^			fig = figure()$/;"	v
fig	utils\plot_variables.py	/^		fig = figure()$/;"	v
fig	utils\plot_variables.py	/^	fig = figure()$/;"	v
g	utils\plot_variables.py	/^			g = data[1::3]$/;"	v
gridDims	utils\plot_variables.py	/^			gridDims = dimensions[-2:]$/;"	v
gridDims	utils\plot_variables.py	/^	gridDims = [int(i) for i in opt.gridDims.split()]$/;"	v
gridDims	utils\plot_variables.py	/^gridDims = None$/;"	v
height	utils\plot_variables.py	/^						height = len(data[i]) \/ gridDims[0]$/;"	v
i	utils\plot_variables.py	/^			i = int(v)$/;"	v
i	utils\plot_variables.py	/^			i = labels.index(v)$/;"	v
ignoreList	utils\plot_variables.py	/^ignoreList = opt.ignore.replace(',', ' ').split()$/;"	v
index	utils\plot_variables.py	/^						index = 0$/;"	v
infilename	utils\plot_variables.py	/^infilename = args[0]$/;"	v
lab	utils\plot_variables.py	/^			lab = labels[c]$/;"	v
lab	utils\plot_variables.py	/^			lab = str(c)$/;"	v
labelledLines	utils\plot_variables.py	/^	labelledLines = False	$/;"	v
labelledLines	utils\plot_variables.py	/^	labelledLines = True$/;"	v
labels	utils\plot_variables.py	/^		labels = line[1:]$/;"	v
labels	utils\plot_variables.py	/^		labels = newlabels$/;"	v
labels	utils\plot_variables.py	/^labels = []$/;"	v
line	utils\plot_variables.py	/^	line = data.readline().split()$/;"	v
line	utils\plot_variables.py	/^line = data.readline().split()$/;"	v
line2d	utils\plot_variables.py	/^		line2d = axes.plot(lineData, linewidth=1.5, label = lab)[0]$/;"	v
lineData	utils\plot_variables.py	/^		lineData = data[c,:]$/;"	v
lineLabelMap	utils\plot_variables.py	/^	lineLabelMap = dict()$/;"	v
lines	utils\plot_variables.py	/^	lines = set()$/;"	v
max	utils\plot_variables.py	/^					max = val$/;"	v
max	utils\plot_variables.py	/^			max = 0$/;"	v
maxNum	utils\plot_variables.py	/^					maxNum = v$/;"	v
maxNum	utils\plot_variables.py	/^			maxNum = -1$/;"	v
newData	utils\plot_variables.py	/^				newData = []$/;"	v
newData	utils\plot_variables.py	/^			newData = []$/;"	v
newdata	utils\plot_variables.py	/^	newdata = []$/;"	v
newdata	utils\plot_variables.py	/^	newdata = array(newdata)$/;"	v
newlabels	utils\plot_variables.py	/^	newlabels = []$/;"	v
newline	utils\plot_variables.py	/^						newline = zeros((width*blockDims[0], height*blockDims[1], colourDepth), 'f')$/;"	v
numRowsToSkip	utils\plot_variables.py	/^numRowsToSkip = 0$/;"	v
parser	utils\plot_variables.py	/^parser = OptionParser(usage)$/;"	v
pcolorLine	utils\plot_variables.py	/^def pcolorLine(line, gridDims):$/;"	f
prevMaxNum	utils\plot_variables.py	/^					prevMaxNum = maxNum$/;"	v
prevMaxNum	utils\plot_variables.py	/^		prevMaxNum = -1$/;"	v
r	utils\plot_variables.py	/^			r = data[::3]$/;"	v
rgbDevs	utils\plot_variables.py	/^			rgbDevs = numpy.array(opt.rgbDevs.split(',')).astype(float)$/;"	v
rgbMeans	utils\plot_variables.py	/^			rgbMeans = numpy.array(opt.rgbMeans.split(',')).astype(float)$/;"	v
sys	utils\plot_variables.py	/^import sys$/;"	i
usage	utils\plot_variables.py	/^usage = "usage: %prog [opt] input-file"$/;"	v
useList	utils\plot_variables.py	/^useList = opt.use.replace(',', ' ').split()$/;"	v
val	utils\plot_variables.py	/^				val = abs(data[v][r])$/;"	v
width	utils\plot_variables.py	/^						width = gridDims[0]$/;"	v
yPlotCoord	utils\plot_variables.py	/^		yPlotCoord = axes.get_ylim()[1] + 0.01 * (axes.get_ylim()[1] - axes.get_ylim()[0])$/;"	v
OptionParser	utils\plot_weights.py	/^from optparse import OptionParser$/;"	i
connName	utils\plot_weights.py	/^	connName = connStr.split('_')[1:]$/;"	v
connStr	utils\plot_weights.py	/^	connStr = words[0]$/;"	v
connections	utils\plot_weights.py	/^	connections = opt.connections.split()$/;"	v
connections	utils\plot_weights.py	/^connections = None$/;"	v
parser	utils\plot_weights.py	/^parser = OptionParser(usage='Usage: %prog [options] <save_file>')$/;"	v
range	utils\plot_weights.py	/^	range = [float(f) for f in opt.range.split()]$/;"	v
range	utils\plot_weights.py	/^range = None$/;"	v
sys	utils\plot_weights.py	/^import sys$/;"	i
weightTypes	utils\plot_weights.py	/^weightTypes = opt.weightTypes.split()$/;"	v
words	utils\plot_weights.py	/^	words = l.split()$/;"	v
NetCDFFile	utils\rescale_netcdf_binary_inputs.py	/^from Scientific.IO.NetCDF import NetCDFFile$/;"	i
OptionParser	utils\rescale_netcdf_binary_inputs.py	/^from optparse import OptionParser$/;"	i
filename	utils\rescale_netcdf_binary_inputs.py	/^filename = args[0]$/;"	v
infile	utils\rescale_netcdf_binary_inputs.py	/^infile = NetCDFFile(filename, 'a')$/;"	v
inputs	utils\rescale_netcdf_binary_inputs.py	/^inputs = invar.getValue()$/;"	v
invar	utils\rescale_netcdf_binary_inputs.py	/^invar = infile.variables['inputs']$/;"	v
parser	utils\rescale_netcdf_binary_inputs.py	/^parser = OptionParser("usage: %prog netcdf_filename")$/;"	v
OptionParser	utils\shuffle_and_split.py	/^from optparse import OptionParser$/;"	i
infilename	utils\shuffle_and_split.py	/^infilename = args [0]$/;"	v
line	utils\shuffle_and_split.py	/^line = 0$/;"	v
lines	utils\shuffle_and_split.py	/^lines = file(infilename).readlines()$/;"	v
numDigits	utils\shuffle_and_split.py	/^numDigits = len(str(len(splitlines) - 1))$/;"	v
numSplits	utils\shuffle_and_split.py	/^	numSplits = int(splitstrings[0])$/;"	v
oldl	utils\shuffle_and_split.py	/^	oldl =l$/;"	v
oldl	utils\shuffle_and_split.py	/^oldl = 0$/;"	v
out	utils\shuffle_and_split.py	/^	out = file(outroot + '_' + str(i).rjust(numDigits, '0') + '.txt', 'w')$/;"	v
outroot	utils\shuffle_and_split.py	/^outroot = args[2]$/;"	v
parser	utils\shuffle_and_split.py	/^parser = OptionParser("usage: %prog [options] input_file split_fractions output_root")$/;"	v
random	utils\shuffle_and_split.py	/^import random$/;"	i
splitfracs	utils\shuffle_and_split.py	/^	splitfracs = [1.0\/numSplits] * numSplits$/;"	v
splitfracs	utils\shuffle_and_split.py	/^	splitfracs = [float(i) for i in splitstrings]$/;"	v
splitlines	utils\shuffle_and_split.py	/^splitlines = []$/;"	v
splitstrings	utils\shuffle_and_split.py	/^splitstrings = args[1].split()$/;"	v
sys	utils\shuffle_and_split.py	/^import sys$/;"	i
numVals	utils\std_dev_mean.py	/^numVals = len(vals)$/;"	v
numpy	utils\std_dev_mean.py	/^import numpy$/;"	i
sqrt	utils\std_dev_mean.py	/^from math import sqrt$/;"	i
stdDev	utils\std_dev_mean.py	/^stdDev = numpy.std(vals)$/;"	v
sys	utils\std_dev_mean.py	/^import sys$/;"	i
vals	utils\std_dev_mean.py	/^vals = []$/;"	v
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_PROGRAM_VERSION	5.8	//
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
