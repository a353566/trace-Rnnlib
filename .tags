!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
BMISLCI	.\src\Helpers.hpp	/^typedef bimap<int, string>::left_const_iterator BMISLCI;$/;"	t
BMISR	.\src\Helpers.hpp	/^typedef bimap<int, string>::relation BMISR;$/;"	t
BMISRCI	.\src\Helpers.hpp	/^typedef bimap<int, string>::right_const_iterator BMISRCI;$/;"	t
BaseGenType	.\src\Random.cpp	/^typedef mt19937 BaseGenType;$/;"	t	file:
BiasLayer	.\src\BiasLayer.hpp	/^	BiasLayer():$/;"	f	struct:BiasLayer
BiasLayer	.\src\BiasLayer.hpp	/^struct BiasLayer: public Layer$/;"	s
BinaryClassificationLayer	.\src\ClassificationLayer.hpp	/^	BinaryClassificationLayer(ostream& out, const string& name, size_t numSeqDims, const vector<string>& labels):$/;"	f	struct:BinaryClassificationLayer
BinaryClassificationLayer	.\src\ClassificationLayer.hpp	/^struct BinaryClassificationLayer: public ClassificationLayer, public NeuronLayer<Logistic>$/;"	s
BlockLayer	.\src\BlockLayer.hpp	/^	BlockLayer(Layer* src, const vector<size_t>& blockshape):$/;"	f	struct:BlockLayer
BlockLayer	.\src\BlockLayer.hpp	/^struct BlockLayer: public Layer$/;"	s
CHECK_STRICT	.\src\Helpers.hpp	162;"	d
COD	.\src\Helpers.hpp	63;"	d
CONN_IT	.\src\Mdrnn.hpp	/^typedef multimap<const Layer*, Connection*>::iterator CONN_IT ;$/;"	t
CONST_CONN_IT	.\src\Mdrnn.hpp	/^typedef multimap<const Layer*, Connection*>::const_iterator CONST_CONN_IT;$/;"	t
CONST_EXPORT_IT	.\src\DataExporter.hpp	/^typedef map<string, DataExporter*>::const_iterator CONST_EXPORT_IT;$/;"	t
CONST_LAYER_IT	.\src\Mdrnn.hpp	/^typedef vector<Layer*>::const_iterator CONST_LAYER_IT;$/;"	t
CONST_SEQ_IT	.\src\NetcdfDataset.hpp	33;"	d
CONST_VAL_IT	.\src\DataExporter.hpp	/^typedef map<string, Val*>::const_iterator CONST_VAL_IT;$/;"	t
COUT	.\src\Helpers.hpp	/^static ostream& COUT = cout;$/;"	v
CVI	.\src\SeqBuffer.hpp	115;"	d
ClassificationLayer	.\src\ClassificationLayer.hpp	/^	ClassificationLayer(ostream& o, const vector<string>& labs):$/;"	f	struct:ClassificationLayer
ClassificationLayer	.\src\ClassificationLayer.hpp	/^struct ClassificationLayer: public NetworkOutput$/;"	s
CollapseLayer	.\src\CollapseLayer.hpp	/^	CollapseLayer(Layer* src, Layer* des, const vector<bool>& activDims = empty_list_of<bool>()):$/;"	f	struct:CollapseLayer
CollapseLayer	.\src\CollapseLayer.hpp	/^struct CollapseLayer: public Layer$/;"	s
ConfigFile	.\src\ConfigFile.hpp	/^	ConfigFile(const string& fname, char readLineChar = '_'):$/;"	f	struct:ConfigFile
ConfigFile	.\src\ConfigFile.hpp	/^struct ConfigFile$/;"	s
Connection	.\src\Connection.hpp	/^	Connection(const string& name, Layer* f, Layer* t):$/;"	f	struct:Connection
Connection	.\src\Connection.hpp	/^struct Connection: public Named$/;"	s
CoordIterator	.\src\SeqBuffer.hpp	/^	CoordIterator (const R& sh, const vector<int>& dirs = empty_list_of<int>(), bool reverse = false):$/;"	f	struct:CoordIterator
CoordIterator	.\src\SeqBuffer.hpp	/^template <class R> struct CoordIterator$/;"	s
CopyConnection	.\src\CopyConnection.hpp	/^	CopyConnection(Layer* f, Layer* t):$/;"	f	struct:CopyConnection
CopyConnection	.\src\CopyConnection.hpp	/^struct CopyConnection: public Connection$/;"	s
DISPLAY	.\src\DataExporter.hpp	29;"	d
DO	.\src\Helpers.hpp	60;"	d
DOC	.\src\Helpers.hpp	61;"	d
DataExportHandler	.\src\DataExporter.hpp	/^struct DataExportHandler$/;"	s
DataExporter	.\src\DataExporter.hpp	/^	DataExporter(const string& name):$/;"	f	struct:DataExporter
DataExporter	.\src\DataExporter.hpp	/^struct DataExporter: public Named$/;"	s
DataHeader	.\src\NetcdfDataset.hpp	/^	DataHeader(const string& filename, const string& task, real_t dataFraction):$/;"	f	struct:DataHeader
DataHeader	.\src\NetcdfDataset.hpp	/^struct DataHeader$/;"	s
DataList	.\src\NetcdfDataset.hpp	/^	DataList(const vector<string>& filenams, const string& t, bool shuffle, real_t loadFrac):$/;"	f	struct:DataList
DataList	.\src\NetcdfDataset.hpp	/^struct DataList$/;"	s
DataSequence	.\src\DataSequence.hpp	/^	DataSequence(const DataSequence& ds):$/;"	f	struct:DataSequence
DataSequence	.\src\DataSequence.hpp	/^	DataSequence(size_t inputDepth = 0, size_t targetPattDepth = 0):$/;"	f	struct:DataSequence
DataSequence	.\src\DataSequence.hpp	/^struct DataSequence$/;"	s
DatasetErrors	.\src\DatasetErrors.hpp	/^	DatasetErrors(){}$/;"	f	struct:DatasetErrors
DatasetErrors	.\src\DatasetErrors.hpp	/^struct DatasetErrors$/;"	s
ERR	.\src\NetworkOutput.hpp	24;"	d
EXPORT_IT	.\src\DataExporter.hpp	/^typedef map<string, DataExporter*>::iterator EXPORT_IT;$/;"	t
FOR	.\src\Helpers.hpp	67;"	d
FROM	.\src\Helpers.hpp	65;"	d
FlatLayer	.\src\Layer.hpp	/^	FlatLayer(const string& name, const vector<int>& dirs, size_t size, Layer* src = 0):$/;"	f	struct:FlatLayer
FlatLayer	.\src\Layer.hpp	/^	FlatLayer(const string& name, size_t numSeqDims, size_t size, Layer* src = 0):$/;"	f	struct:FlatLayer
FlatLayer	.\src\Layer.hpp	/^struct FlatLayer: public Layer$/;"	s
FullConnection	.\src\FullConnection.hpp	/^	FullConnection(Layer* f, Layer* t, const vector<int>& d = empty_list_of<int>(), FullConnection* s = 0):$/;"	f	struct:FullConnection
FullConnection	.\src\FullConnection.hpp	/^struct FullConnection: public Connection$/;"	s
GatherLayer	.\src\GatherLayer.hpp	/^	GatherLayer(const string& name, vector<Layer*>& srcs):$/;"	f	struct:GatherLayer
GatherLayer	.\src\GatherLayer.hpp	/^struct GatherLayer: public Layer$/;"	s
GradientCheck	.\src\GradientCheck.hpp	/^	GradientCheck(ostream& o, Mdrnn* n, const DataSequence& s, unsigned sf = 6, $/;"	f	struct:GradientCheck
GradientCheck	.\src\GradientCheck.hpp	/^struct GradientCheck$/;"	s
HAVE_INTTYPES_H	.\config.h	5;"	d
HAVE_LIBM	.\config.h	8;"	d
HAVE_LIBNETCDF	.\config.h	11;"	d
HAVE_LIBNETCDF_C__	.\config.h	14;"	d
HAVE_LIBSTDC__	.\config.h	17;"	d
HAVE_MALLOC_H	.\config.h	20;"	d
HAVE_MEMORY_H	.\config.h	23;"	d
HAVE_STDINT_H	.\config.h	26;"	d
HAVE_STDLIB_H	.\config.h	29;"	d
HAVE_STRINGS_H	.\config.h	32;"	d
HAVE_STRING_H	.\config.h	35;"	d
HAVE_SYS_STAT_H	.\config.h	38;"	d
HAVE_SYS_TYPES_H	.\config.h	41;"	d
HAVE_TIME_H	.\config.h	44;"	d
HAVE_UNISTD_H	.\config.h	47;"	d
Identity	.\src\ActivationFunctions.hpp	/^struct Identity$/;"	s
IdentityLayer	.\src\IdentityLayer.hpp	/^	IdentityLayer(const string& name, const vector<int>& directions, size_t size):$/;"	f	struct:IdentityLayer
IdentityLayer	.\src\IdentityLayer.hpp	/^	IdentityLayer(const string& name, size_t numSeqDims, size_t size):$/;"	f	struct:IdentityLayer
IdentityLayer	.\src\IdentityLayer.hpp	/^struct IdentityLayer: public FlatLayer$/;"	s
Image	.\examples\arabic_offline_handwriting\arabic_offline.py	/^from PIL import Image$/;"	i
Image	.\examples\farsi_offline_handwriting\farsi_chars.py	/^from PIL import Image$/;"	i
Image	.\utils\plot_variables.py	/^from PIL import Image$/;"	i
InputLayer	.\src\InputLayer.hpp	/^	InputLayer(const string& name, size_t numSeqDims, size_t size, const vector<string>& inputLabels):$/;"	f	struct:InputLayer
InputLayer	.\src\InputLayer.hpp	/^struct InputLayer: public Layer$/;"	s
KL_normal	.\src\Helpers.hpp	/^static real_t KL_normal(real_t pMean, real_t pVar, real_t qMean, real_t qVar)$/;"	f
LAYER_IT	.\src\Mdrnn.hpp	/^typedef vector<Layer*>::iterator LAYER_IT;$/;"	t
LEVEL_IT	.\src\Mdrnn.hpp	/^typedef vector<vector<Layer*> >::iterator LEVEL_IT;$/;"	t
LOOP	.\src\Helpers.hpp	58;"	d
LOOP_BACK	.\src\Helpers.hpp	59;"	d
Layer	.\src\Layer.hpp	/^	Layer(const string& name, const vector<int>& dirs, size_t inputSize, size_t outputSize, Layer* src = 0):$/;"	f	struct:Layer
Layer	.\src\Layer.hpp	/^	Layer(const string& name, size_t numSeqDims, size_t inputSize, size_t outputSize, Layer* src = 0):$/;"	f	struct:Layer
Layer	.\src\Layer.hpp	/^struct Layer: public DataExporter$/;"	s
Log	.\src\Log.hpp	/^	Log(T v = 0, bool logScale = false):$/;"	f	class:Log
Log	.\src\Log.hpp	/^template<class T> class Log$/;"	c
Logistic	.\src\ActivationFunctions.hpp	/^struct Logistic$/;"	s
LstmLayer	.\src\LstmLayer.hpp	/^	LstmLayer(const string& name, const vector<int>& directions, size_t nb, size_t cpb = 1, LstmLayer<CI,CO,G>* ps = 0):$/;"	f	struct:LstmLayer
LstmLayer	.\src\LstmLayer.hpp	/^template <class CI, class CO, class G> struct LstmLayer: public Layer$/;"	s
MCSPDICI	.\src\Helpers.hpp	/^typedef map <string, pair<real_t, int> >::const_iterator MCSPDICI;$/;"	t
MCSPDII	.\src\Helpers.hpp	/^typedef map <string, pair<real_t, int> >::iterator MCSPDII;$/;"	t
MIICI	.\src\Helpers.hpp	/^typedef map<int, int>::const_iterator MIICI;$/;"	t
MIII	.\src\Helpers.hpp	/^typedef map<int, int>::iterator MIII;$/;"	t
MORF	.\src\Helpers.hpp	66;"	d
MSDCI	.\src\Helpers.hpp	/^typedef map<string, real_t>::const_iterator MSDCI;$/;"	t
MSDI	.\src\Helpers.hpp	/^typedef map<string, real_t>::iterator MSDI;$/;"	t
MSICI	.\src\Helpers.hpp	/^typedef map<string, int>::const_iterator MSICI;$/;"	t
MSII	.\src\Helpers.hpp	/^typedef map<string, int>::iterator MSII;$/;"	t
MSPIDCI	.\src\Helpers.hpp	/^typedef map<string, pair<int,real_t> >::const_iterator MSPIDCI;$/;"	t
MSPIDI	.\src\Helpers.hpp	/^typedef map<string, pair<int,real_t> >::iterator MSPIDI;$/;"	t
MSSCI	.\src\Helpers.hpp	/^typedef map<string, string>::const_iterator MSSCI;$/;"	t
MSSI	.\src\Helpers.hpp	/^typedef map<string, string>::iterator MSSI;$/;"	t
Max2min0	.\src\ActivationFunctions.hpp	/^struct Max2min0$/;"	s
Maxmin1	.\src\ActivationFunctions.hpp	/^struct Maxmin1$/;"	s
Maxmin2	.\src\ActivationFunctions.hpp	/^struct Maxmin2$/;"	s
Mdrnn	.\src\Mdrnn.hpp	/^	Mdrnn(ostream& o, ConfigFile& conf, const DataHeader& data):$/;"	f	struct:Mdrnn
Mdrnn	.\src\Mdrnn.hpp	/^struct Mdrnn$/;"	s
MultiArray	.\src\MultiArray.hpp	/^	MultiArray()$/;"	f	struct:MultiArray
MultiArray	.\src\MultiArray.hpp	/^	MultiArray(const vector<size_t>& s)$/;"	f	struct:MultiArray
MultiArray	.\src\MultiArray.hpp	/^	MultiArray(const vector<size_t>& s, const T& fillval)$/;"	f	struct:MultiArray
MultiArray	.\src\MultiArray.hpp	/^template <class T> struct MultiArray$/;"	s
MulticlassClassificationLayer	.\src\ClassificationLayer.hpp	/^	MulticlassClassificationLayer(ostream& out, const string& name, size_t numSeqDims, const vector<string>& labels):$/;"	f	struct:MulticlassClassificationLayer
MulticlassClassificationLayer	.\src\ClassificationLayer.hpp	/^struct MulticlassClassificationLayer: public ClassificationLayer, public SoftmaxLayer$/;"	s
MultilayerNet	.\src\MultilayerNet.hpp	/^	MultilayerNet(ostream& out, ConfigFile& conf, const DataHeader& data):$/;"	f	struct:MultilayerNet
MultilayerNet	.\src\MultilayerNet.hpp	/^struct MultilayerNet: public Mdrnn$/;"	s
Named	.\src\Named.hpp	/^	Named(const string & n):$/;"	f	struct:Named
Named	.\src\Named.hpp	/^struct Named$/;"	s
NetCDFFile	.\utils\netcdf_helpers.py	/^from Scientific.IO.NetCDF import NetCDFFile$/;"	i
NetCDFFile	.\utils\rescale_netcdf_binary_inputs.py	/^from Scientific.IO.NetCDF import NetCDFFile$/;"	i
NetcdfDataset	.\src\NetcdfDataset.hpp	/^	NetcdfDataset(const string& fname, const string& t, int seqNum):$/;"	f	struct:NetcdfDataset
NetcdfDataset	.\src\NetcdfDataset.hpp	/^	NetcdfDataset(const string& fname, const string& t, real_t dataFraction = 1.0):$/;"	f	struct:NetcdfDataset
NetcdfDataset	.\src\NetcdfDataset.hpp	/^struct NetcdfDataset$/;"	s
NetworkOutput	.\src\NetworkOutput.hpp	/^	NetworkOutput(){}$/;"	f	struct:NetworkOutput
NetworkOutput	.\src\NetworkOutput.hpp	/^struct NetworkOutput$/;"	s
NeuronLayer	.\src\NeuronLayer.hpp	/^	NeuronLayer(const string& name, const vector<int>& directions, size_t size):$/;"	f	struct:NeuronLayer
NeuronLayer	.\src\NeuronLayer.hpp	/^	NeuronLayer(const string& name, size_t numDims, size_t size):$/;"	f	struct:NeuronLayer
NeuronLayer	.\src\NeuronLayer.hpp	/^template <class F> struct NeuronLayer: public FlatLayer$/;"	s
OD	.\src\Helpers.hpp	62;"	d
OP_TRACKING	.\src\Matrix.hpp	21;"	d
Optimiser	.\src\Optimiser.hpp	/^	Optimiser(vector<real_t>& weights, vector<real_t>& derivatives):$/;"	f	struct:Optimiser
Optimiser	.\src\Optimiser.hpp	/^struct Optimiser$/;"	s
OptionParser	.\examples\arabic_offline_handwriting\arabic_offline.py	/^from optparse import OptionParser$/;"	i
OptionParser	.\examples\arabic_online_handwriting\arabic_online.py	/^from optparse import OptionParser$/;"	i
OptionParser	.\examples\farsi_offline_handwriting\farsi_chars.py	/^from optparse import OptionParser$/;"	i
OptionParser	.\utils\dump_weight_matrices.py	/^from optparse import OptionParser$/;"	i
OptionParser	.\utils\dump_weights.py	/^from optparse import OptionParser$/;"	i
OptionParser	.\utils\max_jacobian.py	/^from optparse import OptionParser$/;"	i
OptionParser	.\utils\min_max.py	/^from optparse import OptionParser$/;"	i
OptionParser	.\utils\normalise_netcdf.py	/^from optparse import OptionParser$/;"	i
OptionParser	.\utils\plot_errors.py	/^from optparse import OptionParser$/;"	i
OptionParser	.\utils\plot_variables.py	/^from optparse import OptionParser$/;"	i
OptionParser	.\utils\plot_weights.py	/^from optparse import OptionParser$/;"	i
OptionParser	.\utils\rescale_netcdf_binary_inputs.py	/^from optparse import OptionParser$/;"	i
OptionParser	.\utils\shuffle_and_split.py	/^from optparse import OptionParser$/;"	i
PACKAGE	.\config.h	50;"	d
PACKAGE_BUGREPORT	.\config.h	53;"	d
PACKAGE_NAME	.\config.h	56;"	d
PACKAGE_STRING	.\config.h	59;"	d
PACKAGE_TARNAME	.\config.h	62;"	d
PACKAGE_VERSION	.\config.h	65;"	d
PCSD	.\src\Helpers.hpp	/^typedef pair<const string, real_t> PCSD;$/;"	t
PEEPS	.\src\LstmLayer.hpp	24;"	d
PII	.\src\Helpers.hpp	/^typedef pair<int, int> PII;$/;"	t
PIS	.\src\Helpers.hpp	/^typedef pair<int, string> PIS;$/;"	t
PLC	.\src\Mdrnn.hpp	/^typedef pair<const Layer*, Connection*> PLC;$/;"	t
PRINT	.\src\Helpers.hpp	155;"	d
PRINTN	.\src\Helpers.hpp	156;"	d
PRINTR	.\src\Helpers.hpp	159;"	d
PRT	.\src\Helpers.hpp	157;"	d
PRTN	.\src\Helpers.hpp	158;"	d
PRTR	.\src\Helpers.hpp	160;"	d
PSD	.\src\Helpers.hpp	/^typedef pair<string, real_t> PSD;$/;"	t
PSI	.\src\Helpers.hpp	/^typedef pair<string, int> PSI;$/;"	t
PSPDE	.\src\DataExporter.hpp	/^typedef pair<const string, DataExporter*> PSPDE;$/;"	t
PSPIDE	.\src\DatasetErrors.hpp	/^typedef pair<const string, pair<int, DatasetErrors> > PSPIDE;$/;"	t
PSPV	.\src\DataExporter.hpp	/^typedef pair<const string, Val*> PSPV;$/;"	t
PSS	.\src\Helpers.hpp	/^typedef pair<string, string> PSS;$/;"	t
ParamVal	.\src\DataExporter.hpp	/^	ParamVal(T& p):$/;"	f	struct:ParamVal
ParamVal	.\src\DataExporter.hpp	/^template <typename T> struct ParamVal: public Val$/;"	s
REPEAT	.\src\Helpers.hpp	64;"	d
REVERSE_LAYER_IT	.\src\Mdrnn.hpp	/^typedef vector<Layer*>::reverse_iterator REVERSE_LAYER_IT;$/;"	t
ROF	.\src\Helpers.hpp	68;"	d
Random	.\src\Random.hpp	/^namespace Random$/;"	n
RangeVal	.\src\DataExporter.hpp	/^	RangeVal(const R& r):$/;"	f	struct:RangeVal
RangeVal	.\src\DataExporter.hpp	/^template <typename R> struct RangeVal: public Val$/;"	s
Rprop	.\src\Rprop.hpp	/^	Rprop(const string& name, ostream& o, vector<real_t>& weights, vector<real_t>& derivatives, $/;"	f	struct:Rprop
Rprop	.\src\Rprop.hpp	/^struct Rprop: public DataExporter, public Optimiser$/;"	s
SAVE	.\src\DataExporter.hpp	28;"	d
SCI	.\src\Helpers.hpp	/^typedef string::const_iterator SCI;$/;"	t
SEQ_IT	.\src\NetcdfDataset.hpp	32;"	d
SI	.\src\Helpers.hpp	/^typedef string::iterator SI;$/;"	t
STDC_HEADERS	.\config.h	68;"	d
SeqBuffer	.\src\SeqBuffer.hpp	/^	SeqBuffer(const SeqBuffer& sb)$/;"	f	struct:SeqBuffer
SeqBuffer	.\src\SeqBuffer.hpp	/^	SeqBuffer(const vector<size_t>& shape, size_t dep):$/;"	f	struct:SeqBuffer
SeqBuffer	.\src\SeqBuffer.hpp	/^	SeqBuffer(size_t dep = 0):$/;"	f	struct:SeqBuffer
SeqBuffer	.\src\SeqBuffer.hpp	/^template <class T> struct SeqBuffer: public MultiArray<T>$/;"	s
SeqBufferVal	.\src\DataExporter.hpp	/^	SeqBufferVal(const SeqBuffer<T>& a, const vector<string>* labs = 0):$/;"	f	struct:SeqBufferVal
SeqBufferVal	.\src\DataExporter.hpp	/^template <typename T> struct SeqBufferVal: public Val$/;"	s
SeqIterator	.\src\SeqBuffer.hpp	116;"	d
Set	.\src\Container.hpp	/^	Set()$/;"	f	struct:Set
Set	.\src\Container.hpp	/^	Set(const View<T>& v)$/;"	f	struct:Set
Set	.\src\Container.hpp	/^	Set(const vector<T>& v)$/;"	f	struct:Set
Set	.\src\Container.hpp	/^template<class T> struct Set: public set<T>$/;"	s
SoftmaxLayer	.\src\SoftmaxLayer.hpp	/^	SoftmaxLayer(const string& name, size_t numSeqDims, const vector<string>& labs):$/;"	f	struct:SoftmaxLayer
SoftmaxLayer	.\src\SoftmaxLayer.hpp	/^struct SoftmaxLayer: public FlatLayer$/;"	s
Softsign	.\src\ActivationFunctions.hpp	/^struct Softsign$/;"	s
Std	.\utils\normalise_netcdf.py	/^def Std(array,axis):$/;"	f
SteepestDescent	.\src\SteepestDescent.hpp	/^	SteepestDescent(const string& name, ostream& o, vector<real_t>& weights, vector<real_t>& derivatives, $/;"	f	struct:SteepestDescent
SteepestDescent	.\src\SteepestDescent.hpp	/^struct SteepestDescent: public DataExporter, public Optimiser$/;"	s
StringAlignment	.\src\StringAlignment.hpp	/^	StringAlignment (const R1& reference_sequence, const R2& test_sequence, $/;"	f	struct:StringAlignment
StringAlignment	.\src\StringAlignment.hpp	/^template<class R1, class R2> struct StringAlignment$/;"	s
T	.\utils\max_jacobian.py	/^T = shape(a)[1]$/;"	v
TDD	.\src\Helpers.hpp	/^typedef const tuple<real_t&, real_t&>& TDD;$/;"	t
TDDCF	.\src\Helpers.hpp	/^typedef const tuple<real_t&, real_t&, real_t>& TDDCF;$/;"	t
TDDD	.\src\Helpers.hpp	/^typedef const tuple<real_t&, real_t&, real_t&>& TDDD;$/;"	t
TDDDD	.\src\Helpers.hpp	/^typedef const tuple<real_t&, real_t&, real_t&, real_t&>& TDDDD;$/;"	t
TDDDDD	.\src\Helpers.hpp	/^typedef const tuple<real_t&, real_t&, real_t&, real_t&, real_t&>& TDDDDD;$/;"	t
TDDF	.\src\Helpers.hpp	/^typedef const tuple<real_t&, real_t&, real_t&>& TDDF;$/;"	t
TDDI	.\src\Helpers.hpp	/^typedef const tuple<real_t&, real_t&, int&>& TDDI;$/;"	t
TDL	.\src\Helpers.hpp	/^typedef const tuple<real_t, Log<real_t>& >& TDL;$/;"	t
TDLL	.\src\Helpers.hpp	/^typedef const tuple<real_t&, Log<real_t>, Log<real_t> >& TDLL;$/;"	t
TIBI	.\src\Helpers.hpp	/^typedef const tuple<int&, bool, int>& TIBI;$/;"	t
TID	.\src\Helpers.hpp	/^typedef const tuple<int, real_t>& TID;$/;"	t
TII	.\src\Helpers.hpp	/^typedef const tuple<int, int>& TII;$/;"	t
TIS	.\src\Helpers.hpp	/^typedef const tuple<int, string>& TIS;$/;"	t
TISETI	.\src\Helpers.hpp	/^typedef const tuple<int, set<int>&>& TISETI;$/;"	t
Tanh	.\src\ActivationFunctions.hpp	/^struct Tanh$/;"	s
TeeDev	.\src\Main.cpp	/^typedef boost::iostreams::tee_device<ostream, ofstream> TeeDev;$/;"	t	file:
TeeStream	.\src\Main.cpp	/^typedef boost::iostreams::stream<TeeDev> TeeStream;$/;"	t	file:
Trainer	.\src\Trainer.hpp	/^	Trainer(ostream& o, Mdrnn* n, ConfigFile& conf, const string& name = "trainer"):$/;"	f	struct:Trainer
Trainer	.\src\Trainer.hpp	/^struct Trainer: public DataExporter$/;"	s
TranscriptionLayer	.\src\TranscriptionLayer.hpp	/^	TranscriptionLayer(ostream& o, const string& name, const vector<string>& labs, bool cm = false):$/;"	f	struct:TranscriptionLayer
TranscriptionLayer	.\src\TranscriptionLayer.hpp	/^struct TranscriptionLayer: public SoftmaxLayer, public NetworkOutput$/;"	s
VAL_IT	.\src\DataExporter.hpp	/^typedef map<string, Val*>::iterator VAL_IT;$/;"	t
VBCI	.\src\Helpers.hpp	/^typedef vector<bool>::const_iterator VBCI;$/;"	t
VBI	.\src\Helpers.hpp	/^typedef vector<bool>::iterator VBI;$/;"	t
VDCI	.\src\Helpers.hpp	/^typedef vector<real_t>::const_iterator VDCI;$/;"	t
VDI	.\src\Helpers.hpp	/^typedef vector<real_t>::iterator VDI;$/;"	t
VDRI	.\src\Helpers.hpp	/^typedef vector<real_t>::reverse_iterator VDRI;$/;"	t
VERSION	.\config.h	71;"	d
VFCI	.\src\Helpers.hpp	/^typedef vector<real_t>::const_iterator VFCI;$/;"	t
VFI	.\src\Helpers.hpp	/^typedef vector<real_t>::iterator VFI;$/;"	t
VICI	.\src\Helpers.hpp	/^typedef vector<int>::const_iterator VICI;$/;"	t
VII	.\src\Helpers.hpp	/^typedef vector<int>::iterator VII;$/;"	t
VIRCI	.\src\Helpers.hpp	/^typedef vector<int>::const_reverse_iterator VIRCI;$/;"	t
VIRI	.\src\Helpers.hpp	/^typedef vector<int>::reverse_iterator VIRI;$/;"	t
VMSDCI	.\src\Helpers.hpp	/^typedef vector< map<string, pair<int,real_t> > >::const_iterator VMSDCI;$/;"	t
VMSDI	.\src\Helpers.hpp	/^typedef vector<map<string, pair<int,real_t> > >::iterator VMSDI;$/;"	t
VMSDRI	.\src\Helpers.hpp	/^typedef vector<map<string, pair<int,real_t> > >::reverse_iterator VMSDRI;$/;"	t
VPCFCI	.\src\Helpers.hpp	/^typedef vector<const real_t*>::const_iterator VPCFCI;$/;"	t
VPCFCRI	.\src\Helpers.hpp	/^typedef vector<const real_t*>::const_reverse_iterator VPCFCRI;$/;"	t
VPCFI	.\src\Helpers.hpp	/^typedef vector<const real_t*>::iterator VPCFI;$/;"	t
VSCI	.\src\Helpers.hpp	/^typedef vector<string>::const_iterator VSCI;$/;"	t
VSI	.\src\Helpers.hpp	/^typedef vector<string>::iterator VSI;$/;"	t
VSTCI	.\src\Helpers.hpp	/^typedef vector<size_t>::const_iterator VSTCI;$/;"	t
VUII	.\src\Helpers.hpp	/^typedef vector<unsigned int>::iterator VUII;$/;"	t
VVDCI	.\src\Helpers.hpp	/^typedef vector<vector<real_t> >::const_iterator VVDCI;$/;"	t
VVDI	.\src\Helpers.hpp	/^typedef vector<vector<real_t> >::iterator VVDI;$/;"	t
VVFI	.\src\Helpers.hpp	/^typedef vector<vector<real_t> >::iterator VVFI;$/;"	t
VVICI	.\src\Helpers.hpp	/^typedef vector<vector<int> >::const_iterator VVICI;$/;"	t
VVII	.\src\Helpers.hpp	/^typedef vector<vector<int> >::iterator VVII;$/;"	t
VVIRCI	.\src\Helpers.hpp	/^typedef vector<vector<int> >::const_reverse_iterator VVIRCI;$/;"	t
VVIRI	.\src\Helpers.hpp	/^typedef vector<vector<int> >::reverse_iterator VVIRI;$/;"	t
Val	.\src\DataExporter.hpp	/^struct Val$/;"	s
Vector	.\src\Container.hpp	/^	Vector()$/;"	f	struct:Vector
Vector	.\src\Container.hpp	/^	Vector(const View<const T>& v)$/;"	f	struct:Vector
Vector	.\src\Container.hpp	/^	Vector(const vector<T>& v):$/;"	f	struct:Vector
Vector	.\src\Container.hpp	/^	Vector(size_t n):$/;"	f	struct:Vector
Vector	.\src\Container.hpp	/^	Vector(size_t n, const T& t):$/;"	f	struct:Vector
Vector	.\src\Container.hpp	/^template<class T> struct Vector: public vector<T>$/;"	s
View	.\src\Container.hpp	/^	View(T* first = 0, T* second = 0):$/;"	f	struct:View
View	.\src\Container.hpp	/^	View(pair<T*, T*>& p):$/;"	f	struct:View
View	.\src\Container.hpp	/^template<class T> struct View: public sub_range<pair <T*, T*> >$/;"	s
WC_CONN_IT	.\src\WeightContainer.hpp	/^typedef multimap<string, tuple<string, string, int, int> >::iterator WC_CONN_IT; $/;"	t
WC_CONN_PAIR	.\src\WeightContainer.hpp	/^typedef pair<string, tuple<string, string, int, int> > WC_CONN_PAIR;$/;"	t
WeightContainer	.\src\WeightContainer.hpp	/^	WeightContainer():$/;"	f	struct:WeightContainer
WeightContainer	.\src\WeightContainer.hpp	/^struct WeightContainer: public DataExporter$/;"	s
Z	.\utils\max_jacobian.py	/^		Z = sum([exp(x) for x in col])$/;"	v
_INCLUDED_ActivationFunctions_h	.\src\ActivationFunctions.hpp	19;"	d
_INCLUDED_BiasLayer_h	.\src\BiasLayer.hpp	19;"	d
_INCLUDED_BlockLayer_h	.\src\BlockLayer.hpp	19;"	d
_INCLUDED_ClassificationLayer_h	.\src\ClassificationLayer.hpp	19;"	d
_INCLUDED_CollapseLayer_h	.\src\CollapseLayer.hpp	19;"	d
_INCLUDED_ConfigFile_h	.\src\ConfigFile.hpp	19;"	d
_INCLUDED_Connection_h	.\src\Connection.hpp	19;"	d
_INCLUDED_Container_h	.\src\Container.hpp	19;"	d
_INCLUDED_CopyConnection_h	.\src\CopyConnection.hpp	19;"	d
_INCLUDED_DataExporter_h	.\src\DataExporter.hpp	19;"	d
_INCLUDED_DataSequence_h	.\src\DataSequence.hpp	19;"	d
_INCLUDED_DatasetErrors_h	.\src\DatasetErrors.hpp	19;"	d
_INCLUDED_FullConnection_h	.\src\FullConnection.hpp	19;"	d
_INCLUDED_GatherLayer_h	.\src\GatherLayer.hpp	19;"	d
_INCLUDED_GradientCheck_h	.\src\GradientCheck.hpp	19;"	d
_INCLUDED_Helpers_h	.\src\Helpers.hpp	19;"	d
_INCLUDED_IdentityLayer_h	.\src\IdentityLayer.hpp	19;"	d
_INCLUDED_InputLayer_h	.\src\InputLayer.hpp	19;"	d
_INCLUDED_Layer_h	.\src\Layer.hpp	19;"	d
_INCLUDED_Log_h	.\src\Log.hpp	19;"	d
_INCLUDED_LstmLayer_h	.\src\LstmLayer.hpp	19;"	d
_INCLUDED_Matrix_h	.\src\Matrix.hpp	19;"	d
_INCLUDED_Mdrnn_h	.\src\Mdrnn.hpp	19;"	d
_INCLUDED_MultiArray_h	.\src\MultiArray.hpp	19;"	d
_INCLUDED_MultilayerNet_h	.\src\MultilayerNet.hpp	19;"	d
_INCLUDED_NamedObject_h	.\src\Named.hpp	19;"	d
_INCLUDED_NetcdfDataset_h	.\src\NetcdfDataset.hpp	19;"	d
_INCLUDED_NetworkOutput_h	.\src\NetworkOutput.hpp	19;"	d
_INCLUDED_NeuronLayer_h	.\src\NeuronLayer.hpp	19;"	d
_INCLUDED_Optimiser_h	.\src\Optimiser.hpp	19;"	d
_INCLUDED_Random_h	.\src\Random.hpp	19;"	d
_INCLUDED_Rprop_h	.\src\Rprop.hpp	19;"	d
_INCLUDED_SeqBuffer_h	.\src\SeqBuffer.hpp	19;"	d
_INCLUDED_SoftmaxLayer_h	.\src\SoftmaxLayer.hpp	19;"	d
_INCLUDED_SteepestDescent_h	.\src\SteepestDescent.hpp	19;"	d
_INCLUDED_StringAlignment_h	.\src\StringAlignment.hpp	19;"	d
_INCLUDED_String_h	.\src\String.hpp	19;"	d
_INCLUDED_Trainer_h	.\src\Trainer.hpp	19;"	d
_INCLUDED_TranscriptionLayer_h	.\src\TranscriptionLayer.hpp	19;"	d
_INCLUDED_WeightContainer_h	.\src\WeightContainer.hpp	19;"	d
a	.\utils\max_jacobian.py	/^	a = io.read_array(file(f.strip()), lines=[1,-1])$/;"	v
a	.\utils\max_jacobian.py	/^a = io.read_array(file(outactsfile), lines=[2,-1])$/;"	v
abs_sum	.\src\Helpers.hpp	/^template <class R> static typename range_value<R>::type abs_sum(const R& r)$/;"	f
activeDims	.\src\CollapseLayer.hpp	/^	vector<bool> activeDims;$/;"	m	struct:CollapseLayer
acts	.\src\BiasLayer.hpp	/^	View<real_t> acts;$/;"	m	struct:BiasLayer
add_bias	.\src\Mdrnn.hpp	/^	FullConnection* add_bias(Layer* layer)$/;"	f	struct:Mdrnn
add_connection	.\src\Mdrnn.hpp	/^	Connection* add_connection(Connection* conn)$/;"	f	struct:Mdrnn
add_delay	.\src\FullConnection.hpp	/^	const vector<int>* add_delay(const vector<int>& toCoords)$/;"	f	struct:FullConnection
add_error	.\src\DatasetErrors.hpp	/^	void add_error(string name, real_t error, real_t normFactor = 1)$/;"	f	struct:DatasetErrors
add_hidden_layers_to_level	.\src\Mdrnn.hpp	/^	Layer* add_hidden_layers_to_level(const string& type, int size, bool recurrent, const string& name,$/;"	f	struct:Mdrnn
add_hidden_level	.\src\Mdrnn.hpp	/^	int add_hidden_level(const string& type, int size, bool recurrent = true, const string& name = "hidden", bool addBias = true)$/;"	f	struct:Mdrnn
add_input_noise	.\src\Trainer.hpp	/^	DataSequence* add_input_noise(const DataSequence* seq)$/;"	f	struct:Trainer
add_layer	.\src\Mdrnn.hpp	/^	Layer* add_layer(Layer* layer, bool addBias = false, bool recurrent = false)$/;"	f	struct:Mdrnn
add_layer	.\src\Mdrnn.hpp	/^	Layer* add_layer(const string& type, const string& name, int size, $/;"	f	struct:Mdrnn
add_output_layer	.\src\Mdrnn.hpp	/^	Layer* add_output_layer(NetworkOutput* output, bool addBias = true)$/;"	f	struct:Mdrnn
add_seq_errors	.\src\DatasetErrors.hpp	/^	void add_seq_errors(const map<string, real_t>& seqErrors, const map<string, real_t>& seqNorms)$/;"	f	struct:DatasetErrors
allowedErrors	.\utils\plot_errors.py	/^allowedErrors = opt.errTypes.split()$/;"	v
apply_distortions	.\src\Trainer.hpp	/^	const DataSequence* apply_distortions(const DataSequence* seq)$/;"	f	struct:Trainer
arg_max	.\src\Helpers.hpp	/^template <class R> static int arg_max(const R& r)$/;"	f
array	.\src\DataExporter.hpp	/^	const SeqBuffer<T>& array;$/;"	m	struct:SeqBufferVal
arrays	.\utils\plot_variables.py	/^					arrays = [numpy.array(data[i]),numpy.array(data[i+1]),numpy.array(data[i+2])]$/;"	v
asciiStr	.\examples\arabic_offline_handwriting\arabic_offline.py	/^							asciiStr = w.encode('ascii', "backslashreplace")$/;"	v
assign	.\src\MultiArray.hpp	/^	template<class T2> void assign(const MultiArray<T2>& a)$/;"	f	struct:MultiArray
at	.\src\Container.hpp	/^	T& at(size_t i)$/;"	f	struct:View
at	.\src\Container.hpp	/^	const T& at(size_t i) const$/;"	f	struct:View
at	.\src\Helpers.hpp	/^template<class T1, class T2> static const T2& at(const map<T1, T2>& a, const T1& b)$/;"	f
at	.\src\MultiArray.hpp	/^	const View<T> at(const vector<int>& coords)$/;"	f	struct:MultiArray
at	.\src\MultiArray.hpp	/^	const View<const T> at(const vector<int>& coords) const$/;"	f	struct:MultiArray
at	.\src\SeqBuffer.hpp	/^	const View<T> at(int coord)$/;"	f	struct:SeqBuffer
at	.\src\SeqBuffer.hpp	/^	const View<const T> at(int coord) const$/;"	f	struct:SeqBuffer
axes	.\utils\plot_errors.py	/^		axes = gca()$/;"	v
axes	.\utils\plot_variables.py	/^	axes = axes()$/;"	v
b	.\utils\plot_variables.py	/^			b = data[2::3]$/;"	v
back	.\src\SeqBuffer.hpp	/^	const View<T> back(const vector<int>& dirs = empty_list_of<int>())$/;"	f	struct:SeqBuffer
backwardVariables	.\src\TranscriptionLayer.hpp	/^	SeqBuffer<Log<real_t> > backwardVariables;$/;"	m	struct:TranscriptionLayer
batchLearn	.\src\Trainer.hpp	/^	bool batchLearn;$/;"	m	struct:Trainer
begin	.\src\SeqBuffer.hpp	/^	SeqIterator begin(const vector<int>& dirs = empty_list_of<int>()) const$/;"	f	struct:SeqBuffer
begin	.\src\SeqBuffer.hpp	/^	void begin()$/;"	f	struct:CoordIterator
begins	.\src\String.hpp	/^static bool begins(const string& str, const char* search)$/;"	f
begins	.\src\String.hpp	/^static bool begins(const string& str, const string& search)$/;"	f
bestEpochs	.\utils\plot_errors.py	/^bestEpochs = dict()$/;"	v
best_label_seq	.\src\TranscriptionLayer.hpp	/^	vector<int>& best_label_seq() const$/;"	f	struct:TranscriptionLayer
bias	.\src\Mdrnn.hpp	/^	BiasLayer bias;$/;"	m	struct:Mdrnn
bidirectional	.\src\Mdrnn.hpp	/^	vector<bool> bidirectional;		\/\/ 雙向 (numDims)$/;"	m	struct:Mdrnn
bigIm	.\examples\farsi_offline_handwriting\farsi_chars.py	/^		bigIm = Image.new(im.mode, (w,h), 255)$/;"	v
bits_to_nats	.\src\Helpers.hpp	/^static real_t bits_to_nats(real_t bits)$/;"	f
blank	.\src\TranscriptionLayer.hpp	/^	int blank;$/;"	m	struct:TranscriptionLayer
blockArea	.\utils\plot_variables.py	/^				blockArea = numpy.product(blockDims)$/;"	v
blockDims	.\utils\plot_variables.py	/^			blockDims = numpy.array(opt.blockDims.split(',')).astype(int)$/;"	v
blockIndex	.\utils\plot_variables.py	/^								blockIndex = 0$/;"	v
blockIterator	.\src\BlockLayer.hpp	/^	CVI blockIterator;			\/\/ CoordIterator<const vector<size_t> > 走訪一個 block 會用到的區域範圍$/;"	m	struct:BlockLayer
blockOffset	.\src\BlockLayer.hpp	/^	vector<int> blockOffset;$/;"	m	struct:BlockLayer
blockShape	.\src\BlockLayer.hpp	/^	vector<size_t> blockShape;	\/\/ Shape 3,4$/;"	m	struct:BlockLayer
bound	.\src\Helpers.hpp	/^template <class T> static T bound (const T& v, const T& minVal, const T& maxVal)$/;"	f
bound_range	.\src\Helpers.hpp	/^template <class R> static void bound_range (R& r, const typename boost::range_value<R>::type& minVal, const typename boost::range_value<R>::type& maxVal)$/;"	f
breakOnError	.\src\GradientCheck.hpp	/^	bool breakOnError;$/;"	m	struct:GradientCheck
build	.\src\Layer.hpp	/^	virtual void build()$/;"	f	struct:Layer
build	.\src\Mdrnn.hpp	/^	virtual void build()$/;"	f	struct:Mdrnn
build	.\src\Rprop.hpp	/^	void build()$/;"	f	struct:Rprop
build	.\src\SteepestDescent.hpp	/^	void build()$/;"	f	struct:SteepestDescent
build	.\src\WeightContainer.hpp	/^	void build()$/;"	f	struct:WeightContainer
c	.\utils\max_jacobian.py	/^		c = c[:-1]$/;"	v
c	.\utils\max_jacobian.py	/^		c = list(v[:,t])$/;"	v
c	.\utils\max_jacobian.py	/^	c = list(a[:,t])$/;"	v
calculate_all_errors	.\src\Trainer.hpp	/^	void calculate_all_errors()$/;"	f	struct:Trainer
calculate_compression_errors	.\src\Trainer.hpp	/^	void calculate_compression_errors(DatasetErrors& errors)$/;"	f	struct:Trainer
calculate_errors	.\src\ClassificationLayer.hpp	/^	real_t calculate_errors(const DataSequence& seq)$/;"	f	struct:ClassificationLayer
calculate_errors	.\src\Mdrnn.hpp	/^	virtual real_t calculate_errors(const DataSequence& seq)$/;"	f	struct:Mdrnn
calculate_errors	.\src\NetworkOutput.hpp	/^	virtual real_t calculate_errors(const DataSequence& seq){return realMax;}$/;"	f	struct:NetworkOutput
calculate_errors	.\src\Trainer.hpp	/^	DatasetErrors& calculate_errors(DataList& data, DatasetErrors& errors)$/;"	f	struct:Trainer
calculate_errors	.\src\TranscriptionLayer.hpp	/^	real_t calculate_errors(const DataSequence& seq)$/;"	f	struct:TranscriptionLayer
calculate_output_errors	.\src\Mdrnn.hpp	/^	virtual real_t calculate_output_errors(const DataSequence& seq)$/;"	f	struct:Mdrnn
cellErrors	.\src\LstmLayer.hpp	/^	SeqBuffer<real_t> cellErrors;$/;"	m	struct:LstmLayer
cellsPerBlock	.\src\LstmLayer.hpp	/^	size_t cellsPerBlock;$/;"	m	struct:LstmLayer
check	.\src\Helpers.hpp	161;"	d
check_connection	.\src\GradientCheck.hpp	/^	bool check_connection(const string& name, int begin, int end)$/;"	f	struct:GradientCheck
check_for_best	.\src\Trainer.hpp	/^	bool check_for_best(const DatasetErrors& currentErrors, map<string, pair<int, DatasetErrors> >& bestErrors, int epoch)$/;"	f	struct:Trainer
check_layer	.\src\GradientCheck.hpp	/^	bool check_layer(const string& name)$/;"	f	struct:GradientCheck
checked	.\src\GradientCheck.hpp	/^	map<string, bool> checked;$/;"	m	struct:GradientCheck
class_prob	.\src\ClassificationLayer.hpp	/^	real_t class_prob(int pt, int index) const$/;"	f	struct:BinaryClassificationLayer
class_prob	.\src\ClassificationLayer.hpp	/^	real_t class_prob(int pt, int index) const$/;"	f	struct:MulticlassClassificationLayer
clear	.\src\DatasetErrors.hpp	/^	void clear()$/;"	f	struct:DatasetErrors
clear_seq	.\src\NetcdfDataset.hpp	/^	void clear_seq()$/;"	f	struct:DataList
col	.\utils\max_jacobian.py	/^		col = a[:,input]$/;"	v
col	.\utils\max_jacobian.py	/^		col = v[:,t]$/;"	v
collapse_layer	.\src\Mdrnn.hpp	/^	Layer* collapse_layer(Layer* src, Layer* dest, const vector<bool>& activeDims = empty_list_of<bool>())$/;"	f	struct:Mdrnn
colors	.\utils\plot_variables.py	/^	colors = []$/;"	v
colourDepth	.\utils\plot_variables.py	/^							colourDepth = 1$/;"	v
colourDepth	.\utils\plot_variables.py	/^							colourDepth = 3$/;"	v
config	.\src\Trainer.hpp	/^	ConfigFile& config;$/;"	m	struct:Trainer
config	.\utils\dump_weight_matrices.py	/^config = args[0]$/;"	v
config	.\utils\dump_weights.py	/^config = args[0]$/;"	v
confusionMatrix	.\src\ClassificationLayer.hpp	/^	vector<vector<int> > confusionMatrix;$/;"	m	struct:ClassificationLayer
confusionMatrix	.\src\TranscriptionLayer.hpp	/^	bool confusionMatrix;$/;"	m	struct:TranscriptionLayer
connName	.\utils\dump_weight_matrices.py	/^	connName = connStr.split('_')[1:]$/;"	v
connName	.\utils\dump_weights.py	/^	connName = connStr.split('_')[1:]$/;"	v
connName	.\utils\plot_weights.py	/^	connName = connStr.split('_')[1:]$/;"	v
connNameStr	.\utils\dump_weights.py	/^	connNameStr = '_'.join(connName)$/;"	v
connStr	.\utils\dump_weight_matrices.py	/^	connStr = words[0]$/;"	v
connStr	.\utils\dump_weights.py	/^	connStr = words[0]$/;"	v
connStr	.\utils\plot_weights.py	/^	connStr = words[0]$/;"	v
connect_from_hidden_level	.\src\Mdrnn.hpp	/^	void connect_from_hidden_level(int levelNum, Layer* to)$/;"	f	struct:Mdrnn
connect_layers	.\src\Mdrnn.hpp	/^	FullConnection* connect_layers(Layer* from, Layer* to, const vector<int>& delay = empty_list_of<int>())$/;"	f	struct:Mdrnn
connect_to_hidden_level	.\src\Mdrnn.hpp	/^	void connect_to_hidden_level(Layer* from, int levelNum)$/;"	f	struct:Mdrnn
connections	.\src\Mdrnn.hpp	/^	multimap<const Layer*, Connection*> connections;$/;"	m	struct:Mdrnn
connections	.\src\WeightContainer.hpp	/^	multimap<string, tuple<string, string, int, int> > connections;$/;"	m	struct:WeightContainer
connections	.\utils\dump_weight_matrices.py	/^	connections = opt.connections.split(',')$/;"	v
connections	.\utils\dump_weight_matrices.py	/^	connections = opt.connections.split()$/;"	v
connections	.\utils\dump_weights.py	/^	connections = opt.connections.split()$/;"	v
connections	.\utils\dump_weights.py	/^connections = None$/;"	v
connections	.\utils\plot_weights.py	/^	connections = opt.connections.split()$/;"	v
connections	.\utils\plot_weights.py	/^connections = None$/;"	v
conns	.\src\GradientCheck.hpp	/^	multimap<string, tuple<string, string, int, int> >& conns;$/;"	m	struct:GradientCheck
contains	.\src\ConfigFile.hpp	/^	bool contains(const string& name) const$/;"	f	struct:ConfigFile
convertToPrimaries	.\examples\arabic_offline_handwriting\arabic_offline.py	/^def convertToPrimaries (labelString):$/;"	f
copy	.\src\Helpers.hpp	/^template<class R1, class R2> static void copy(const R1& source, R2& dest)$/;"	f
copy_connections	.\src\Mdrnn.hpp	/^	int copy_connections(Layer* src, Layer* dest, bool mirror = false)$/;"	f	struct:Mdrnn
copy_inputs	.\src\InputLayer.hpp	/^	template<typename T> void copy_inputs(const SeqBuffer<T>& inputs)$/;"	f	struct:InputLayer
count	.\src\Helpers.hpp	/^template<class R> static size_t count(const R& r, const typename boost::range_value<R>::type& v)$/;"	f
count_adjacent	.\src\Helpers.hpp	/^template <class R> static size_t count_adjacent(const R& r)$/;"	f
createNcDim	.\utils\netcdf_helpers.py	/^def createNcDim(ncfile,name,d):$/;"	f
criteria	.\src\Mdrnn.hpp	/^	Vector<string> criteria;$/;"	m	struct:Mdrnn
criteria	.\src\NetworkOutput.hpp	/^	Vector<string> criteria;$/;"	m	struct:NetworkOutput
criteria	.\src\Trainer.hpp	/^    Vector<string>& criteria;$/;"	m	struct:Trainer
d	.\utils\plot_variables.py	/^			d = int(d)$/;"	v
dEdYTerms	.\src\TranscriptionLayer.hpp	/^	vector<Log<real_t> > dEdYTerms;$/;"	m	struct:TranscriptionLayer
data	.\examples\arabic_offline_handwriting\arabic_offline.py	/^					data = words[1].split(';')$/;"	v
data	.\src\MultiArray.hpp	/^	Vector<T> data;$/;"	m	struct:MultiArray
data	.\utils\min_max.py	/^		data = l.split()$/;"	v
data	.\utils\plot_variables.py	/^				data = newData$/;"	v
data	.\utils\plot_variables.py	/^			data = newData$/;"	v
data	.\utils\plot_variables.py	/^			data = r_[r,g,b]$/;"	v
data	.\utils\plot_variables.py	/^	data = array(newdata)$/;"	v
data	.\utils\plot_variables.py	/^	data = data[:5]$/;"	v
data	.\utils\plot_variables.py	/^	data = data[opt.min:]$/;"	v
data	.\utils\plot_variables.py	/^	data = data[opt.min:opt.max]$/;"	v
data	.\utils\plot_variables.py	/^	data = newdata$/;"	v
data	.\utils\plot_variables.py	/^data = file(infilename)$/;"	v
data	.\utils\plot_variables.py	/^data = loadtxt(infilename, skiprows = numRowsToSkip)$/;"	v
dataExporters	.\src\DataExporter.hpp	/^	map<string, DataExporter*> dataExporters;$/;"	m	struct:DataExportHandler
dataFraction	.\src\NetcdfDataset.hpp	/^	real_t dataFraction;$/;"	m	struct:DataList
dataFraction	.\src\Trainer.hpp	/^	real_t dataFraction;$/;"	m	struct:Trainer
dataset	.\src\NetcdfDataset.hpp	/^	NetcdfDataset* dataset;$/;"	m	struct:DataList
datasetIndex	.\src\NetcdfDataset.hpp	/^	int datasetIndex;$/;"	m	struct:DataList
delPenalty	.\src\StringAlignment.hpp	/^	int delPenalty;$/;"	m	struct:StringAlignment
delay	.\src\FullConnection.hpp	/^	vector<int> delay;$/;"	m	struct:FullConnection
delayedCoords	.\src\FullConnection.hpp	/^	vector<int> delayedCoords;$/;"	m	struct:FullConnection
delayedCoords	.\src\LstmLayer.hpp	/^	vector<int> delayedCoords;$/;"	m	struct:LstmLayer
delete_dataset	.\src\NetcdfDataset.hpp	/^	void delete_dataset()$/;"	f	struct:DataList
delete_map	.\src\Helpers.hpp	/^template<class R> void delete_map(R& r)$/;"	f
delete_range	.\src\Helpers.hpp	/^template<class R> void delete_range(R& r)$/;"	f
delete_val	.\src\DataExporter.hpp	/^	void delete_val(map<string, Val*>& vals, const string& name)$/;"	f	struct:DataExporter
deletions	.\src\StringAlignment.hpp	/^	int deletions;$/;"	m	struct:StringAlignment
delimMatch	.\utils\dump_weights.py	/^	delimMatch = re.search('(labelDelimiter) (\\S+)', text)$/;"	v
delsMap	.\src\StringAlignment.hpp	/^	map<typename boost::range_value<R1>::type, int> delsMap;$/;"	m	struct:StringAlignment
deltas	.\src\Rprop.hpp	/^	vector<real_t> deltas;$/;"	m	struct:Rprop
deltas	.\src\SteepestDescent.hpp	/^	vector<real_t> deltas;$/;"	m	struct:SteepestDescent
depth	.\src\SeqBuffer.hpp	/^	size_t depth;$/;"	m	struct:SeqBuffer
deriv	.\src\ActivationFunctions.hpp	/^	static real_t deriv(real_t y)$/;"	f	struct:Identity
deriv	.\src\ActivationFunctions.hpp	/^	static real_t deriv(real_t y)$/;"	f	struct:Logistic
deriv	.\src\ActivationFunctions.hpp	/^	static real_t deriv(real_t y)$/;"	f	struct:Max2min0
deriv	.\src\ActivationFunctions.hpp	/^	static real_t deriv(real_t y)$/;"	f	struct:Maxmin1
deriv	.\src\ActivationFunctions.hpp	/^	static real_t deriv(real_t y)$/;"	f	struct:Maxmin2
deriv	.\src\ActivationFunctions.hpp	/^	static real_t deriv(real_t y)$/;"	f	struct:Softsign
deriv	.\src\ActivationFunctions.hpp	/^	static real_t deriv(real_t y)$/;"	f	struct:Tanh
derivatives	.\src\WeightContainer.hpp	/^	Vector<real_t> derivatives;$/;"	m	struct:WeightContainer
derivs	.\src\FullConnection.hpp	/^	const View<real_t> derivs()$/;"	f	struct:FullConnection
derivs	.\src\GradientCheck.hpp	/^	vector<real_t>& derivs;$/;"	m	struct:GradientCheck
derivs	.\src\Optimiser.hpp	/^	vector<real_t>& derivs;$/;"	m	struct:Optimiser
derivs	.\src\Trainer.hpp	/^	Vector<real_t>& derivs;$/;"	m	struct:Trainer
difference	.\src\Helpers.hpp	/^template <class T1, class T2> static size_t difference(const pair<T1,T2>& p)$/;"	f
differentiate	.\src\Trainer.hpp	/^	real_t differentiate(const DataSequence* seq)$/;"	f	struct:Trainer
dimensions	.\utils\plot_variables.py	/^dimensions = []$/;"	v
dims	.\examples\arabic_offline_handwriting\arabic_offline.py	/^		dims = (image.size[1], image.size[0])$/;"	v
dims	.\examples\farsi_offline_handwriting\farsi_chars.py	/^				dims = (im.size[1], im.size[0])$/;"	v
dims	.\examples\farsi_offline_handwriting\farsi_chars.py	/^				dims = (max(padDims[0], im.size[1]), max(padDims[1], im.size[0]))$/;"	v
directions	.\src\Layer.hpp	/^	vector<int> directions;$/;"	m	struct:Layer
directions	.\src\SeqBuffer.hpp	/^	vector<int> directions;	\/\/ 方向		 : 走的方向$/;"	m	struct:CoordIterator
disjoint	.\src\Helpers.hpp	/^template<class T> static bool disjoint(const set<T>& s1, const set<T>& s2)$/;"	f
display	.\src\DataExporter.cpp	/^void DataExportHandler::display(const string& path) const$/;"	f	class:DataExportHandler
display	.\src\DataExporter.hpp	/^	template <typename T> void display(const SeqBuffer<T>& array, const string& name, const vector<string>* labels = 0)$/;"	f	struct:DataExporter
displayVals	.\src\DataExporter.hpp	/^	map<string, Val*> displayVals;$/;"	m	struct:DataExporter
distance	.\src\StringAlignment.hpp	/^	int distance;	$/;"	m	struct:StringAlignment
distortedWeights	.\src\Trainer.hpp	/^	vector<real_t> distortedWeights;$/;"	m	struct:Trainer
dot	.\src\Matrix.hpp	/^static void dot(const real_t *inBegin, const real_t *inEnd, const real_t *M, real_t *out, real_t *outEnd)$/;"	f
dot	.\src\Matrix.hpp	/^template<class R> static void dot(const R& a, const real_t *M, const R& b)$/;"	f
dot_transpose	.\src\Matrix.hpp	/^static void dot_transpose(const real_t *in, const real_t *inEnd, const real_t *M, real_t *outBegin, real_t *outEnd)$/;"	f
dot_transpose	.\src\Matrix.hpp	/^template<class R> static void dot_transpose(const R& a, const real_t *M, const R& b)$/;"	f
dot_transpose_m_squared	.\src\Matrix.hpp	/^static void dot_transpose_m_squared(const real_t *in, const real_t *inEnd, const real_t *M, real_t *outBegin, real_t *outEnd)$/;"	f
dot_transpose_m_squared	.\src\Matrix.hpp	/^template<class R> static void dot_transpose_m_squared(const R& a, const real_t *M, const R& b)$/;"	f
elt	.\src\Matrix.hpp	/^static real_t& elt(View<real_t> M, int x, int y, int width)$/;"	f
empty	.\src\MultiArray.hpp	/^	virtual bool empty() const$/;"	f	struct:MultiArray
empty_list_of	.\src\Helpers.hpp	/^template<class T> static assign_detail::generic_list<T> empty_list_of()$/;"	f
end	.\src\SeqBuffer.hpp	/^	bool end;$/;"	m	struct:CoordIterator
end	.\utils\dump_weights.py	/^				end = start + fromLayerSize$/;"	v
ends	.\src\String.hpp	/^static bool ends(const string& str, const char* search)$/;"	f
ends	.\src\String.hpp	/^static bool ends(const string& str, const string& search)$/;"	f
enumerate	.\src\Helpers.hpp	/^enumerate(R& r)$/;"	f
epoch	.\src\Trainer.hpp	/^	int epoch;$/;"	m	struct:Trainer
epochNum	.\utils\plot_errors.py	/^		epochNum = int(l.split()[1])$/;"	v
epochNum	.\utils\plot_errors.py	/^epochNum = -1$/;"	v
equal	.\src\Helpers.hpp	/^template<class R1, class R2> static bool equal(const R1& source, R2& dest)$/;"	f
err	.\src\NetcdfDataset.hpp	/^	NcError err;$/;"	m	struct:NetcdfDataset
errVal	.\utils\plot_errors.py	/^				errVal = float(words[1].strip('%'))$/;"	v
errWord	.\utils\plot_errors.py	/^			errWord = words[0]$/;"	v
errorMap	.\src\NetworkOutput.hpp	/^	map <string, real_t> errorMap;$/;"	m	struct:NetworkOutput
errorType	.\utils\plot_errors.py	/^			errorType = ""$/;"	v
errorType	.\utils\plot_errors.py	/^			errorType = "test"$/;"	v
errorType	.\utils\plot_errors.py	/^			errorType = "train"$/;"	v
errorType	.\utils\plot_errors.py	/^			errorType = "validation"$/;"	v
errorType	.\utils\plot_errors.py	/^errorType = ""$/;"	v
errors	.\src\BiasLayer.hpp	/^	View<real_t> errors;$/;"	m	struct:BiasLayer
errors	.\src\DatasetErrors.hpp	/^	map<string, real_t> errors;$/;"	m	struct:DatasetErrors
errors	.\src\Mdrnn.hpp	/^	map<string, real_t> errors;$/;"	m	struct:Mdrnn
errors	.\utils\plot_errors.py	/^errors = dict()$/;"	v
etaChange	.\src\Rprop.hpp	/^	real_t etaChange;$/;"	m	struct:Rprop
etaMin	.\src\Rprop.hpp	/^	real_t etaMin;$/;"	m	struct:Rprop
etaPlus	.\src\Rprop.hpp	/^	real_t etaPlus;$/;"	m	struct:Rprop
euclidean_squared	.\src\Helpers.hpp	/^template <class R1, class R2> typename boost::range_value<R1>::type euclidean_squared(const R1& r1, const R2& r2)$/;"	f
evaluate	.\src\Trainer.hpp	/^	real_t evaluate(const DataSequence* seq)$/;"	f	struct:Trainer
exp	.\src\Log.hpp	/^	T exp()$/;"	f	class:Log
expLimit	.\src\Log.hpp	/^	static const T expLimit;$/;"	m	class:Log
expLimit	.\src\Log.hpp	/^template <class T> const T Log<T>::expLimit = std::log(expMax);$/;"	m	class:Log
expMax	.\src\Log.hpp	/^	static const T expMax;$/;"	m	class:Log
expMax	.\src\Log.hpp	/^template <class T> const T Log<T>::expMax = numeric_limits<T>::max();$/;"	m	class:Log
expMin	.\src\Log.hpp	/^	static const T expMin;$/;"	m	class:Log
expMin	.\src\Log.hpp	/^template <class T> const T Log<T>::expMin = numeric_limits<T>::min();$/;"	m	class:Log
expVal	.\src\Log.hpp	/^	T expVal;$/;"	m	class:Log
extend	.\src\Container.hpp	/^	template<class R> Set<T>& extend(const R& r)$/;"	f	struct:Set
extend	.\src\Container.hpp	/^	template<class R> Vector<T>& extend(const R& r)$/;"	f	struct:Vector
f	.\utils\min_max.py	/^			f = float(d)$/;"	v
feed_back	.\src\BlockLayer.hpp	/^	void feed_back(const vector<int>& outCoords)$/;"	f	struct:BlockLayer
feed_back	.\src\CollapseLayer.hpp	/^	void feed_back(const vector<int>& coords)$/;"	f	struct:CollapseLayer
feed_back	.\src\Connection.hpp	/^	virtual void feed_back(const vector<int>& coords){}$/;"	f	struct:Connection
feed_back	.\src\CopyConnection.hpp	/^	void feed_back(const vector<int>& coords)$/;"	f	struct:CopyConnection
feed_back	.\src\FullConnection.hpp	/^	void feed_back(const vector<int>& toCoords)$/;"	f	struct:FullConnection
feed_back	.\src\GatherLayer.hpp	/^	void feed_back(const vector<int>& outCoords)$/;"	f	struct:GatherLayer
feed_back	.\src\IdentityLayer.hpp	/^	void feed_back(const vector<int>& coords)$/;"	f	struct:IdentityLayer
feed_back	.\src\Layer.hpp	/^	virtual void feed_back(const vector<int>& coords){}$/;"	f	struct:Layer
feed_back	.\src\LstmLayer.hpp	/^	void feed_back(const vector<int>& coords)$/;"	f	struct:LstmLayer
feed_back	.\src\Mdrnn.hpp	/^	virtual void feed_back()$/;"	f	struct:Mdrnn
feed_back	.\src\NeuronLayer.hpp	/^	void feed_back(const vector<int>& coords)$/;"	f	struct:NeuronLayer
feed_back	.\src\SoftmaxLayer.hpp	/^	void feed_back(const vector<int>& coords)$/;"	f	struct:SoftmaxLayer
feed_back_layer	.\src\Mdrnn.hpp	/^	void feed_back_layer(Layer* layer)$/;"	f	struct:Mdrnn
feed_forward	.\src\BlockLayer.hpp	/^	void feed_forward(const vector<int>& outCoords)$/;"	f	struct:BlockLayer
feed_forward	.\src\CollapseLayer.hpp	/^	void feed_forward(const vector<int>& coords)$/;"	f	struct:CollapseLayer
feed_forward	.\src\Connection.hpp	/^	virtual void feed_forward(const vector<int>& coords){}$/;"	f	struct:Connection
feed_forward	.\src\CopyConnection.hpp	/^	void feed_forward(const vector<int>& coords)$/;"	f	struct:CopyConnection
feed_forward	.\src\FullConnection.hpp	/^	void feed_forward(const vector<int>& toCoords)$/;"	f	struct:FullConnection
feed_forward	.\src\GatherLayer.hpp	/^	void feed_forward(const vector<int>& outCoords)$/;"	f	struct:GatherLayer
feed_forward	.\src\IdentityLayer.hpp	/^	void feed_forward(const vector<int>& coords)$/;"	f	struct:IdentityLayer
feed_forward	.\src\Layer.hpp	/^	virtual void feed_forward(const vector<int>& coords){}$/;"	f	struct:Layer
feed_forward	.\src\LstmLayer.hpp	/^	void feed_forward(const vector<int>& coords)$/;"	f	struct:LstmLayer
feed_forward	.\src\Mdrnn.hpp	/^	virtual void feed_forward(const DataSequence& seq)$/;"	f	struct:Mdrnn
feed_forward	.\src\NeuronLayer.hpp	/^	void feed_forward(const vector<int>& coords)$/;"	f	struct:NeuronLayer
feed_forward	.\src\SoftmaxLayer.hpp	/^	void feed_forward(const vector<int>& coords)$/;"	f	struct:SoftmaxLayer
feed_forward_layer	.\src\Mdrnn.hpp	/^	void feed_forward_layer(Layer* layer)$/;"	f	struct:Mdrnn
fig	.\utils\plot_variables.py	/^			fig = figure()$/;"	v
fig	.\utils\plot_variables.py	/^		fig = figure()$/;"	v
fig	.\utils\plot_variables.py	/^	fig = figure()$/;"	v
file	.\examples\arabic_offline_handwriting\arabic_offline.py	/^file = netcdf_helpers.NetCDFFile(outputFilename, 'w')$/;"	v
file	.\examples\arabic_online_handwriting\arabic_online.py	/^file = netcdf_helpers.NetCDFFile(ncFilename, 'w')$/;"	v
file	.\examples\farsi_offline_handwriting\farsi_chars.py	/^file = netcdf_helpers.NetCDFFile(ncFilename, 'w')$/;"	v
filePattern	.\utils\min_max.py	/^filePattern = args[0]$/;"	v
filename	.\src\ConfigFile.hpp	/^	string filename;$/;"	m	struct:ConfigFile
filename	.\src\NetcdfDataset.hpp	/^	string filename;$/;"	m	struct:NetcdfDataset
filename	.\utils\plot_errors.py	/^filename = args[0]$/;"	v
filename	.\utils\rescale_netcdf_binary_inputs.py	/^filename = args[0]$/;"	v
filenames	.\examples\arabic_offline_handwriting\arabic_offline.py	/^filenames = file(inputFilename).readlines()$/;"	v
filenames	.\examples\farsi_offline_handwriting\farsi_chars.py	/^filenames = []$/;"	v
filenames	.\src\NetcdfDataset.hpp	/^	vector<string> filenames;$/;"	m	struct:DataList
filenames	.\utils\min_max.py	/^filenames = glob.glob(filePattern)$/;"	v
fill	.\src\Helpers.hpp	/^template<class R> static void fill (R& r, const typename boost::range_value<R>::type& v)$/;"	f
fill_data	.\src\MultiArray.hpp	/^	void fill_data(const T& fillVal)$/;"	f	struct:MultiArray
find	.\src\Helpers.hpp	/^template <class R, class T> static typename range_iterator<R>::type find(R& r, const T& t)$/;"	f
find_nc_variable	.\src\NetcdfDataset.hpp	/^bool find_nc_variable(const NcFile& ncf, const string& name)$/;"	f
find_variable	.\src\NetcdfDataset.hpp	/^	bool find_variable(const string& name)$/;"	f	struct:NetcdfDataset
flip	.\src\Helpers.hpp	/^template <class R> static vector<typename boost::range_value<R>::type>& flip(const R& r)$/;"	f
flood	.\src\Helpers.hpp	/^template<class R> static void flood(R& r, size_t size, const typename boost::range_value<R>::type& v = 0)$/;"	f
fn	.\src\ActivationFunctions.hpp	/^	static real_t fn(real_t x)$/;"	f	struct:Identity
fn	.\src\ActivationFunctions.hpp	/^	static real_t fn(real_t x)$/;"	f	struct:Logistic
fn	.\src\ActivationFunctions.hpp	/^	static real_t fn(real_t x)$/;"	f	struct:Max2min0
fn	.\src\ActivationFunctions.hpp	/^	static real_t fn(real_t x)$/;"	f	struct:Maxmin1
fn	.\src\ActivationFunctions.hpp	/^	static real_t fn(real_t x)$/;"	f	struct:Maxmin2
fn	.\src\ActivationFunctions.hpp	/^	static real_t fn(real_t x)$/;"	f	struct:Softsign
fn	.\src\ActivationFunctions.hpp	/^	static real_t fn(real_t x)$/;"	f	struct:Tanh
fname	.\examples\arabic_offline_handwriting\arabic_offline.py	/^	fname = f.strip()$/;"	v
fname	.\examples\farsi_offline_handwriting\farsi_chars.py	/^	fname = line.strip()$/;"	v
for_each	.\src\Helpers.hpp	/^template <class R, class UnaryFunction> static UnaryFunction for_each(R& r, UnaryFunction f)$/;"	f
forgetGateActs	.\src\LstmLayer.hpp	/^	SeqBuffer<real_t> forgetGateActs;$/;"	m	struct:LstmLayer
forwardVariables	.\src\TranscriptionLayer.hpp	/^	SeqBuffer<Log<real_t> > forwardVariables;$/;"	m	struct:TranscriptionLayer
from	.\src\Connection.hpp	/^	Layer* from;$/;"	m	struct:Connection
fromLayer	.\utils\dump_weight_matrices.py	/^		fromLayer = '_'.join(connName[:min(2, toIndex)])$/;"	v
fromLayer	.\utils\dump_weights.py	/^		fromLayer = '_'.join(connName[:min(2, toIndex)])$/;"	v
fromLayerSize	.\utils\dump_weight_matrices.py	/^			fromLayerSize = layerOutputSizes[fromLayer]$/;"	v
fromLayerSize	.\utils\dump_weights.py	/^			fromLayerSize = layerSizes[fromLayer]$/;"	v
front	.\src\SeqBuffer.hpp	/^	const View<T> front(const vector<int>& dirs = empty_list_of<int>())$/;"	f	struct:SeqBuffer
func_extract_an_archive	.\build-aux\ltmain.sh	/^func_extract_an_archive ()$/;"	f
func_extract_archives	.\build-aux\ltmain.sh	/^func_extract_archives ()$/;"	f
func_infer_tag	.\build-aux\ltmain.sh	/^func_infer_tag ()$/;"	f
func_mktempdir	.\build-aux\ltmain.sh	/^func_mktempdir ()$/;"	f
func_win32_libid	.\build-aux\ltmain.sh	/^func_win32_libid ()$/;"	f
g	.\utils\plot_variables.py	/^			g = data[1::3]$/;"	v
gatesPerBlock	.\src\LstmLayer.hpp	/^	size_t gatesPerBlock;$/;"	m	struct:LstmLayer
gather_level	.\src\Mdrnn.hpp	/^	Layer* gather_level(const string& name, int levelNum)$/;"	f	struct:Mdrnn
gauss_pdf	.\src\Helpers.hpp	/^template<class T1, class T2, class T3, class T4> static T1 gauss_pdf(const T2& x, const T3& mean, const T4& stdDev)$/;"	f
get	.\src\ConfigFile.hpp	/^	template<class T> T get(const string& name)$/;"	f	struct:ConfigFile
get	.\src\ConfigFile.hpp	/^	template<class T> T get(const string& name, const T& defaultVal)$/;"	f	struct:ConfigFile
get	.\src\MultiArray.hpp	/^	T& get(const vector<int>& coords)$/;"	f	struct:MultiArray
get	.\src\MultiArray.hpp	/^	const T& get(const vector<int>& coords) const$/;"	f	struct:MultiArray
get_array	.\src\ConfigFile.hpp	/^	template<class T> Vector<Vector<T> > get_array(const string& name, const char delim1 = ';', const char delim2 = ',')$/;"	f	struct:ConfigFile
get_array	.\src\ConfigFile.hpp	/^	template<class T> Vector<Vector<T> > get_array(const string& name, const string& defaultStr, size_t length, const char delim1 = ';', const char delim2 = ',')$/;"	f	struct:ConfigFile
get_derivs	.\src\WeightContainer.hpp	/^	View<real_t> get_derivs(pair<int, int> range)$/;"	f	struct:WeightContainer
get_input_layer	.\src\Mdrnn.hpp	/^	Layer* get_input_layer() const$/;"	f	struct:Mdrnn
get_list	.\src\ConfigFile.hpp	/^	template<class T> Vector<T> get_list(const string& name, const T& defaultVal, size_t length, const char delim = ',')$/;"	f	struct:ConfigFile
get_list	.\src\ConfigFile.hpp	/^	template<class T> Vector<T> get_list(const string& name, const char delim = ',')$/;"	f	struct:ConfigFile
get_nc_array_step	.\src\NetcdfDataset.hpp	/^template<class T> static vector<T> get_nc_array_step(const NcFile& ncf, const string& name, int offset = 0, bool required = true)$/;"	f
get_nc_string	.\src\NetcdfDataset.hpp	/^static string get_nc_string(const NcFile& ncf, const string& name, int offset = 0, bool required = true)$/;"	f
get_offset	.\src\NetcdfDataset.hpp	/^	pair<int,int> get_offset(int seqNum) const$/;"	f	struct:NetcdfDataset
get_out_coords	.\src\CollapseLayer.hpp	/^	vector<int> get_out_coords(const vector<int>& inCoords)$/;"	f	struct:CollapseLayer
get_size	.\src\GatherLayer.hpp	/^	int get_size(vector<Layer*>& srcs)$/;"	f	struct:GatherLayer
get_string	.\src\NetcdfDataset.hpp	/^	string get_string(const string& name, int offset = 0, bool required = true)$/;"	f	struct:NetcdfDataset
get_weights	.\src\WeightContainer.hpp	/^	View<real_t> get_weights(pair<int, int> range)$/;"	f	struct:WeightContainer
glob	.\utils\min_max.py	/^import glob$/;"	i
gridDims	.\utils\plot_variables.py	/^			gridDims = dimensions[-2:]$/;"	v
gridDims	.\utils\plot_variables.py	/^	gridDims = [int(i) for i in opt.gridDims.split()]$/;"	v
gridDims	.\utils\plot_variables.py	/^gridDims = None$/;"	v
grow	.\src\Container.hpp	/^	Vector<T>& grow(size_t length)$/;"	f	struct:Vector
h	.\examples\farsi_offline_handwriting\farsi_chars.py	/^		h = max(padDims[1], im.size[1])$/;"	v
header	.\src\NetcdfDataset.hpp	/^	DataHeader header;	$/;"	m	struct:NetcdfDataset
headers	.\src\NetcdfDataset.hpp	/^	vector<DataHeader> headers;$/;"	m	struct:DataList
height	.\utils\plot_variables.py	/^						height = len(data[i]) \/ gridDims[0]$/;"	v
hiddenLayers	.\src\Mdrnn.hpp	/^	vector<Layer*> hiddenLayers;	\/\/ 所有的 hiddenLayers 都會在這裡面$/;"	m	struct:Mdrnn
hiddenLevels	.\src\Mdrnn.hpp	/^	vector<vector<Layer*> > hiddenLevels;$/;"	m	struct:Mdrnn
hiddenMatch	.\utils\dump_weights.py	/^hiddenMatch = re.search('(hiddenSize) (\\S+)', text)$/;"	v
hiddenSizes	.\utils\dump_weight_matrices.py	/^hiddenSizes = re.search('(hiddenSize) (\\S+)', text).group(2).split(',')$/;"	v
i	.\utils\max_jacobian.py	/^		i = c.index(max(c))$/;"	v
i	.\utils\plot_variables.py	/^			i = int(v)$/;"	v
i	.\utils\plot_variables.py	/^			i = labels.index(v)$/;"	v
ignoreList	.\utils\plot_variables.py	/^ignoreList = opt.ignore.replace(',', ' ').split()$/;"	v
im	.\examples\farsi_offline_handwriting\farsi_chars.py	/^			im = Image.open(fname)$/;"	v
im	.\examples\farsi_offline_handwriting\farsi_chars.py	/^		im = bigIm$/;"	v
im	.\examples\farsi_offline_handwriting\farsi_chars.py	/^	im = Image.open(tag).transpose(Image.FLIP_TOP_BOTTOM).transpose(Image.ROTATE_270).convert('L')$/;"	v
image	.\examples\arabic_offline_handwriting\arabic_offline.py	/^		image = Image.open(fname)$/;"	v
image	.\examples\arabic_offline_handwriting\arabic_offline.py	/^	image = Image.open(filename).transpose(Image.FLIP_TOP_BOTTOM).transpose(Image.ROTATE_270)$/;"	v
importance	.\src\DataSequence.hpp	/^	SeqBuffer<real_t> importance;$/;"	m	struct:DataSequence
in	.\src\Helpers.hpp	/^template <class R, class T> static bool in(const R& r, const T& t)$/;"	f
in	.\src\Helpers.hpp	/^template<class T1, class T2> static bool in(const map<T1, T2>& a, const T1& b)$/;"	f
in	.\src\Helpers.hpp	/^template<class T1, class T2> static bool in(const multimap<T1, T2>& a, const T1& b)$/;"	f
in	.\src\String.hpp	/^static bool in(const string& str, const char* search)$/;"	f
in	.\src\String.hpp	/^static bool in(const string& str, const string& search)$/;"	f
inCoords	.\src\BlockLayer.hpp	/^	vector<int> inCoords;$/;"	m	struct:BlockLayer
inGateActs	.\src\LstmLayer.hpp	/^	SeqBuffer<real_t> inGateActs;$/;"	m	struct:LstmLayer
in_closed_interval	.\src\Helpers.hpp	/^template<class T> static bool in_closed_interval(pair<T,T> interval, T val)$/;"	f
in_left	.\src\Helpers.hpp	/^template<class T1, class T2> static bool in_left(const bimap<T1, T2>& a, const T1& b)$/;"	f
in_open_interval	.\src\Helpers.hpp	/^template<class T> static bool in_open_interval(pair<T,T> interval, T val)$/;"	f
in_range	.\src\Helpers.hpp	/^template <class R> static bool in_range(R& r, size_t n)$/;"	f
in_range	.\src\MultiArray.hpp	/^	bool in_range(const vector<int>& coords) const$/;"	f	struct:MultiArray
in_right	.\src\Helpers.hpp	/^template<class T1, class T2> static bool in_right(const bimap<T1, T2>& a, const T2& b)$/;"	f
index	.\src\Helpers.hpp	/^template <class R, class T> static size_t index(const R& r, const T& t)$/;"	f
index	.\utils\plot_variables.py	/^						index = 0$/;"	v
indices	.\src\Helpers.hpp	/^template <class R> static integer_range<typename boost::range_size<R>::type> indices(const R& r)$/;"	f
infile	.\utils\normalise_netcdf.py	/^infile = netcdf_helpers.NetCDFFile(inputFilename, 'r')$/;"	v
infile	.\utils\rescale_netcdf_binary_inputs.py	/^infile = NetCDFFile(filename, 'a')$/;"	v
infilename	.\utils\plot_variables.py	/^infilename = args[0]$/;"	v
infilename	.\utils\shuffle_and_split.py	/^infilename = args [0]$/;"	v
infinity	.\src\Helpers.hpp	/^static const real_t infinity = numeric_limits<real_t>::infinity();$/;"	v
init	.\src\NetcdfDataset.hpp	/^	void init()$/;"	f	struct:NetcdfDataset
init	.\src\NeuronLayer.hpp	/^	void init()$/;"	f	struct:NeuronLayer
initDelta	.\src\Rprop.hpp	/^	real_t initDelta;$/;"	m	struct:Rprop
inkmlfile	.\examples\arabic_online_handwriting\arabic_online.py	/^	inkmlfile = l.strip()$/;"	v
inner_product	.\src\Helpers.hpp	/^template<class R1, class R2> static typename range_value<R1>::type inner_product(const R1& a, const R2& b, typename range_value<R1>::type c = 0)$/;"	f
inputActivations	.\src\Layer.hpp	/^	SeqBuffer<real_t> inputActivations;$/;"	m	struct:Layer
inputBlock	.\src\Mdrnn.hpp	/^	vector<size_t> inputBlock;		\/\/ inputBlock Shape 3,4$/;"	m	struct:Mdrnn
inputBlockLayer	.\src\Mdrnn.hpp	/^	Layer* inputBlockLayer;			\/\/ Data input 連接到 inputBlock 算是第一層，也依照 inputBlock(3,4)大小設置(不過好像還沒有*W過)$/;"	m	struct:Mdrnn
inputClasses	.\src\DataSequence.hpp	/^	SeqBuffer<int> inputClasses;$/;"	m	struct:DataSequence
inputDims	.\utils\dump_weights.py	/^	inputDims = [re.search('(inputSize) (\\S+)', text).group(2)]$/;"	v
inputDims	.\utils\dump_weights.py	/^	inputDims = opt.inputDims.split()$/;"	v
inputErrors	.\src\Layer.hpp	/^	SeqBuffer<real_t> inputErrors;$/;"	m	struct:Layer
inputFilename	.\examples\arabic_offline_handwriting\arabic_offline.py	/^inputFilename = args[0]$/;"	v
inputFilename	.\examples\arabic_online_handwriting\arabic_online.py	/^inputFilename = args [0]$/;"	v
inputFilename	.\examples\farsi_offline_handwriting\farsi_chars.py	/^inputFilename = args[0]$/;"	v
inputFilename	.\utils\normalise_netcdf.py	/^inputFilename = args[0]$/;"	v
inputLabelCounts	.\src\NetcdfDataset.hpp	/^	map<string, int> inputLabelCounts;$/;"	m	struct:DataHeader
inputLabelHits	.\src\NetcdfDataset.hpp	/^	map <string, real_t> inputLabelHits;$/;"	m	struct:DataList
inputLabels	.\src\NetcdfDataset.hpp	/^	Vector<string> inputLabels;$/;"	m	struct:DataHeader
inputLayer	.\src\Mdrnn.hpp	/^	InputLayer* inputLayer;$/;"	m	struct:Mdrnn
inputMatch	.\utils\dump_weight_matrices.py	/^	inputMatch = re.search('(inputSize) (\\S+)', text)$/;"	v
inputMean	.\examples\arabic_offline_handwriting\arabic_offline.py	/^inputMean = 226.8663$/;"	v
inputMean	.\examples\farsi_offline_handwriting\farsi_chars.py	/^ 	inputMean = 244.2604$/;"	v
inputMean	.\examples\farsi_offline_handwriting\farsi_chars.py	/^ 	inputMean = 247.2425$/;"	v
inputMeans	.\examples\arabic_online_handwriting\arabic_online.py	/^inputMeans = array([511.8343, 102.7592, 0.03199977])$/;"	v
inputMeans	.\utils\normalise_netcdf.py	/^	inputMeans = array(stdMeanFile.variables[options.inputArrayName+'Means'].getValue())$/;"	v
inputMeans	.\utils\normalise_netcdf.py	/^	inputMeans=mean(outputArray[:options.maxArraySize],0)$/;"	v
inputNoiseDev	.\src\Trainer.hpp	/^	real_t inputNoiseDev;$/;"	m	struct:Trainer
inputSeqDims	.\src\NetcdfDataset.hpp	/^	SeqBuffer<int> inputSeqDims;$/;"	m	struct:NetcdfDataset
inputSize	.\src\NetcdfDataset.hpp	/^	size_t inputSize;$/;"	m	struct:DataHeader
inputStd	.\examples\arabic_offline_handwriting\arabic_offline.py	/^inputStd = 81.62196$/;"	v
inputStd	.\examples\farsi_offline_handwriting\farsi_chars.py	/^	inputStd = 29.01598$/;"	v
inputStd	.\examples\farsi_offline_handwriting\farsi_chars.py	/^	inputStd = 30.54056$/;"	v
inputStds	.\examples\arabic_online_handwriting\arabic_online.py	/^inputStds = array([134.0498, 24.34094, 0.1758981])$/;"	v
inputStds	.\utils\normalise_netcdf.py	/^	inputStds = array(stdMeanFile.variables[options.inputArrayName+'Stds'].getValue())$/;"	v
inputStds	.\utils\normalise_netcdf.py	/^	inputStds=Std(outputArray[:options.maxArraySize],0)$/;"	v
inputVar	.\utils\normalise_netcdf.py	/^inputVar = infile.variables[options.inputArrayName]$/;"	v
input_seq_begin	.\src\Layer.hpp	/^	virtual SeqIterator input_seq_begin() const$/;"	f	struct:Layer
input_seq_rbegin	.\src\Layer.hpp	/^	virtual SeqIterator input_seq_rbegin() const$/;"	f	struct:Layer
input_seq_shape	.\src\Layer.hpp	/^	virtual const View<const size_t> input_seq_shape() const$/;"	f	struct:Layer
input_size	.\src\Layer.hpp	/^	virtual size_t input_size() const$/;"	f	struct:Layer
inputlines	.\examples\farsi_offline_handwriting\farsi_chars.py	/^inputlines = file(inputFilename).readlines()$/;"	v
inputs	.\examples\arabic_offline_handwriting\arabic_offline.py	/^inputs = zeros((totalLen,1), 'f')$/;"	v
inputs	.\examples\arabic_online_handwriting\arabic_online.py	/^inputs = ((array(inputs)-inputMeans)\/inputStds).tolist()$/;"	v
inputs	.\examples\arabic_online_handwriting\arabic_online.py	/^inputs = []$/;"	v
inputs	.\examples\farsi_offline_handwriting\farsi_chars.py	/^inputs = zeros((sum(seqLengths), 1), 'f')$/;"	v
inputs	.\src\DataSequence.hpp	/^	SeqBuffer<real_t> inputs;$/;"	m	struct:DataSequence
inputs	.\utils\rescale_netcdf_binary_inputs.py	/^inputs = invar.getValue()$/;"	v
insMap	.\src\StringAlignment.hpp	/^	map<typename boost::range_value<R1>::type, int> insMap;$/;"	m	struct:StringAlignment
insPenalty	.\src\StringAlignment.hpp	/^	int insPenalty;$/;"	m	struct:StringAlignment
insertions	.\src\StringAlignment.hpp	/^	int insertions;$/;"	m	struct:StringAlignment
instance	.\src\DataExporter.hpp	/^	static DataExportHandler& instance()$/;"	f	struct:DataExportHandler
instance	.\src\WeightContainer.hpp	/^	static WeightContainer& instance()$/;"	f	struct:WeightContainer
int_to_sortable_string	.\src\String.hpp	/^static string int_to_sortable_string(size_t num, size_t max)$/;"	f
integer	.\src\Helpers.hpp	/^template<class T> static int integer(const T& t)$/;"	f
intersecting	.\src\Helpers.hpp	/^template<class T> static bool intersecting(const set<T>& s1, const set<T>& s2)$/;"	f
invTrainSeqs	.\src\Trainer.hpp	/^    real_t invTrainSeqs;$/;"	m	struct:Trainer
invar	.\utils\rescale_netcdf_binary_inputs.py	/^invar = infile.variables['inputs']$/;"	v
io	.\utils\max_jacobian.py	/^from scipy import io$/;"	i
iota	.\src\Helpers.hpp	/^template <class T1, class T2> static vector<T1> iota(const T2& t)$/;"	f
iota	.\src\Helpers.hpp	/^template <class T1, class T2> static vector<T1> iota(const T2& t1, const T2& t2)$/;"	f
is_mirror	.\src\Mdrnn.hpp	/^ 	bool is_mirror(const Layer* layer)$/;"	f	struct:Mdrnn
is_recurrent	.\src\Mdrnn.hpp	/^	bool is_recurrent(const Layer* layer) const$/;"	f	struct:Mdrnn
jaclistfile	.\utils\max_jacobian.py	/^jaclistfile = args[0]$/;"	v
join	.\src\String.hpp	/^template<class T, class R >static string join(const R& r, const string joinStr = "")$/;"	f
l1	.\src\Trainer.hpp	/^	real_t l1;$/;"	m	struct:Trainer
l2	.\src\Trainer.hpp	/^	real_t l2;$/;"	m	struct:Trainer
lab	.\examples\arabic_offline_handwriting\arabic_offline.py	/^									lab = w[:ligChar]$/;"	v
lab	.\examples\arabic_offline_handwriting\arabic_offline.py	/^									lab = w[len(ligatureString):]$/;"	v
lab	.\examples\arabic_offline_handwriting\arabic_offline.py	/^								lab = w$/;"	v
lab	.\examples\arabic_offline_handwriting\arabic_offline.py	/^							lab = lab[0] + lab[1:].replace('1','').replace('2','')$/;"	v
lab	.\examples\arabic_offline_handwriting\arabic_offline.py	/^			lab = l.split('*')[1].strip()$/;"	v
lab	.\utils\plot_errors.py	/^					lab = "best "+best[0]$/;"	v
lab	.\utils\plot_errors.py	/^					lab = "best network"$/;"	v
lab	.\utils\plot_variables.py	/^			lab = labels[c]$/;"	v
lab	.\utils\plot_variables.py	/^			lab = str(c)$/;"	v
label	.\examples\arabic_online_handwriting\arabic_online.py	/^				label = c.encode('unicode_escape')$/;"	v
label	.\examples\farsi_offline_handwriting\farsi_chars.py	/^				label = fname.split('\/')[-1][:2]$/;"	v
label	.\examples\farsi_offline_handwriting\farsi_chars.py	/^				label = labels[0]$/;"	v
labelDelim	.\utils\dump_weights.py	/^		labelDelim = delimMatch.group(2)$/;"	v
label_seq_to_str	.\src\DataSequence.hpp	/^template<class R> static string label_seq_to_str(const R& labelSeq, const vector<string>& alphabet, const string& delim = " ")$/;"	f
labelledLines	.\utils\plot_variables.py	/^	labelledLines = False	$/;"	v
labelledLines	.\utils\plot_variables.py	/^	labelledLines = True$/;"	v
labels	.\examples\arabic_offline_handwriting\arabic_offline.py	/^	labels = []$/;"	v
labels	.\examples\arabic_offline_handwriting\arabic_offline.py	/^	labels = list(labels)$/;"	v
labels	.\examples\arabic_offline_handwriting\arabic_offline.py	/^	labels = set()$/;"	v
labels	.\examples\arabic_online_handwriting\arabic_online.py	/^labels = ['*', '0', '1', '2', '6', '7', '8', '9', 'V', '\\\\u0621', '\\\\u0622', '\\\\u0623', '\\\\u0625', '\\\\u0626', '\\\\u0627', '\\\\u0628', '\\\\u0629', '\\\\u062a', '\\\\u062b', '\\\\u062c', '\\\\u062d', '\\\\u062e', '\\\\u062f', '\\\\u0630', '\\\\u0631', '\\\\u0632', '\\\\u0633', '\\\\u0634', '\\\\u0635', '\\\\u0636', '\\\\u0637', '\\\\u0638', '\\\\u0639', '\\\\u063a', '\\\\u0641', '\\\\u0642', '\\\\u0643', '\\\\u0644', '\\\\u0645', '\\\\u0646', '\\\\u0647', '\\\\u0648', '\\\\u0649', '\\\\u064a', '\\\\u0651']$/;"	v
labels	.\examples\farsi_offline_handwriting\farsi_chars.py	/^	labels = [str(x).rjust(2,'0') for x in range(1,35)]$/;"	v
labels	.\examples\farsi_offline_handwriting\farsi_chars.py	/^	labels = [str(x).rjust(2,'0') for x in range(35,47)]$/;"	v
labels	.\src\ClassificationLayer.hpp	/^	Vector<string> labels;$/;"	m	struct:ClassificationLayer
labels	.\src\DataExporter.hpp	/^	const vector<string>* labels;$/;"	m	struct:SeqBufferVal
labels	.\utils\max_jacobian.py	/^labels = file(outactsfile).readline().split()[1:]$/;"	v
labels	.\utils\plot_variables.py	/^		labels = line[1:]$/;"	v
labels	.\utils\plot_variables.py	/^		labels = newlabels$/;"	v
labels	.\utils\plot_variables.py	/^labels = []$/;"	v
last_index	.\src\Helpers.hpp	/^template <class R> static size_t last_index(R& r)$/;"	f
layerName	.\utils\dump_weight_matrices.py	/^	layerName = 'hidden_' + str(n)$/;"	v
layerOutputSizes	.\utils\dump_weight_matrices.py	/^layerOutputSizes = {'bias':1}$/;"	v
layerSizes	.\utils\dump_weights.py	/^layerSizes = {"bias":1}$/;"	v
learnRate	.\src\SteepestDescent.hpp	/^	real_t learnRate;$/;"	m	struct:SteepestDescent
left_pad	.\src\String.hpp	/^template<class T> string left_pad(const T& val, int width, char fill = '0')$/;"	f
ligChar	.\examples\arabic_offline_handwriting\arabic_offline.py	/^							ligChar = w.find(ligatureString)$/;"	v
ligatureString	.\examples\arabic_offline_handwriting\arabic_offline.py	/^ligatureString = 'llL'$/;"	v
line	.\utils\plot_variables.py	/^	line = data.readline().split()$/;"	v
line	.\utils\plot_variables.py	/^line = data.readline().split()$/;"	v
line	.\utils\shuffle_and_split.py	/^line = 0$/;"	v
line2d	.\utils\plot_variables.py	/^		line2d = axes.plot(lineData, linewidth=1.5, label = lab)[0]$/;"	v
lineData	.\utils\plot_variables.py	/^		lineData = data[c,:]$/;"	v
lineLabelMap	.\utils\plot_variables.py	/^	lineLabelMap = dict()$/;"	v
lines	.\utils\min_max.py	/^	lines = file(f).readlines()$/;"	v
lines	.\utils\plot_errors.py	/^lines = file(filename, 'r').readlines()$/;"	v
lines	.\utils\plot_variables.py	/^	lines = set()$/;"	v
lines	.\utils\shuffle_and_split.py	/^lines = file(infilename).readlines()$/;"	v
link_layers	.\src\WeightContainer.hpp	/^	void link_layers(const string& fromName, const string& toName, const string& connName = "", int paramBegin = 0, int paramEnd = 0)$/;"	f	struct:WeightContainer
load	.\src\DataExporter.cpp	/^void DataExportHandler::load(ConfigFile& conf, ostream& out)$/;"	f	class:DataExportHandler
load	.\src\DataExporter.hpp	/^	bool load(ConfigFile& conf, ostream& out = cout)$/;"	f	struct:DataExporter
load	.\src\DataExporter.hpp	/^	bool load(istream& in, ostream& out = cout)$/;"	f	struct:ParamVal
load	.\src\DataExporter.hpp	/^	bool load(istream& in, ostream& out = cout)$/;"	f	struct:RangeVal
load	.\src\DataExporter.hpp	/^	virtual bool load(istream& in, ostream& out = cout)$/;"	f	struct:Val
load_array	.\src\NetcdfDataset.hpp	/^	template<class T> bool load_array(const string& name, vector<T>& dest, bool required = true, int offset = 0, int count = -1)$/;"	f	struct:NetcdfDataset
load_dim	.\src\NetcdfDataset.hpp	/^	int load_dim(const string& name, bool required = true)$/;"	f	struct:NetcdfDataset
load_nc_array	.\src\NetcdfDataset.hpp	/^template<class T> static bool load_nc_array(const NcFile& ncf, const string& name, vector<T>& dest, bool required = true, int offset = 0, int count = -1)$/;"	f
load_nc_dim	.\src\NetcdfDataset.hpp	/^static int load_nc_dim(const NcFile& ncf, const string& name, bool required = true)$/;"	f
load_nc_variable	.\src\NetcdfDataset.hpp	/^static NcVar* load_nc_variable (const NcFile& ncf, const string& name, bool required = true)$/;"	f
load_sequences	.\src\NetcdfDataset.hpp	/^	void load_sequences (int first, int last)$/;"	f	struct:NetcdfDataset
load_to_seq_buffer	.\src\NetcdfDataset.hpp	/^	template<class T, class R> bool load_to_seq_buffer(SeqBuffer<T>& dest, const R& shape, const string& name, bool required = true, int offset = 0, int count = -1)$/;"	f	struct:NetcdfDataset
load_to_seq_buffer_with_depth	.\src\NetcdfDataset.hpp	/^	template<class T, class R> bool load_to_seq_buffer_with_depth(SeqBuffer<T>& dest, const R& shape, int depth, const string& name, bool required = true, int offset = 0, int count = -1)$/;"	f	struct:NetcdfDataset
load_variable	.\src\NetcdfDataset.hpp	/^	NcVar* load_variable (const string& name, bool required = true)$/;"	f	struct:NetcdfDataset
log	.\src\Log.hpp	/^	T log() const$/;"	f	class:Log
logActivations	.\src\SoftmaxLayer.hpp	/^	SeqBuffer<Log<real_t> > logActivations;$/;"	m	struct:SoftmaxLayer
logInfinity	.\src\Log.hpp	/^	static const T logInfinity;$/;"	m	class:Log
logInfinity	.\src\Log.hpp	/^template <class T> const T Log<T>::logInfinity = 1e100;$/;"	m	class:Log
logVal	.\src\Log.hpp	/^	T logVal;$/;"	m	class:Log
logZero	.\src\Log.hpp	/^	static const T logZero;$/;"	m	class:Log
logZero	.\src\Log.hpp	/^template <class T> const T Log<T>::logZero = -Log<T>::logInfinity;$/;"	m	class:Log
log_add	.\src\Log.hpp	/^	static T log_add(T x, T y)$/;"	f	class:Log
log_divide	.\src\Log.hpp	/^	static T log_divide(T x, T y)$/;"	f	class:Log
log_multiply	.\src\Log.hpp	/^	static T log_multiply(T x, T y)$/;"	f	class:Log
log_subtract	.\src\Log.hpp	/^	static T log_subtract(T x, T y)$/;"	f	class:Log
log_sum	.\src\Helpers.hpp	/^template <class R> static typename range_value<R>::type log_sum(const R& r)$/;"	f
lower	.\src\String.hpp	/^static const string lower(const string& s)$/;"	f
m	.\src\StringAlignment.hpp	/^	size_t m;$/;"	m	struct:StringAlignment
m	.\utils\max_jacobian.py	/^		m = c.index(max(c))$/;"	v
m	.\utils\max_jacobian.py	/^	m = c.index(max(c))$/;"	v
main	.\src\Main.cpp	/^int main(int argc, char* argv[])$/;"	f
make_classification_layer	.\src\ClassificationLayer.hpp	/^ClassificationLayer* make_classification_layer(ostream& out, const string& name, size_t numSeqDims, const vector<string>& labels)$/;"	f
make_layer_recurrent	.\src\Mdrnn.hpp	/^	void make_layer_recurrent(Layer* layer)$/;"	f	struct:Mdrnn
make_name	.\src\FullConnection.hpp	/^	static const string& make_name(Layer* f, Layer* t, const vector<int>& d)$/;"	f	struct:FullConnection
make_target_labels	.\src\TranscriptionLayer.hpp	/^	vector<string> make_target_labels(const vector<string>& labs)$/;"	f	struct:TranscriptionLayer
mark	.\src\Helpers.hpp	/^static void mark()$/;"	f
matrix	.\src\StringAlignment.hpp	/^	Vector<Vector<int> > matrix;$/;"	m	struct:StringAlignment
matrixOps	.\src\Matrix.hpp	/^static unsigned long long matrixOps = 0;$/;"	v
max	.\src\Helpers.hpp	/^template <class R> static typename range_value<R>::type max(const R& r)$/;"	f
max	.\utils\normalise_netcdf.py	/^				max = min (offset+step, len(outputArray))$/;"	v
max	.\utils\plot_variables.py	/^					max = val$/;"	v
max	.\utils\plot_variables.py	/^			max = 0$/;"	v
maxDelta	.\src\Rprop.hpp	/^	real_t maxDelta;$/;"	m	struct:Rprop
maxLen	.\utils\netcdf_helpers.py	/^def maxLen(strings):$/;"	f
maxLength	.\utils\netcdf_helpers.py	/^	maxLength = maxLen(strings) + 1$/;"	v
maxNum	.\utils\plot_variables.py	/^					maxNum = v$/;"	v
maxNum	.\utils\plot_variables.py	/^			maxNum = -1$/;"	v
maxVal	.\utils\min_max.py	/^				maxVal = f$/;"	v
maxVal	.\utils\min_max.py	/^maxVal = -minVal$/;"	v
maxindices	.\utils\max_jacobian.py	/^maxindices = []$/;"	v
mdl	.\src\Trainer.hpp	/^	bool mdl;$/;"	m	struct:Trainer
mdlInitStdDev	.\src\Trainer.hpp	/^	real_t mdlInitStdDev;$/;"	m	struct:Trainer
mdlMlErrors	.\src\Trainer.hpp	/^    Vector<prob_t> mdlMlErrors;$/;"	m	struct:Trainer
mdlOldDerivs	.\src\Trainer.hpp	/^	Vector<real_t> mdlOldDerivs;$/;"	m	struct:Trainer
mdlOptimiser	.\src\Trainer.hpp	/^	Optimiser* mdlOptimiser;$/;"	m	struct:Trainer
mdlPriorMean	.\src\Trainer.hpp	/^	real_t mdlPriorMean;$/;"	m	struct:Trainer
mdlPriorStdDev	.\src\Trainer.hpp	/^    real_t mdlPriorStdDev;$/;"	m	struct:Trainer
mdlPriorVariance	.\src\Trainer.hpp	/^    real_t mdlPriorVariance;$/;"	m	struct:Trainer
mdlSamples	.\src\Trainer.hpp	/^	int mdlSamples;$/;"	m	struct:Trainer
mdlSeqDerivs	.\src\Trainer.hpp	/^	Vector<real_t> mdlSeqDerivs;$/;"	m	struct:Trainer
mdlSeqErrors	.\src\Trainer.hpp	/^	map<string, real_t> mdlSeqErrors;$/;"	m	struct:Trainer
mdlStdDevDerivs	.\src\Trainer.hpp	/^	Vector<real_t> mdlStdDevDerivs;$/;"	m	struct:Trainer
mdlStdDevs	.\src\Trainer.hpp	/^	Vector<real_t> mdlStdDevs;$/;"	m	struct:Trainer
mdlSymmetricSampling	.\src\Trainer.hpp	/^	bool mdlSymmetricSampling;$/;"	m	struct:Trainer
mdlWeight	.\src\Trainer.hpp	/^	real_t mdlWeight;$/;"	m	struct:Trainer
mdl_calculate_prior_params	.\src\Trainer.hpp	/^	void mdl_calculate_prior_params()$/;"	f	struct:Trainer
mdl_differentiate	.\src\Trainer.hpp	/^	void mdl_differentiate(real_t scaleFactor = 1)$/;"	f	struct:Trainer
mdl_evaluate	.\src\Trainer.hpp	/^	real_t mdl_evaluate()$/;"	f	struct:Trainer
mdl_mean	.\src\Trainer.hpp	/^	real_t mdl_mean(int i)$/;"	f	struct:Trainer
mdl_ml_error	.\src\Trainer.hpp	/^	real_t mdl_ml_error()$/;"	f	struct:Trainer
mdl_print_stats	.\src\Trainer.hpp	/^	void mdl_print_stats()$/;"	f	struct:Trainer
mdl_sample_weights	.\src\Trainer.hpp	/^	void mdl_sample_weights(int sampleNum)$/;"	f	struct:Trainer
mdl_std_dev	.\src\Trainer.hpp	/^	real_t mdl_std_dev(int i)$/;"	f	struct:Trainer
mdl_variance	.\src\Trainer.hpp	/^	real_t mdl_variance(int i)$/;"	f	struct:Trainer
mean	.\src\Helpers.hpp	/^template <class R> static typename range_value<R>::type mean(const R& r)$/;"	f
minDelta	.\src\Rprop.hpp	/^	real_t minDelta;$/;"	m	struct:Rprop
minVal	.\utils\min_max.py	/^				minVal = f$/;"	v
minVal	.\utils\min_max.py	/^minVal = 100000000.0$/;"	v
minmax	.\src\Helpers.hpp	/^template <class R> pair<typename range_value<R>::type, typename range_value<R>::type> minmax(const R& r)$/;"	f
momentum	.\src\SteepestDescent.hpp	/^	real_t momentum;$/;"	m	struct:SteepestDescent
n	.\src\StringAlignment.hpp	/^	size_t n;$/;"	m	struct:StringAlignment
name	.\src\Named.hpp	/^	string name;$/;"	m	struct:Named
nats_to_bits	.\src\Helpers.hpp	/^static real_t nats_to_bits(real_t nats)$/;"	f
natural	.\src\Helpers.hpp	/^template<class T> static size_t natural(const T& t)$/;"	f
nc	.\src\NetcdfDataset.hpp	/^	NcFile nc;$/;"	m	struct:NetcdfDataset
ncFilename	.\examples\arabic_online_handwriting\arabic_online.py	/^ncFilename = args[1]$/;"	v
ncFilename	.\examples\farsi_offline_handwriting\farsi_chars.py	/^ncFilename = args[1]$/;"	v
net	.\src\GradientCheck.hpp	/^	Mdrnn* net;$/;"	m	struct:GradientCheck
net	.\src\Trainer.hpp	/^	Mdrnn* net;$/;"	m	struct:Trainer
netErrors	.\src\Trainer.hpp	/^	map<string, real_t>& netErrors;$/;"	m	struct:Trainer
netNormFactors	.\src\Trainer.hpp	/^	const map<string, real_t>& netNormFactors;$/;"	m	struct:Trainer
netcdf_helpers	.\examples\arabic_offline_handwriting\arabic_offline.py	/^import netcdf_helpers$/;"	i
netcdf_helpers	.\examples\arabic_online_handwriting\arabic_online.py	/^import netcdf_helpers$/;"	i
netcdf_helpers	.\examples\farsi_offline_handwriting\farsi_chars.py	/^import netcdf_helpers$/;"	i
netcdf_helpers	.\utils\normalise_netcdf.py	/^import netcdf_helpers$/;"	i
newData	.\utils\plot_variables.py	/^				newData = []$/;"	v
newData	.\utils\plot_variables.py	/^			newData = []$/;"	v
new_parameters	.\src\WeightContainer.hpp	/^	pair<size_t, size_t> new_parameters(size_t numParams, const string& fromName, const string& toName, const string& connName)$/;"	f	struct:WeightContainer
newdata	.\utils\plot_variables.py	/^	newdata = []$/;"	v
newdata	.\utils\plot_variables.py	/^	newdata = array(newdata)$/;"	v
newlabels	.\utils\plot_variables.py	/^	newlabels = []$/;"	v
newline	.\utils\plot_variables.py	/^						newline = zeros((width*blockDims[0], height*blockDims[1], colourDepth), 'f')$/;"	v
nextCellErrors	.\src\LstmLayer.hpp	/^	vector<View<real_t> > nextCellErrors;$/;"	m	struct:LstmLayer
nextErrors	.\src\LstmLayer.hpp	/^	vector<View<real_t> > nextErrors;$/;"	m	struct:LstmLayer
nextFgActs	.\src\LstmLayer.hpp	/^	vector<View<real_t> > nextFgActs;$/;"	m	struct:LstmLayer
next_dataset	.\src\NetcdfDataset.hpp	/^	bool next_dataset()$/;"	f	struct:DataList
next_sequence	.\src\NetcdfDataset.hpp	/^	DataSequence* next_sequence()$/;"	f	struct:DataList
norm	.\src\Helpers.hpp	/^template <class R> static typename range_value<R>::type norm(const R& r)$/;"	f
normFactors	.\src\DatasetErrors.hpp	/^	map<string, real_t> normFactors;$/;"	m	struct:DatasetErrors
normFactors	.\src\Mdrnn.hpp	/^	map<string, real_t> normFactors;$/;"	m	struct:Mdrnn
normFactors	.\src\NetworkOutput.hpp	/^	map <string, real_t> normFactors;$/;"	m	struct:NetworkOutput
normal	.\src\Random.cpp	/^real_t Random::normal()$/;"	f	class:Random
normal	.\src\Random.cpp	/^real_t Random::normal(real_t dev, real_t mean)$/;"	f	class:Random
normalise	.\src\DatasetErrors.hpp	/^	void normalise()$/;"	f	struct:DatasetErrors
nth_last	.\src\Helpers.hpp	/^template <class R> static typename range_value<R>::type& nth_last(R& r, size_t n = 1)$/;"	f
nullStrings	.\utils\netcdf_helpers.py	/^	nullStrings = []$/;"	v
numBlocks	.\src\LstmLayer.hpp	/^	size_t numBlocks;$/;"	m	struct:LstmLayer
numCells	.\src\LstmLayer.hpp	/^	size_t numCells;$/;"	m	struct:LstmLayer
numDigits	.\utils\shuffle_and_split.py	/^numDigits = len(str(len(splitlines) - 1))$/;"	v
numDims	.\src\NetcdfDataset.hpp	/^	int numDims;$/;"	m	struct:DataHeader
numErrorsByClass	.\src\ClassificationLayer.hpp	/^	vector<int> numErrorsByClass;$/;"	m	struct:ClassificationLayer
numRowsToSkip	.\utils\plot_variables.py	/^numRowsToSkip = 0$/;"	v
numSequences	.\src\NetcdfDataset.hpp	/^	size_t numSequences;$/;"	m	struct:DataHeader
numSequences	.\src\NetcdfDataset.hpp	/^	size_t numSequences;$/;"	m	struct:DataList
numSplits	.\utils\shuffle_and_split.py	/^	numSplits = int(splitstrings[0])$/;"	v
numTargetsByClass	.\src\ClassificationLayer.hpp	/^	vector<int> numTargetsByClass;$/;"	m	struct:ClassificationLayer
numTimesteps	.\src\NetcdfDataset.hpp	/^	size_t numTimesteps;$/;"	m	struct:DataHeader
numTimesteps	.\src\NetcdfDataset.hpp	/^	size_t numTimesteps;$/;"	m	struct:DataList
numVals	.\utils\std_dev_mean.py	/^numVals = len(vals)$/;"	v
num_dims	.\src\MultiArray.hpp	/^	virtual size_t num_dims() const$/;"	f	struct:MultiArray
num_seq_dims	.\src\Layer.hpp	/^	virtual size_t num_seq_dims() const$/;"	f	struct:Layer
num_seq_dims	.\src\Mdrnn.hpp	/^	size_t num_seq_dims() const$/;"	f	struct:Mdrnn
num_seq_dims	.\src\SeqBuffer.hpp	/^ 	size_t num_seq_dims() const$/;"	f	struct:SeqBuffer
num_timesteps	.\src\DataSequence.hpp	/^	size_t num_timesteps() const$/;"	f	struct:DataSequence
num_weights	.\src\Connection.hpp	/^	virtual size_t num_weights() const {return 0;}$/;"	f	struct:Connection
num_weights	.\src\FullConnection.hpp	/^	size_t num_weights() const$/;"	f	struct:FullConnection
numpy	.\utils\std_dev_mean.py	/^import numpy$/;"	i
offset	.\examples\arabic_offline_handwriting\arabic_offline.py	/^offset = 0$/;"	v
offset	.\examples\farsi_offline_handwriting\farsi_chars.py	/^offset = 0$/;"	v
offset	.\src\MultiArray.hpp	/^	size_t offset(const vector<int>& coords) const$/;"	f	struct:MultiArray
offset	.\utils\normalise_netcdf.py	/^			offset = 0$/;"	v
oldStart	.\examples\arabic_offline_handwriting\arabic_offline.py	/^							oldStart = match.start()$/;"	v
oldStart	.\examples\arabic_offline_handwriting\arabic_offline.py	/^						oldStart = 0$/;"	v
oldStates	.\src\LstmLayer.hpp	/^	vector<View<real_t> > oldStates;$/;"	m	struct:LstmLayer
oldl	.\utils\shuffle_and_split.py	/^	oldl =l$/;"	v
oldl	.\utils\shuffle_and_split.py	/^oldl = 0$/;"	v
oldlen	.\examples\arabic_online_handwriting\arabic_online.py	/^		oldlen = len(inputs)$/;"	v
online	.\src\Rprop.hpp	/^	bool online;$/;"	m	struct:Rprop
operator *	.\src\Log.hpp	/^template<class T> Log<T> operator *(Log<T> log1, Log<T> log2)$/;"	f
operator *	.\src\SeqBuffer.hpp	/^	const vector<int>& operator* () const$/;"	f	struct:CoordIterator
operator *=	.\src\Helpers.hpp	/^template<class T1, class T2, class T3, class T4> static void operator *=(map<T1, T2>& a, const map<T3, T4>& b)$/;"	f
operator *=	.\src\Helpers.hpp	/^template<class T1, class T2, class T3> static void operator *=(map<T1, T2>& a, const T3& b)$/;"	f
operator *=	.\src\Log.hpp	/^	Log<T>& operator *=(const Log<T>& l)$/;"	f	class:Log
operator +	.\src\Helpers.hpp	/^template<class T1, class T2, class T3> static pair<T1, T2> operator+ (const pair<T1, T2>& a, const T3& b)$/;"	f
operator +	.\src\Log.hpp	/^template<class T> Log<T> operator +(Log<T> log1, Log<T> log2)$/;"	f
operator ++	.\src\SeqBuffer.hpp	/^	CoordIterator& operator++ ()$/;"	f	struct:CoordIterator
operator +=	.\src\Container.hpp	/^	Set& operator +=(const T& val) $/;"	f	struct:Set
operator +=	.\src\Helpers.hpp	/^template<class T1, class T2, class T3, class T4> static void operator +=(map<T1, T2>& a, const map<T3, T4>& b)$/;"	f
operator +=	.\src\Helpers.hpp	/^template<class T1, class T2> static void operator+= (pair<T1, T2>& a, const pair<T1, T2>& b)$/;"	f
operator +=	.\src\Log.hpp	/^	Log<T>& operator +=(const Log<T>& l)$/;"	f	class:Log
operator -	.\src\Log.hpp	/^template<class T> Log<T> operator -(Log<T> log1, Log<T> log2)$/;"	f
operator -=	.\src\Helpers.hpp	/^template<class T1, class T2, class T3, class T4> static void operator -=(map<T1, T2>& a, const map<T3, T4>& b)$/;"	f
operator -=	.\src\Log.hpp	/^	Log<T>& operator -=(const Log<T>& l)$/;"	f	class:Log
operator /	.\src\Log.hpp	/^template<class T> Log<T> operator \/(Log<T> log1, Log<T> log2)$/;"	f
operator /=	.\src\Helpers.hpp	/^template<class T1, class T2, class T3, class T4> static void operator \/=(map<T1, T2>& a, const map<T3, T4>& b)$/;"	f
operator /=	.\src\Helpers.hpp	/^template<class T1, class T2, class T3> static void operator \/=(map<T1, T2>& a, const T3& b)$/;"	f
operator /=	.\src\Log.hpp	/^	Log<T>& operator \/=(const Log<T>& l)$/;"	f	class:Log
operator <	.\src\Log.hpp	/^template<class T> bool operator <(Log<T> log1, Log<T> log2)$/;"	f
operator <<	.\src\ConfigFile.hpp	/^static ostream& operator << (ostream& out, const ConfigFile& conf)$/;"	f
operator <<	.\src\Connection.hpp	/^static ostream& operator <<(ostream& out, const Connection& c)$/;"	f
operator <<	.\src\DataExporter.hpp	/^static ostream& operator << (ostream& out, const DataExportHandler& de)$/;"	f
operator <<	.\src\DataExporter.hpp	/^static ostream& operator <<(ostream& out, const DataExporter& d)$/;"	f
operator <<	.\src\DataExporter.hpp	/^static ostream& operator <<(ostream& out, const Val& v)$/;"	f
operator <<	.\src\DataSequence.hpp	/^static ostream& operator <<(ostream& out, const DataSequence& seq)$/;"	f
operator <<	.\src\DatasetErrors.hpp	/^static ostream& operator << (ostream& out, const DatasetErrors& de)$/;"	f
operator <<	.\src\Helpers.hpp	/^template <class C, class Tr, class R> static basic_ostream<C, Tr>& operator <<(basic_ostream<C, Tr>& out, const R& r)$/;"	f
operator <<	.\src\Helpers.hpp	/^template<class T1, class T2, class T3, class T4, class T5> static ostream& operator << (ostream& out, const tuple<T1, T2, T3, T4, T5>& t)$/;"	f
operator <<	.\src\Helpers.hpp	/^template<class T1, class T2, class T3, class T4> static ostream& operator << (ostream& out, const tuple<T1, T2, T3, T4>& t)$/;"	f
operator <<	.\src\Helpers.hpp	/^template<class T1, class T2, class T3, class T4> static ostream& operator <<(ostream& out, const boost::bimaps::relation::structured_pair<T1, T2, T3, T4>& p)$/;"	f
operator <<	.\src\Helpers.hpp	/^template<class T1, class T2, class T3> static ostream& operator << (ostream& out, const tuple<T1, T2, T3>& t)$/;"	f
operator <<	.\src\Helpers.hpp	/^template<class T1, class T2> static ostream& operator << (ostream& out, const bimap<T1, T2>& m)$/;"	f
operator <<	.\src\Helpers.hpp	/^template<class T1, class T2> static ostream& operator << (ostream& out, const pair<T1, T2>& p)$/;"	f
operator <<	.\src\Helpers.hpp	/^template<class T1, class T2> static ostream& operator << (ostream& out, const tuple<T1, T2>& t)$/;"	f
operator <<	.\src\Helpers.hpp	/^template<class T1, class T2> static ostream& operator <<(ostream& out, const map<T1, T2*>& m)$/;"	f
operator <<	.\src\Helpers.hpp	/^template<class T1, class T2> static ostream& operator <<(ostream& out, const map<T1, T2>& m)$/;"	f
operator <<	.\src\Layer.hpp	/^ostream& operator << (ostream& out, const Layer& l)$/;"	f
operator <<	.\src\Log.hpp	/^template<class T> ostream& operator <<(ostream& out, const Log<T>& l)$/;"	f
operator <<	.\src\Mdrnn.hpp	/^ostream& operator << (ostream& out, const Mdrnn& net)$/;"	f
operator <<	.\src\Named.hpp	/^static ostream& operator << (ostream& out, const Named& n)$/;"	f
operator <<	.\src\NetcdfDataset.hpp	/^static ostream& operator << (ostream& out, const DataHeader& dh)$/;"	f
operator <<	.\src\NetcdfDataset.hpp	/^static ostream& operator << (ostream& out, const DataList& dl)$/;"	f
operator <<	.\src\NetcdfDataset.hpp	/^static ostream& operator << (ostream& out, const NetcdfDataset& d)$/;"	f
operator <<	.\src\Optimiser.hpp	/^ostream& operator << (ostream& out, const Optimiser& o)$/;"	f
operator <<	.\src\SeqBuffer.hpp	/^template <class T> static ostream& operator <<(ostream& out, const SeqBuffer<T>& a)$/;"	f
operator <=	.\src\Log.hpp	/^template<class T> bool operator <=(Log<T> log1, Log<T> log2)$/;"	f
operator =	.\src\Container.hpp	/^	template<class R> Vector<T>& operator =(const R& r)$/;"	f	struct:Vector
operator =	.\src\Container.hpp	/^	template<class R> const View<T>& operator =(const R& r) const$/;"	f	struct:View
operator =	.\src\Container.hpp	/^  	template<class R> Set<T>& operator =(const R& r)$/;"	f	struct:Set
operator =	.\src\Log.hpp	/^	Log<T>& operator =(const Log<T>& l)$/;"	f	class:Log
operator =	.\src\MultiArray.hpp	/^	template<class T2> MultiArray<T>& operator=(const MultiArray<T2>& a)$/;"	f	struct:MultiArray
operator =	.\src\SeqBuffer.hpp	/^	template<class T2> SeqBuffer<T>& operator =(const SeqBuffer<T2>& a)$/;"	f	struct:SeqBuffer
operator ==	.\src\Log.hpp	/^template<class T> bool operator ==(Log<T> log1, Log<T> log2)$/;"	f
operator ==	.\src\MultiArray.hpp	/^template <class T> static bool operator ==(const MultiArray<T>& a, const MultiArray<T>& b)$/;"	f
operator >	.\src\Log.hpp	/^template<class T> bool operator >(Log<T> log1, Log<T> log2)$/;"	f
operator >=	.\src\Log.hpp	/^template<class T> bool operator >=(Log<T> log1, Log<T> log2)$/;"	f
operator >>	.\src\DataExporter.hpp	/^static istream& operator >>(istream& in, Val& v)$/;"	f
operator >>	.\src\Helpers.hpp	/^template <class C, class Tr, class R> static basic_istream<C, Tr>& operator >>(basic_istream<C, Tr>& in, R& r)$/;"	f
operator >>	.\src\Log.hpp	/^template<class T> istream& operator >>(istream& in, Log<T>& l)$/;"	f
operator []	.\src\MultiArray.hpp	/^	const View<T> operator[](const vector<int>& coords)$/;"	f	struct:MultiArray
operator []	.\src\MultiArray.hpp	/^	const View<const T> operator[](const vector<int>& coords) const$/;"	f	struct:MultiArray
operator []	.\src\NetcdfDataset.hpp	/^	DataSequence& operator[](int n)$/;"	f	struct:NetcdfDataset
operator []	.\src\SeqBuffer.hpp	/^	const View<T> operator[](int coord)$/;"	f	struct:SeqBuffer
operator []	.\src\SeqBuffer.hpp	/^	const View<const T> operator[](int coord) const$/;"	f	struct:SeqBuffer
optimiser	.\src\Trainer.hpp	/^	Optimiser* optimiser;$/;"	m	struct:Trainer
ordinal	.\src\String.hpp	/^static string ordinal(size_t n)$/;"	f
os	.\examples\arabic_online_handwriting\arabic_online.py	/^import os$/;"	i
out	.\src\ClassificationLayer.hpp	/^	ostream& out;$/;"	m	struct:ClassificationLayer
out	.\src\GradientCheck.hpp	/^	ostream& out;$/;"	m	struct:GradientCheck
out	.\src\Mdrnn.hpp	/^	ostream& out;$/;"	m	struct:Mdrnn
out	.\src\Rprop.hpp	/^	ostream& out;$/;"	m	struct:Rprop
out	.\src\SteepestDescent.hpp	/^	ostream& out;$/;"	m	struct:SteepestDescent
out	.\src\Trainer.hpp	/^	ostream& out;$/;"	m	struct:Trainer
out	.\src\TranscriptionLayer.hpp	/^	ostream& out;$/;"	m	struct:TranscriptionLayer
out	.\utils\dump_weight_matrices.py	/^			out = open(config + '_' + connStr, 'w')$/;"	v
out	.\utils\dump_weights.py	/^			out = open(config + '_' + connNameStr, 'w')$/;"	v
out	.\utils\max_jacobian.py	/^out = file(outfile, 'w')$/;"	v
out	.\utils\shuffle_and_split.py	/^	out = file(outroot + '_' + str(i).rjust(numDigits, '0') + '.txt', 'w')$/;"	v
outGateActs	.\src\LstmLayer.hpp	/^	SeqBuffer<real_t> outGateActs;$/;"	m	struct:LstmLayer
outSeqShape	.\src\BlockLayer.hpp	/^	vector<size_t> outSeqShape;$/;"	m	struct:BlockLayer
outSeqShape	.\src\CollapseLayer.hpp	/^	vector<size_t> outSeqShape;$/;"	m	struct:CollapseLayer
out_acts	.\src\BiasLayer.hpp	/^	const View<real_t> out_acts(const vector<int>& coords)$/;"	f	struct:BiasLayer
out_acts	.\src\Layer.hpp	/^	virtual const View<real_t> out_acts(const vector<int>& coords)$/;"	f	struct:Layer
out_errs	.\src\BiasLayer.hpp	/^	const View<real_t> out_errs(const vector<int>& coords)$/;"	f	struct:BiasLayer
out_errs	.\src\Layer.hpp	/^	virtual const View<real_t> out_errs(const vector<int>& coords)$/;"	f	struct:Layer
outactsfile	.\utils\max_jacobian.py	/^outactsfile = args[1]$/;"	v
outer	.\src\Matrix.hpp	/^static void outer(const real_t *aBegin, const real_t *aEnd, real_t *M, const real_t *b, const real_t *bEnd)$/;"	f
outer	.\src\Matrix.hpp	/^template<class R> static void outer(const R& a, real_t *M, const R&b)$/;"	f
outer_a_squared	.\src\Matrix.hpp	/^static void outer_a_squared(const real_t *aBegin, const real_t *aEnd, real_t *M, const real_t *b, const real_t *bEnd)$/;"	f
outer_a_squared	.\src\Matrix.hpp	/^template<class R> static void outer_a_squared(const R& a, real_t *M, const R&b)$/;"	f
outfile	.\utils\max_jacobian.py	/^outfile = args[2]$/;"	v
outfile	.\utils\normalise_netcdf.py	/^outfile = netcdf_helpers.NetCDFFile(outputFilename, 'w')$/;"	v
output	.\src\BiasLayer.hpp	/^	void output() {$/;"	f	struct:BiasLayer
output	.\src\BlockLayer.hpp	/^	void output() {$/;"	f	struct:BlockLayer
output	.\src\CollapseLayer.hpp	/^	void output() {$/;"	f	struct:CollapseLayer
output	.\src\GatherLayer.hpp	/^	void output() {$/;"	f	struct:GatherLayer
output	.\src\IdentityLayer.hpp	/^	void output() {$/;"	f	struct:IdentityLayer
output	.\src\InputLayer.hpp	/^	void output() {$/;"	f	struct:InputLayer
output	.\src\Layer.hpp	/^	virtual void output() {$/;"	f	struct:FlatLayer
output	.\src\Layer.hpp	/^	virtual void output() {$/;"	f	struct:Layer
output	.\src\LstmLayer.hpp	/^	void output() {$/;"	f	struct:LstmLayer
output	.\src\NeuronLayer.hpp	/^	void output() {$/;"	f	struct:NeuronLayer
output	.\src\SoftmaxLayer.hpp	/^	virtual void output() {$/;"	f	struct:SoftmaxLayer
output	.\src\TranscriptionLayer.hpp	/^	void output() {$/;"	f	struct:TranscriptionLayer
output	.\utils\max_jacobian.py	/^	output = int(f.split('\/')[-2].split('_')[-1])$/;"	v
outputActivations	.\src\Layer.hpp	/^	SeqBuffer<real_t> outputActivations;$/;"	m	struct:Layer
outputArray	.\utils\normalise_netcdf.py	/^	outputArray = inputVar.getValue()$/;"	v
outputArray	.\utils\normalise_netcdf.py	/^outputArray = zeros(inputVar.shape, 'f')$/;"	v
outputErrors	.\src\Layer.hpp	/^	SeqBuffer<real_t> outputErrors;$/;"	m	struct:Layer
outputFilename	.\examples\arabic_offline_handwriting\arabic_offline.py	/^outputFilename = args[1]$/;"	v
outputFilename	.\utils\normalise_netcdf.py	/^outputFilename = args[1]$/;"	v
outputLabelSeq	.\src\TranscriptionLayer.hpp	/^	vector<int> outputLabelSeq;$/;"	m	struct:TranscriptionLayer
outputLayers	.\src\Mdrnn.hpp	/^	vector<Layer*> outputLayers;$/;"	m	struct:Mdrnn
outputSize	.\src\NetcdfDataset.hpp	/^	size_t outputSize;$/;"	m	struct:DataHeader
output_class	.\src\ClassificationLayer.hpp	/^	int output_class(int pt) const$/;"	f	struct:BinaryClassificationLayer
output_class	.\src\ClassificationLayer.hpp	/^	int output_class(int pt) const$/;"	f	struct:MulticlassClassificationLayer
output_seq_begin	.\src\Layer.hpp	/^	virtual SeqIterator output_seq_begin() const$/;"	f	struct:Layer
output_seq_shape	.\src\Layer.hpp	/^	virtual const View<const size_t> output_seq_shape() const$/;"	f	struct:Layer
output_size	.\src\Layer.hpp	/^	virtual size_t output_size() const$/;"	f	struct:Layer
outputs	.\src\ClassificationLayer.hpp	/^	vector<int> outputs;$/;"	m	struct:ClassificationLayer
outputs	.\src\Mdrnn.hpp	/^	vector<NetworkOutput*> outputs;$/;"	m	struct:Mdrnn
outroot	.\utils\shuffle_and_split.py	/^outroot = args[2]$/;"	v
padDims	.\examples\farsi_offline_handwriting\farsi_chars.py	/^padDims = (95, 77)$/;"	v
pair_mean	.\src\Helpers.hpp	/^template<class T1, class T2> static real_t pair_mean(const pair<T1, T2>& p)$/;"	f
pair_product	.\src\Helpers.hpp	/^template<class T1, class T2> static real_t pair_product(const pair<T1, T2>& p)$/;"	f
pair_sum	.\src\Helpers.hpp	/^template<class T1, class T2> static real_t pair_sum(const pair<T1, T2>& p)$/;"	f
param	.\src\DataExporter.hpp	/^	T& param;$/;"	m	struct:ParamVal
paramRange	.\src\FullConnection.hpp	/^	pair<size_t, size_t> paramRange;$/;"	m	struct:FullConnection
params	.\src\ConfigFile.hpp	/^	map<string, string> params;$/;"	m	struct:ConfigFile
parse	.\examples\arabic_online_handwriting\arabic_online.py	/^from xml.dom.minidom import parse$/;"	i
parser	.\examples\arabic_offline_handwriting\arabic_offline.py	/^parser = OptionParser()$/;"	v
parser	.\examples\arabic_online_handwriting\arabic_online.py	/^parser = OptionParser()$/;"	v
parser	.\examples\farsi_offline_handwriting\farsi_chars.py	/^parser = OptionParser()$/;"	v
parser	.\utils\dump_weight_matrices.py	/^parser = OptionParser(usage='Usage: %prog [options] <save_file>')$/;"	v
parser	.\utils\dump_weights.py	/^parser = OptionParser(usage='Usage: %prog [options] <save_file>')$/;"	v
parser	.\utils\max_jacobian.py	/^parser = OptionParser(usage)$/;"	v
parser	.\utils\min_max.py	/^parser = OptionParser(usage)$/;"	v
parser	.\utils\normalise_netcdf.py	/^parser = OptionParser("usage: %prog input_filename output_filename")$/;"	v
parser	.\utils\plot_errors.py	/^parser = OptionParser(usage)$/;"	v
parser	.\utils\plot_variables.py	/^parser = OptionParser(usage)$/;"	v
parser	.\utils\plot_weights.py	/^parser = OptionParser(usage='Usage: %prog [options] <save_file>')$/;"	v
parser	.\utils\rescale_netcdf_binary_inputs.py	/^parser = OptionParser("usage: %prog netcdf_filename")$/;"	v
parser	.\utils\shuffle_and_split.py	/^parser = OptionParser("usage: %prog [options] input_file split_fractions output_root")$/;"	v
path_to_string	.\src\TranscriptionLayer.hpp	/^	vector<int>& path_to_string(const vector<int>& path) const$/;"	f	struct:TranscriptionLayer
pcolorLine	.\utils\plot_variables.py	/^def pcolorLine(line, gridDims):$/;"	f
peepRange	.\src\LstmLayer.hpp	/^	pair<size_t, size_t> peepRange;$/;"	m	struct:LstmLayer
peepSource	.\src\LstmLayer.hpp	/^	LstmLayer<CI,CO,G>* peepSource;$/;"	m	struct:LstmLayer
peepsPerBlock	.\src\LstmLayer.hpp	/^	size_t peepsPerBlock;$/;"	m	struct:LstmLayer
percentErrors	.\src\DatasetErrors.hpp	/^	static set<string> percentErrors;$/;"	m	struct:DatasetErrors
percentErrors	.\src\DatasetErrors.hpp	/^set<string> DatasetErrors::percentErrors = list_of("classificationError")("wordError")("labelError")("seqError")("deletions")("insertions")("substitutions")("ratio");$/;"	m	class:DatasetErrors
percent_error	.\src\DatasetErrors.hpp	/^	bool percent_error(const string& err) const$/;"	f	struct:DatasetErrors
perturb_weight	.\src\WeightContainer.hpp	/^void perturb_weight(real_t& weight, real_t stdDev, bool additive = true)$/;"	f
perturb_weights	.\src\WeightContainer.hpp	/^template <class R> void perturb_weights(R& weights, R& stdDevs, bool additive = true)$/;"	f
perturb_weights	.\src\WeightContainer.hpp	/^template <class R> void perturb_weights(R& weights, real_t stdDev, bool additive = true)$/;"	f
perturbation	.\src\GradientCheck.hpp	/^	real_t perturbation;$/;"	m	struct:GradientCheck
pop_front	.\src\Container.hpp	/^	T& pop_front()$/;"	f	struct:Vector
preGateStates	.\src\LstmLayer.hpp	/^	SeqBuffer<real_t> preGateStates;$/;"	m	struct:LstmLayer
preOutGateActs	.\src\LstmLayer.hpp	/^	SeqBuffer<real_t> preOutGateActs;$/;"	m	struct:LstmLayer
prevAvgDelta	.\src\Rprop.hpp	/^	real_t prevAvgDelta;$/;"	m	struct:Rprop
prevDerivs	.\src\Rprop.hpp	/^	vector<real_t> prevDerivs;$/;"	m	struct:Rprop
prevMaxNum	.\utils\plot_variables.py	/^					prevMaxNum = maxNum$/;"	v
prevMaxNum	.\utils\plot_variables.py	/^		prevMaxNum = -1$/;"	v
print	.\src\BlockLayer.hpp	/^	void print(ostream& out = cout) const$/;"	f	struct:BlockLayer
print	.\src\Connection.hpp	/^	virtual void print(ostream& out) const{}$/;"	f	struct:Connection
print	.\src\CopyConnection.hpp	/^	void print(ostream& out) const$/;"	f	struct:CopyConnection
print	.\src\DataExporter.hpp	/^	void print(ostream& out) const$/;"	f	struct:ParamVal
print	.\src\DataExporter.hpp	/^	void print(ostream& out) const$/;"	f	struct:RangeVal
print	.\src\DataExporter.hpp	/^	void print(ostream& out) const$/;"	f	struct:SeqBufferVal
print	.\src\DataSequence.hpp	/^	void print(ostream& out, vector<string>* targetLabels = 0, vector<string>* inputLabels = 0) const$/;"	f	struct:DataSequence
print	.\src\DatasetErrors.hpp	/^	void print(ostream& out) const$/;"	f	struct:DatasetErrors
print	.\src\FullConnection.hpp	/^	void print(ostream& out) const$/;"	f	struct:FullConnection
print	.\src\Helpers.hpp	/^template<class T1, class T2, class T3, class T4, class T5> static void print(const T1& t1, const T2& t2, const T3& t3, const T4& t4, const T5& t5, ostream& out = cout)$/;"	f
print	.\src\Helpers.hpp	/^template<class T1, class T2, class T3, class T4> static void print(const T1& t1, const T2& t2, const T3& t3, const T4& t4, ostream& out = cout)$/;"	f
print	.\src\Helpers.hpp	/^template<class T1, class T2, class T3> static void print(const T1& t1, const T2& t2, const T3& t3, ostream& out = cout)$/;"	f
print	.\src\Helpers.hpp	/^template<class T1, class T2> static void print(const T1& t1, const T2& t2, ostream& out = cout)$/;"	f
print	.\src\Helpers.hpp	/^template<class T> static void print(const T& t, ostream& out = cout)$/;"	f
print	.\src\Layer.hpp	/^	virtual void print(ostream& out = cout) const$/;"	f	struct:Layer
print	.\src\LstmLayer.hpp	/^	void print(ostream& out = cout) const$/;"	f	struct:LstmLayer
print	.\src\Mdrnn.hpp	/^	virtual void print(ostream& out = cout) const$/;"	f	struct:Mdrnn
print	.\src\Named.hpp	/^	void print(ostream& out = cout) const$/;"	f	struct:Named
print	.\src\NetcdfDataset.hpp	/^	void print(ostream& out = cout) const$/;"	f	struct:DataList
print	.\src\NetcdfDataset.hpp	/^	void print(ostream& out) const$/;"	f	struct:DataHeader
print	.\src\NetcdfDataset.hpp	/^	void print(ostream& out) const$/;"	f	struct:NetcdfDataset
print	.\src\Rprop.hpp	/^	void print(ostream& out = cout) const$/;"	f	struct:Rprop
print	.\src\SeqBuffer.hpp	/^	void print(ostream& out) const$/;"	f	struct:SeqBuffer
print	.\src\SteepestDescent.hpp	/^	void print(ostream& out = cout) const$/;"	f	struct:SteepestDescent
printErrorHelpAndExit	.\utils\dump_sequence_variables.sh	/^printErrorHelpAndExit()$/;"	f
printErrorHelpAndExit	.\utils\error_test.sh	/^printErrorHelpAndExit()$/;"	f
printErrorHelpAndExit	.\utils\gradient_check.sh	/^printErrorHelpAndExit()$/;"	f
printErrorHelpAndExit	.\utils\jacobian.sh	/^printErrorHelpAndExit()$/;"	f
printErrorHelpAndExit	.\utils\normalise_netcdf.sh	/^printErrorHelpAndExit()$/;"	f
printHelpAndExit	.\utils\dump_sequence_variables.sh	/^printHelpAndExit()$/;"	f
printHelpAndExit	.\utils\error_test.sh	/^printHelpAndExit()$/;"	f
printHelpAndExit	.\utils\gradient_check.sh	/^printHelpAndExit()$/;"	f
printHelpAndExit	.\utils\jacobian.sh	/^printHelpAndExit()$/;"	f
printHelpAndExit	.\utils\normalise_netcdf.sh	/^printHelpAndExit()$/;"	f
print_best_errors	.\src\Trainer.hpp	/^	void print_best_errors(const string& name, const map<string, pair<int, DatasetErrors> >& bestErrors) const$/;"	f	struct:Trainer
print_bimap	.\src\Helpers.hpp	/^template<class T1, class T2> void print_bimap (const bimap<T1, T2>& m, ostream& out)$/;"	f
print_datasets	.\src\Trainer.hpp	/^	void print_datasets() const$/;"	f	struct:Trainer
print_distortions	.\src\Trainer.hpp	/^	bool print_distortions()$/;"	f	struct:Trainer
print_left	.\src\Helpers.hpp	/^template<class T1, class T2> static void print_left(const map<T1, T2>& m, ostream& out = cout, const char delim = ' ')$/;"	f
print_output_shape	.\src\Mdrnn.hpp	/^	virtual void print_output_shape(ostream& out = cout) const$/;"	f	struct:Mdrnn
print_range	.\src\Helpers.hpp	/^template <class C, class Tr, class R> static void print_range(basic_ostream<C, Tr>& out, const R& r, const basic_string<C, Tr>& delim = " ")$/;"	f
print_range	.\src\Helpers.hpp	/^template <class C, class Tr, class R> static void print_range(basic_ostream<C, Tr>& out, const R& r, const char delim)$/;"	f
print_right	.\src\Helpers.hpp	/^template<class T1, class T2> static void print_right(const map<T1, T2>& m, ostream& out = cout, const char delim = ' ')$/;"	f
print_time	.\src\Helpers.hpp	/^static void print_time(real_t totalSeconds, ostream& out = cout, bool abbrv = false)$/;"	f
prior_label_prob	.\src\TranscriptionLayer.hpp	/^	virtual const Log<real_t>& prior_label_prob(int label)$/;"	f	struct:TranscriptionLayer
prob_t	.\src\Helpers.hpp	/^typedef Log<real_t> prob_t;$/;"	t
product	.\src\Helpers.hpp	/^template <class R> static typename range_value<R>::type product(const R& r)$/;"	f
prt_line	.\src\Helpers.hpp	/^static void prt_line(ostream& out = cout)$/;"	f
pt	.\examples\arabic_online_handwriting\arabic_online.py	/^				pt = coords.split()$/;"	v
pt	.\src\SeqBuffer.hpp	/^	vector<int> pt;			\/\/ shape 的 size : 目前的位置$/;"	m	struct:CoordIterator
push_front	.\src\Container.hpp	/^	void push_front(const T& t)$/;"	f	struct:Vector
r	.\utils\plot_variables.py	/^			r = data[::3]$/;"	v
random	.\utils\shuffle_and_split.py	/^import random$/;"	i
randomise	.\src\WeightContainer.hpp	/^	int randomise(real_t range)$/;"	f	struct:WeightContainer
range	.\src\DataExporter.hpp	/^	R range;$/;"	m	struct:RangeVal
range	.\utils\plot_weights.py	/^	range = [float(f) for f in opt.range.split()]$/;"	v
range	.\utils\plot_weights.py	/^range = None$/;"	v
range_divide	.\src\Helpers.hpp	/^template<class R1, class R2, class R3> static void range_divide(R1& a, const R2& b, const R3& c)$/;"	f
range_divide_equals	.\src\Helpers.hpp	/^template<class R1, class R2> static void range_divide_equals(R1& a, const R2& b)$/;"	f
range_divide_val	.\src\Helpers.hpp	/^template<class R1, class R2> static void range_divide_val(R1& a, const R2& b, const typename boost::range_value<R1>::type& c)$/;"	f
range_divide_val	.\src\Helpers.hpp	/^template<class R> static void range_divide_val(R& a, const typename boost::range_value<R>::type& b)$/;"	f
range_indep_gauss_pdf	.\src\Helpers.hpp	/^template<class T, class R1, class R2, class R3> static T range_indep_gauss_pdf(const R1& variables, const R2& means, const R3& stdDevs)$/;"	f
range_min_size	.\src\Helpers.hpp	/^template<class R1, class R2, class R3, class R4, class R5> static size_t range_min_size (const R1& a, const R2& b, const R3& c, const R4& d, const R5& e)$/;"	f
range_min_size	.\src\Helpers.hpp	/^template<class R1, class R2, class R3, class R4> static size_t range_min_size (const R1& a, const R2& b, const R3& c, const R4& d)$/;"	f
range_min_size	.\src\Helpers.hpp	/^template<class R1, class R2, class R3> static size_t range_min_size (const R1& a, const R2& b, const R3& c)$/;"	f
range_min_size	.\src\Helpers.hpp	/^template<class R1, class R2> static size_t range_min_size (const R1& a, const R2& b)$/;"	f
range_minus	.\src\Helpers.hpp	/^template<class R1, class R2, class R3> static void range_minus(R1& a, const R2& b, const R3& c)$/;"	f
range_minus_equals	.\src\Helpers.hpp	/^template<class R1, class R2> static void range_minus_equals(R1& a, const R2& b)$/;"	f
range_minus_val	.\src\Helpers.hpp	/^template<class R1, class R2> static void range_minus_val(R1& a, const R2& b, const typename boost::range_value<R2>::type& c)$/;"	f
range_minus_val	.\src\Helpers.hpp	/^template<class R> static void range_minus_val(R& a, const typename boost::range_value<R>::type& b)$/;"	f
range_multiply	.\src\Helpers.hpp	/^template<class R1, class R2, class R3> static void range_multiply(R1& a, const R2& b, const R3& c)$/;"	f
range_multiply_add	.\src\Helpers.hpp	/^template<class R1, class R2, class R3> static void range_multiply_add(R1& a, const R2& b, const R3& c)$/;"	f
range_multiply_equals	.\src\Helpers.hpp	/^template<class R1, class R2> static void range_multiply_equals(R1& a, const R2& b)$/;"	f
range_multiply_val	.\src\Helpers.hpp	/^template<class R1, class R2> static void range_multiply_val(R1& a, const R2& b, const typename boost::range_value<R2>::type& c)$/;"	f
range_multiply_val	.\src\Helpers.hpp	/^template<class R> static void range_multiply_val(R& a, const typename boost::range_value<R>::type& b)$/;"	f
range_negate	.\src\Helpers.hpp	/^template<class R> static vector<typename boost::range_value<R>::type>& range_negate(const R& r)$/;"	f
range_negate_equals	.\src\Helpers.hpp	/^template<class R> static void range_negate_equals(R& r)$/;"	f
range_plus	.\src\Helpers.hpp	/^template<class R1, class R2, class R3> static R1& range_plus(R1& a, const R2& b, const R3& c)$/;"	f
range_plus_equals	.\src\Helpers.hpp	/^template<class R1, class R2> static void range_plus_equals(R1& a, const R2& b)$/;"	f
range_plus_val	.\src\Helpers.hpp	/^template<class R1, class R2> static void range_plus_val(R1& a, const R2& b, const typename boost::range_value<R2>::type& c)$/;"	f
range_plus_val	.\src\Helpers.hpp	/^template<class R> static void range_plus_val(R& a, const typename boost::range_value<R>::type& b)$/;"	f
rbegin	.\src\SeqBuffer.hpp	/^	SeqIterator rbegin(const vector<int>& dirs = empty_list_of<int>()) const$/;"	f	struct:SeqBuffer
re	.\examples\arabic_offline_handwriting\arabic_offline.py	/^import re$/;"	i
re	.\utils\dump_weight_matrices.py	/^import re$/;"	i
re	.\utils\dump_weights.py	/^import re$/;"	i
re	.\utils\plot_errors.py	/^import re$/;"	i
read	.\src\Helpers.hpp	/^template<class T> static T read(const string& data)$/;"	f
real	.\src\Helpers.hpp	/^template<class T> static real_t real(const T& t)$/;"	f
realMax	.\src\Helpers.hpp	/^static const real_t realMax = numeric_limits<real_t>::max();$/;"	v
realMin	.\src\Helpers.hpp	/^static const real_t realMin = numeric_limits<real_t>::min();$/;"	v
real_t	.\src\Helpers.hpp	/^typedef float real_t;$/;"	t
recurrentLayers	.\src\Mdrnn.hpp	/^	vector<Layer*> recurrentLayers;$/;"	m	struct:Mdrnn
regularise	.\src\Trainer.hpp	/^	void regularise(real_t scaleFactor = 1)$/;"	f	struct:Trainer
remove	.\src\ConfigFile.hpp	/^	bool remove(const string& name)$/;"	f	struct:ConfigFile
replicate	.\src\Container.hpp	/^	Vector<T> replicate(size_t times) const$/;"	f	struct:Vector
reset_derivs	.\src\Trainer.hpp	/^	void reset_derivs()$/;"	f	struct:Trainer
reset_derivs	.\src\WeightContainer.hpp	/^	void reset_derivs()$/;"	f	struct:WeightContainer
reshape	.\src\MultiArray.hpp	/^	template<class R> void reshape(const R& dims, const T& fillVal)$/;"	f	struct:MultiArray
reshape	.\src\MultiArray.hpp	/^	template<class R> void reshape(const R& newShape)$/;"	f	struct:MultiArray
reshape	.\src\SeqBuffer.hpp	/^	template<class R> void reshape(const R& newSeqShap, const T& fillval)$/;"	f	struct:SeqBuffer
reshape	.\src\SeqBuffer.hpp	/^	template<class R> void reshape(const R& newSeqShape)$/;"	f	struct:SeqBuffer
reshape	.\src\SeqBuffer.hpp	/^	template<class T2> void reshape(const SeqBuffer<T2>& buff)$/;"	f	struct:SeqBuffer
reshape	.\src\SeqBuffer.hpp	/^	template<class T2> void reshape(const SeqBuffer<T2>& buff, const T& fillVal)$/;"	f	struct:SeqBuffer
reshape_errors	.\src\Layer.hpp	/^	virtual void reshape_errors()$/;"	f	struct:Layer
reshape_with_depth	.\src\SeqBuffer.hpp	/^	template<class R> void reshape_with_depth(const R& newSeqShap, size_t dep)$/;"	f	struct:SeqBuffer
reshape_with_depth	.\src\SeqBuffer.hpp	/^	template<class R> void reshape_with_depth(const R& newSeqShap, size_t dep, const T& fillval)$/;"	f	struct:SeqBuffer
resize_data	.\src\MultiArray.hpp	/^	virtual void resize_data()$/;"	f	struct:MultiArray
reverse	.\src\Helpers.hpp	/^template <class R> static void reverse(R& r)$/;"	f
reverse_copy	.\src\Helpers.hpp	/^template<class R1, class R2> static void reverse_copy(const R1& source, R2& dest)$/;"	f
reverse_sort	.\src\Helpers.hpp	/^template <class R> static R& reverse_sort(R& r)$/;"	f
revert_distortions	.\src\Trainer.hpp	/^	const void revert_distortions()$/;"	f	struct:Trainer
rgbDevs	.\utils\plot_variables.py	/^			rgbDevs = numpy.array(opt.rgbDevs.split(',')).astype(float)$/;"	v
rgbMeans	.\utils\plot_variables.py	/^			rgbMeans = numpy.array(opt.rgbMeans.split(',')).astype(float)$/;"	v
runningGradTest	.\src\Helpers.hpp	/^static bool runningGradTest = false;$/;"	v
safe_exp	.\src\Log.hpp	/^	static T safe_exp(T x)$/;"	f	class:Log
safe_log	.\src\Log.hpp	/^	static T safe_log(T x)$/;"	f	class:Log
save	.\src\DataExporter.cpp	/^void DataExportHandler::save(ostream& out) const$/;"	f	class:DataExportHandler
save	.\src\DataExporter.hpp	/^	template<typename T> void save(T& param, const string& name)$/;"	f	struct:DataExporter
save	.\src\DataExporter.hpp	/^	void save(ostream& out) const$/;"	f	struct:DataExporter
saveVals	.\src\DataExporter.hpp	/^	map<string, Val*> saveVals;$/;"	m	struct:DataExporter
save_by_conns	.\src\WeightContainer.hpp	/^	void save_by_conns(vector<real_t>& container, const string& nam)$/;"	f	struct:WeightContainer
save_data	.\src\Trainer.hpp	/^	void save_data(const string& filename, ConfigFile& conf)$/;"	f	struct:Trainer
save_range	.\src\DataExporter.hpp	/^	template<typename R> void save_range(const R& range, const string& name)$/;"	f	struct:DataExporter
second_deriv	.\src\ActivationFunctions.hpp	/^	static real_t second_deriv(real_t y)$/;"	f	struct:Identity
second_deriv	.\src\ActivationFunctions.hpp	/^	static real_t second_deriv(real_t y)$/;"	f	struct:Logistic
second_deriv	.\src\ActivationFunctions.hpp	/^	static real_t second_deriv(real_t y)$/;"	f	struct:Max2min0
second_deriv	.\src\ActivationFunctions.hpp	/^	static real_t second_deriv(real_t y)$/;"	f	struct:Maxmin1
second_deriv	.\src\ActivationFunctions.hpp	/^	static real_t second_deriv(real_t y)$/;"	f	struct:Maxmin2
second_deriv	.\src\ActivationFunctions.hpp	/^	static real_t second_deriv(real_t y)$/;"	f	struct:Softsign
second_deriv	.\src\ActivationFunctions.hpp	/^	static real_t second_deriv(real_t y)$/;"	f	struct:Tanh
segment_range	.\src\TranscriptionLayer.hpp	/^	integer_range<int> segment_range(int time, int totalSegs = -1) const $/;"	f	struct:TranscriptionLayer
select_channels	.\src\Helpers.hpp	/^template <class R1, class R2> static vector<typename boost::range_value<R1>::type>& select_channels(const R1& r, const R2& channels)$/;"	f
seq	.\src\GradientCheck.hpp	/^	const DataSequence& seq;$/;"	m	struct:GradientCheck
seq	.\src\NetcdfDataset.hpp	/^	DataSequence* seq;$/;"	m	struct:DataList
seqDims	.\examples\arabic_offline_handwriting\arabic_offline.py	/^seqDims = []$/;"	v
seqDims	.\examples\arabic_online_handwriting\arabic_online.py	/^seqDims = []$/;"	v
seqDims	.\examples\farsi_offline_handwriting\farsi_chars.py	/^seqDims = []$/;"	v
seqIndex	.\src\NetcdfDataset.hpp	/^	int seqIndex;$/;"	m	struct:DataList
seqLengths	.\examples\arabic_offline_handwriting\arabic_offline.py	/^seqLengths = []$/;"	v
seqLengths	.\examples\arabic_online_handwriting\arabic_online.py	/^seqLengths = []$/;"	v
seqLengths	.\examples\farsi_offline_handwriting\farsi_chars.py	/^seqLengths = []$/;"	v
seqTags	.\examples\arabic_offline_handwriting\arabic_offline.py	/^seqTags = []$/;"	v
seqTags	.\examples\arabic_online_handwriting\arabic_online.py	/^seqTags = []$/;"	v
seqTags	.\examples\farsi_offline_handwriting\farsi_chars.py	/^seqTags = []$/;"	v
seq_means	.\src\SeqBuffer.hpp	/^	vector<real_t>& seq_means() const$/;"	f	struct:SeqBuffer
seq_offset	.\src\SeqBuffer.hpp	/^	int seq_offset(const vector<int>& coords)$/;"	f	struct:SeqBuffer
seq_shape	.\src\SeqBuffer.hpp	/^	const View<const size_t> seq_shape() const$/;"	f	struct:SeqBuffer
seq_size	.\src\SeqBuffer.hpp	/^	size_t seq_size() const$/;"	f	struct:SeqBuffer
seq_to_offset	.\src\NetcdfDataset.hpp	/^	pair<int,int> seq_to_offset(int seqNum) const$/;"	f	struct:NetcdfDataset
seqsPerWeightUpdate	.\src\Trainer.hpp	/^	int seqsPerWeightUpdate;$/;"	m	struct:Trainer
sequences	.\src\NetcdfDataset.hpp	/^	vector<DataSequence*> sequences;$/;"	m	struct:NetcdfDataset
set_delay	.\src\FullConnection.hpp	/^	void set_delay(const vector<int>& d)$/;"	f	struct:FullConnection
set_error	.\src\ClassificationLayer.hpp	/^	real_t set_error(int pt, int targetClass)$/;"	f	struct:BinaryClassificationLayer
set_error	.\src\ClassificationLayer.hpp	/^	real_t set_error(int pt, int targetClass)$/;"	f	struct:MulticlassClassificationLayer
set_seed	.\src\Random.cpp	/^unsigned int Random::set_seed(unsigned int seed)$/;"	f	class:Random
set_val	.\src\ConfigFile.hpp	/^	template<class T> const T& set_val(const string& name, const T& val, bool valUsed = true)$/;"	f	struct:ConfigFile
shape	.\src\MultiArray.hpp	/^	Vector<size_t> shape;$/;"	m	struct:MultiArray
shape	.\src\SeqBuffer.hpp	/^	Vector<size_t> shape;	\/\/ Shape 3,4 : 走的區塊大小$/;"	m	struct:CoordIterator
shrink	.\src\Container.hpp	/^	Vector<T>& shrink(size_t length)$/;"	f	struct:Vector
shuffle	.\src\Helpers.hpp	/^template<class R> static R& shuffle (R& r)$/;"	f
shuffle_sequences	.\src\NetcdfDataset.hpp	/^	void shuffle_sequences()$/;"	f	struct:NetcdfDataset
shuffled	.\src\NetcdfDataset.hpp	/^	bool shuffled;$/;"	m	struct:DataList
sigFigs	.\src\GradientCheck.hpp	/^	unsigned sigFigs;$/;"	m	struct:GradientCheck
sign	.\src\Helpers.hpp	/^template<class T> static int sign(const T& t)$/;"	f
size	.\src\MultiArray.hpp	/^	virtual size_t size() const$/;"	f	struct:MultiArray
size	.\src\NetcdfDataset.hpp	/^	int size() const$/;"	f	struct:DataList
size	.\src\NetcdfDataset.hpp	/^	int size() const$/;"	f	struct:NetcdfDataset
size	.\utils\dump_weight_matrices.py	/^		size = int(words[1])$/;"	v
slice	.\src\Container.hpp	/^	View slice(int first = 0, int last = numeric_limits<int>::max())$/;"	f	struct:View
slice	.\src\Container.hpp	/^	View slice(pair<int, int>& r)$/;"	f	struct:View
slice	.\src\Container.hpp	/^	View<T> slice(int first = 0, int last = numeric_limits<int>::max())$/;"	f	struct:Vector
slice	.\src\Container.hpp	/^	View<T> slice(pair<int, int>& r)$/;"	f	struct:Vector
slice	.\src\Container.hpp	/^	const View slice(int first = 0, int last = numeric_limits<int>::max()) const$/;"	f	struct:View
slice	.\src\Container.hpp	/^	const View slice(pair<int, int>& r) const$/;"	f	struct:View
slice	.\src\Container.hpp	/^	const View<T> slice(int first = 0, int last = numeric_limits<int>::max()) const$/;"	f	struct:Vector
slice	.\src\Container.hpp	/^	const View<T> slice(pair<int, int>& r) const$/;"	f	struct:Vector
sort	.\src\Helpers.hpp	/^template <class R> static R& sort(R& r)$/;"	f
source	.\src\FullConnection.hpp	/^	FullConnection* source;$/;"	m	struct:FullConnection
source	.\src\Layer.hpp	/^	Layer* source;$/;"	m	struct:Layer
sourceSize	.\src\BlockLayer.hpp	/^	size_t sourceSize;			\/\/ 宣告時 會去取得 src 的 outputSize，所以 Layer creat 時不會主動做出這個數值$/;"	m	struct:BlockLayer
sources	.\src\GatherLayer.hpp	/^	vector<Layer*> sources;$/;"	m	struct:GatherLayer
span	.\src\Helpers.hpp	/^template <class T1, class T2> static integer_range<T2> span(T1 t1, T2 t2)$/;"	f
span	.\src\Helpers.hpp	/^template <class T> static integer_range<T> span(T t)$/;"	f
split	.\src\String.hpp	/^template<class T> static Vector<T> split(const string& original, char delim = ' ', size_t maxSplits = 0)$/;"	f
split_with_repeat	.\src\String.hpp	/^template<class T> static Vector<T> split_with_repeat(const string& original, char delim = ' ', char repeater = '*')$/;"	f
splitfracs	.\utils\shuffle_and_split.py	/^	splitfracs = [1.0\/numSplits] * numSplits$/;"	v
splitfracs	.\utils\shuffle_and_split.py	/^	splitfracs = [float(i) for i in splitstrings]$/;"	v
splitlines	.\utils\shuffle_and_split.py	/^splitlines = []$/;"	v
splitstrings	.\utils\shuffle_and_split.py	/^splitstrings = args[1].split()$/;"	v
sqrt	.\utils\std_dev_mean.py	/^from math import sqrt$/;"	i
squared	.\src\Helpers.hpp	/^template<class T> static T squared(const T& t)$/;"	f
start	.\src\NetcdfDataset.hpp	/^	DataSequence* start()$/;"	f	struct:DataList
start	.\utils\dump_weights.py	/^				start = end$/;"	v
start	.\utils\dump_weights.py	/^			start = 0$/;"	v
start_sequence	.\src\BlockLayer.hpp	/^	void start_sequence()$/;"	f	struct:BlockLayer
start_sequence	.\src\CollapseLayer.hpp	/^	virtual void start_sequence()$/;"	f	struct:CollapseLayer
start_sequence	.\src\Layer.hpp	/^	virtual void start_sequence()$/;"	f	struct:Layer
start_sequence	.\src\LstmLayer.hpp	/^	void start_sequence()$/;"	f	struct:LstmLayer
start_sequence	.\src\SoftmaxLayer.hpp	/^	void start_sequence()$/;"	f	struct:SoftmaxLayer
stateDelays	.\src\LstmLayer.hpp	/^	vector<vector<int> > stateDelays;$/;"	m	struct:LstmLayer
states	.\src\LstmLayer.hpp	/^	SeqBuffer<real_t> states;$/;"	m	struct:LstmLayer
stdDev	.\utils\std_dev_mean.py	/^stdDev = numpy.std(vals)$/;"	v
stdMeanFile	.\utils\normalise_netcdf.py	/^	stdMeanFile = netcdf_helpers.NetCDFFile(options.stdMeanFilename, 'r')$/;"	v
std_dev	.\src\Helpers.hpp	/^template <class R> static typename range_value<R>::type std_dev(const R& r)$/;"	f
step	.\src\SeqBuffer.hpp	/^	void step(size_t d)$/;"	f	struct:CoordIterator
step	.\utils\normalise_netcdf.py	/^			step = options.maxArraySize$/;"	v
str	.\src\Helpers.hpp	/^template<class T> static string str(const T& t)$/;"	f
str_to_label_seq	.\src\DataSequence.hpp	/^static vector<int> str_to_label_seq(const string& labelSeqString, const vector<string>& alphabet)$/;"	f
strides	.\src\MultiArray.hpp	/^	vector<size_t> strides;$/;"	m	struct:MultiArray
subMatch	.\utils\dump_weights.py	/^subMatch = re.search('(subsampleSize) (\\S+)', text)$/;"	v
subPenalty	.\src\StringAlignment.hpp	/^	int subPenalty;$/;"	m	struct:StringAlignment
subsMap	.\src\StringAlignment.hpp	/^	map<typename boost::range_value<R1>::type, map<typename boost::range_value<R1>::type, int> > subsMap;$/;"	m	struct:StringAlignment
subsampleMatch	.\utils\dump_weight_matrices.py	/^subsampleMatch = re.search('(subsampleSize) (\\S+)', text)$/;"	v
substitutions	.\src\StringAlignment.hpp	/^	int substitutions;$/;"	m	struct:StringAlignment
sum	.\src\Helpers.hpp	/^template <class R> static typename range_value<R>::type sum(const R& r)$/;"	f
sum_of_squares	.\src\Helpers.hpp	/^template <class R1, class R2> static typename range_value<R1>::type sum_of_squares(const R1& r1, const R2& r2)$/;"	f
sum_right	.\src\Helpers.hpp	/^template<class T1, class T2> static T2 sum_right(const map<T1, T2>& m)$/;"	f
symmetry	.\src\Mdrnn.hpp	/^	vector<bool> symmetry;			\/\/ 對稱 (numDims)$/;"	m	struct:Mdrnn
sys	.\examples\arabic_offline_handwriting\arabic_offline.py	/^import sys$/;"	i
sys	.\examples\arabic_online_handwriting\arabic_online.py	/^import sys$/;"	i
sys	.\examples\farsi_offline_handwriting\farsi_chars.py	/^import sys$/;"	i
sys	.\utils\dump_weight_matrices.py	/^import sys$/;"	i
sys	.\utils\dump_weights.py	/^import sys$/;"	i
sys	.\utils\normalise_netcdf.py	/^import sys$/;"	i
sys	.\utils\plot_variables.py	/^import sys$/;"	i
sys	.\utils\plot_weights.py	/^import sys$/;"	i
sys	.\utils\shuffle_and_split.py	/^import sys$/;"	i
sys	.\utils\std_dev_mean.py	/^import sys$/;"	i
tag	.\src\DataSequence.hpp	/^	string tag;$/;"	m	struct:DataSequence
targetClasses	.\src\DataSequence.hpp	/^	SeqBuffer<int> targetClasses;$/;"	m	struct:DataSequence
targetLabelCounts	.\src\NetcdfDataset.hpp	/^	map <string, real_t> targetLabelCounts;$/;"	m	struct:DataList
targetLabelCounts	.\src\NetcdfDataset.hpp	/^	map<string, int> targetLabelCounts;	\/\/ 每個單字(app)出現的次數$/;"	m	struct:DataHeader
targetLabelSeq	.\src\DataSequence.hpp	/^	vector<int> targetLabelSeq;$/;"	m	struct:DataSequence
targetLabels	.\src\NetcdfDataset.hpp	/^	Vector<string> targetLabels;        \/\/ 共有多少個單字(app)$/;"	m	struct:DataHeader
targetLabels	.\src\SoftmaxLayer.hpp	/^	vector<string> targetLabels;$/;"	m	struct:SoftmaxLayer
targetPatterns	.\src\DataSequence.hpp	/^	SeqBuffer<real_t> targetPatterns;$/;"	m	struct:DataSequence
targetSeqDims	.\src\NetcdfDataset.hpp	/^	SeqBuffer<int> targetSeqDims;$/;"	m	struct:NetcdfDataset
targetString	.\examples\arabic_offline_handwriting\arabic_offline.py	/^						targetString = wordTarget$/;"	v
targetString	.\examples\arabic_offline_handwriting\arabic_offline.py	/^					targetString = ""$/;"	v
targetString	.\examples\arabic_offline_handwriting\arabic_offline.py	/^					targetString = targetString.strip()$/;"	v
targetStrings	.\examples\arabic_offline_handwriting\arabic_offline.py	/^targetStrings = []$/;"	v
targetStrings	.\examples\arabic_online_handwriting\arabic_online.py	/^targetStrings = []$/;"	v
targetStrings	.\examples\farsi_offline_handwriting\farsi_chars.py	/^targetStrings = []$/;"	v
targetWordSeq	.\src\DataSequence.hpp	/^	vector<string> targetWordSeq;$/;"	m	struct:DataSequence
targets	.\src\ClassificationLayer.hpp	/^	SeqBuffer<int> targets;$/;"	m	struct:ClassificationLayer
task	.\src\NetcdfDataset.hpp	/^	string task;$/;"	m	struct:DataList
task	.\src\NetcdfDataset.hpp	/^	string task;$/;"	m	struct:NetcdfDataset
task	.\src\Trainer.hpp	/^	string task;$/;"	m	struct:Trainer
testDistortions	.\src\Trainer.hpp	/^	bool testDistortions;$/;"	m	struct:Trainer
testErrors	.\src\Trainer.hpp	/^	DatasetErrors testErrors;$/;"	m	struct:Trainer
testFiles	.\src\Trainer.hpp	/^	DataList testFiles;$/;"	m	struct:Trainer
text	.\utils\dump_weight_matrices.py	/^text = open(config).read()$/;"	v
text	.\utils\dump_weights.py	/^text = open(config).read().strip()$/;"	v
time_stamp	.\src\Helpers.hpp	/^static string time_stamp(const string& format = "%Y.%m.%d-%H.%M.%S%F%Q")$/;"	f
timesteps	.\src\NetcdfDataset.hpp	/^	size_t timesteps() const$/;"	f	struct:NetcdfDataset
to	.\src\Connection.hpp	/^	Layer* to;$/;"	m	struct:Connection
to	.\src\Container.hpp	/^	template<class T2> Vector<T2> to() const$/;"	f	struct:Vector
to	.\src\Container.hpp	/^	template<class T2> Vector<T2> to() const$/;"	f	struct:View
toIndex	.\utils\dump_weight_matrices.py	/^		toIndex = connName.index('to')$/;"	v
toIndex	.\utils\dump_weights.py	/^		toIndex = connName.index('to')$/;"	v
toLayer	.\utils\dump_weight_matrices.py	/^			toLayer = '_'.join(connName[toIndex+1:min(len(connName)-1,toIndex + 3)])$/;"	v
toLayer	.\utils\dump_weights.py	/^		toLayer = '_'.join(connName[toIndex+1:min(len(connName)-1,toIndex + 3)])$/;"	v
toLayerSize	.\utils\dump_weight_matrices.py	/^			toLayerSize = size \/ fromLayerSize$/;"	v
toLayerSize	.\utils\dump_weights.py	/^			toLayerSize = layerSizes[toLayer]$/;"	v
totalLen	.\examples\arabic_offline_handwriting\arabic_offline.py	/^totalLen = sum(seqLengths)$/;"	v
totalSegments	.\src\TranscriptionLayer.hpp	/^	int totalSegments;$/;"	m	struct:TranscriptionLayer
totalTargetStringLength	.\src\NetcdfDataset.hpp	/^	size_t totalTargetStringLength;$/;"	m	struct:DataHeader
totalTargetStringLength	.\src\NetcdfDataset.hpp	/^	size_t totalTargetStringLength;$/;"	m	struct:DataList
totalTime	.\src\TranscriptionLayer.hpp	/^	int totalTime;$/;"	m	struct:TranscriptionLayer
train	.\src\Mdrnn.hpp	/^	virtual real_t train(const DataSequence& seq)$/;"	f	struct:Mdrnn
train	.\src\Trainer.hpp	/^	void train(const string& savename)$/;"	f	struct:Trainer
trainErrors	.\src\Trainer.hpp	/^	DatasetErrors trainErrors;$/;"	m	struct:Trainer
trainFiles	.\src\Trainer.hpp	/^	DataList trainFiles;$/;"	m	struct:Trainer
transcript	.\examples\arabic_offline_handwriting\arabic_offline.py	/^							transcript = transcriptNumFlip$/;"	v
transcript	.\examples\arabic_offline_handwriting\arabic_offline.py	/^							transcript = transcript[::-1]$/;"	v
transcript	.\examples\arabic_offline_handwriting\arabic_offline.py	/^						transcript= data[1].split(':')[1].decode("cp1256")$/;"	v
transcript	.\examples\arabic_offline_handwriting\arabic_offline.py	/^						transcript= data[2].split(':')[1].split('|')[:-1]$/;"	v
transcript	.\examples\arabic_offline_handwriting\arabic_offline.py	/^                                                        transcript = transcript[::-1]$/;"	v
transcriptNumFlip	.\examples\arabic_offline_handwriting\arabic_offline.py	/^						transcriptNumFlip = ""$/;"	v
transform	.\src\Helpers.hpp	/^template <class R1, class R2, class F> static typename range_iterator<R2>::type transform(const R1& r1, R2& r2, const F& f)$/;"	f
trim	.\src\String.hpp	/^static void trim(string& str)$/;"	f
truFile	.\examples\arabic_offline_handwriting\arabic_offline.py	/^			truFile = open(truFilename)$/;"	v
truFilename	.\examples\arabic_offline_handwriting\arabic_offline.py	/^		truFilename = fname.replace('tif','tru')$/;"	v
ts	.\examples\arabic_online_handwriting\arabic_online.py	/^			ts = ""$/;"	v
ts	.\examples\arabic_online_handwriting\arabic_online.py	/^			ts = ts.strip()$/;"	v
uniform	.\src\Random.cpp	/^real_t Random::uniform()$/;"	f	class:Random
uniform	.\src\Random.cpp	/^real_t Random::uniform(real_t range)$/;"	f	class:Random
unitsPerBlock	.\src\LstmLayer.hpp	/^	size_t unitsPerBlock;$/;"	m	struct:LstmLayer
unnormedActivations	.\src\SoftmaxLayer.hpp	/^	SeqBuffer<real_t> unnormedActivations;$/;"	m	struct:SoftmaxLayer
unnormedlogActivations	.\src\SoftmaxLayer.hpp	/^	SeqBuffer<Log<real_t> > unnormedlogActivations;$/;"	m	struct:SoftmaxLayer
update_derivs	.\src\Connection.hpp	/^	virtual void update_derivs(const vector<int>& coords){}$/;"	f	struct:Connection
update_derivs	.\src\FullConnection.hpp	/^	void update_derivs(const vector<int>& toCoords)$/;"	f	struct:FullConnection
update_derivs	.\src\Layer.hpp	/^	virtual void update_derivs(const vector<int>& coords){}$/;"	f	struct:Layer
update_derivs	.\src\LstmLayer.hpp	/^	void update_derivs(const vector<int>& coords)$/;"	f	struct:LstmLayer
update_weights	.\src\Rprop.hpp	/^	void update_weights()$/;"	f	struct:Rprop
update_weights	.\src\SteepestDescent.hpp	/^	void update_weights()$/;"	f	struct:SteepestDescent
update_weights	.\src\Trainer.hpp	/^	void update_weights()$/;"	f	struct:Trainer
upxfile	.\examples\arabic_online_handwriting\arabic_online.py	/^		upxfile = inkmlfile.replace('inkml', 'upx')$/;"	v
usage	.\utils\max_jacobian.py	/^usage = "usage: %prog [options] jacobian_list_file output_activations_file output_file"$/;"	v
usage	.\utils\min_max.py	/^usage = "usage: %prog input-file"$/;"	v
usage	.\utils\plot_errors.py	/^usage = "usage: %prog log_file"$/;"	v
usage	.\utils\plot_variables.py	/^usage = "usage: %prog [opt] input-file"$/;"	v
useList	.\utils\plot_variables.py	/^useList = opt.use.replace(',', ' ').split()$/;"	v
used	.\src\ConfigFile.hpp	/^	set<string> used;$/;"	m	struct:ConfigFile
v	.\utils\max_jacobian.py	/^	v = zeros((T,T),'f')$/;"	v
v	.\utils\max_jacobian.py	/^	v = zeros((len(labels),T),'f')$/;"	v
val	.\utils\plot_variables.py	/^				val = abs(data[v][r])$/;"	v
valErrors	.\src\Trainer.hpp	/^	DatasetErrors valErrors;$/;"	m	struct:Trainer
valFiles	.\src\Trainer.hpp	/^	DataList valFiles;$/;"	m	struct:Trainer
validDatasets	.\src\Main.cpp	/^vector<string> validDatasets = list_of<string>("train")("test")("val");$/;"	v
vals	.\utils\dump_weight_matrices.py	/^		vals = words[2:]$/;"	v
vals	.\utils\dump_weights.py	/^		vals = words[2:]$/;"	v
vals	.\utils\std_dev_mean.py	/^vals = []$/;"	v
variance	.\src\Helpers.hpp	/^template <class R> static typename range_value<R>::type variance(const R& r)$/;"	f
vector_assign	.\src\Helpers.hpp	/^template<class R, class T> void vector_assign(const R& r, vector<T>& v)$/;"	f
verbose	.\src\GradientCheck.hpp	/^	bool verbose;$/;"	m	struct:GradientCheck
verbose	.\src\Helpers.hpp	/^static bool verbose = false;$/;"	v
w	.\examples\farsi_offline_handwriting\farsi_chars.py	/^		w = max(padDims[0], im.size[0])$/;"	v
warn_unless	.\src\Helpers.hpp	/^static bool warn_unless (bool condition, const string& str, ostream& out = cout)$/;"	f
warn_unused	.\src\ConfigFile.hpp	/^	void warn_unused(ostream& out, bool removeUnused = true)$/;"	f	struct:ConfigFile
weightCosts	.\src\Trainer.hpp	/^	Vector<real_t> weightCosts;$/;"	m	struct:Trainer
weightDistortion	.\src\Trainer.hpp	/^	real_t weightDistortion;$/;"	m	struct:Trainer
weightTypes	.\utils\dump_weight_matrices.py	/^weightTypes = opt.weightTypes.split()$/;"	v
weightTypes	.\utils\dump_weights.py	/^weightTypes = opt.weightTypes.split()$/;"	v
weightTypes	.\utils\plot_weights.py	/^weightTypes = opt.weightTypes.split()$/;"	v
weight_cost	.\src\Trainer.hpp	/^	real_t weight_cost(int i)$/;"	f	struct:Trainer
weights	.\src\Connection.hpp	/^	virtual const View<real_t> weights(){return View<real_t>();}$/;"	f	struct:Connection
weights	.\src\FullConnection.hpp	/^	const View<real_t> weights()$/;"	f	struct:FullConnection
weights	.\src\GradientCheck.hpp	/^	vector<real_t>& weights;$/;"	m	struct:GradientCheck
weights	.\src\Layer.hpp	/^	virtual const View<real_t> weights(){return View<real_t>();}$/;"	f	struct:Layer
weights	.\src\LstmLayer.hpp	/^	const View<real_t> weights()$/;"	f	struct:LstmLayer
weights	.\src\WeightContainer.hpp	/^	Vector<real_t> weights;$/;"	m	struct:WeightContainer
width	.\utils\plot_variables.py	/^						width = gridDims[0]$/;"	v
word	.\examples\arabic_online_handwriting\arabic_online.py	/^			word = parse(upxfile).getElementsByTagName('hwData')[0].getElementsByTagName('label')[0].getElementsByTagName('alternate')[0].getAttribute('value').strip().replace(' ','*')$/;"	v
wordTarget	.\examples\arabic_offline_handwriting\arabic_offline.py	/^					wordTarget = data[0].split(':')[1]$/;"	v
wordTargetStrings	.\examples\arabic_offline_handwriting\arabic_offline.py	/^wordTargetStrings = []$/;"	v
wordTargetStrings	.\examples\arabic_online_handwriting\arabic_online.py	/^wordTargetStrings = []$/;"	v
words	.\examples\arabic_offline_handwriting\arabic_offline.py	/^				words = l.split()$/;"	v
words	.\utils\dump_weight_matrices.py	/^	words = l.split()$/;"	v
words	.\utils\dump_weights.py	/^	words = l.split()$/;"	v
words	.\utils\plot_errors.py	/^	words = l.split()$/;"	v
words	.\utils\plot_weights.py	/^	words = l.split()$/;"	v
wts	.\examples\arabic_online_handwriting\arabic_online.py	/^			wts = word.encode('unicode_escape')$/;"	v
wts	.\src\Optimiser.hpp	/^	vector<real_t>& wts;$/;"	m	struct:Optimiser
wts	.\src\Trainer.hpp	/^	Vector<real_t>& wts;$/;"	m	struct:Trainer
yPlotCoord	.\utils\plot_variables.py	/^		yPlotCoord = axes.get_ylim()[1] + 0.01 * (axes.get_ylim()[1] - axes.get_ylim()[0])$/;"	v
yRange	.\utils\plot_errors.py	/^		yRange = [axis()[2], axis()[3]]$/;"	v
zip	.\src\Helpers.hpp	/^zip(R1& r1, R2& r2)$/;"	f
zip	.\src\Helpers.hpp	/^zip(R1& r1, R2& r2, R3& r3)$/;"	f
zip	.\src\Helpers.hpp	/^zip(R1& r1, R2& r2, R3& r3, R4& r4)$/;"	f
zip	.\src\Helpers.hpp	/^zip(R1& r1, R2& r2, R3& r3, R4& r4, R5& r5)$/;"	f
~BiasLayer	.\src\BiasLayer.hpp	/^	~BiasLayer(){}$/;"	f	struct:BiasLayer
~Connection	.\src\Connection.hpp	/^	virtual ~Connection(){}$/;"	f	struct:Connection
~CopyConnection	.\src\CopyConnection.hpp	/^	virtual ~CopyConnection(){}$/;"	f	struct:CopyConnection
~DataExporter	.\src\DataExporter.hpp	/^	~DataExporter()$/;"	f	struct:DataExporter
~DataList	.\src\NetcdfDataset.hpp	/^	~DataList()$/;"	f	struct:DataList
~FullConnection	.\src\FullConnection.hpp	/^	~FullConnection(){}$/;"	f	struct:FullConnection
~InputLayer	.\src\InputLayer.hpp	/^	~InputLayer(){}$/;"	f	struct:InputLayer
~Layer	.\src\Layer.hpp	/^	virtual ~Layer(){}$/;"	f	struct:Layer
~LstmLayer	.\src\LstmLayer.hpp	/^	~LstmLayer()$/;"	f	struct:LstmLayer
~Mdrnn	.\src\Mdrnn.hpp	/^	virtual ~Mdrnn()$/;"	f	struct:Mdrnn
~MultiArray	.\src\MultiArray.hpp	/^	virtual ~MultiArray()$/;"	f	struct:MultiArray
~Named	.\src\Named.hpp	/^	virtual ~Named(){}$/;"	f	struct:Named
~NetcdfDataset	.\src\NetcdfDataset.hpp	/^	~NetcdfDataset()$/;"	f	struct:NetcdfDataset
~NeuronLayer	.\src\NeuronLayer.hpp	/^	~NeuronLayer(){}$/;"	f	struct:NeuronLayer
~Optimiser	.\src\Optimiser.hpp	/^	virtual ~Optimiser(){}$/;"	f	struct:Optimiser
~SeqBuffer	.\src\SeqBuffer.hpp	/^	virtual ~SeqBuffer()$/;"	f	struct:SeqBuffer
~StringAlignment	.\src\StringAlignment.hpp	/^	~StringAlignment(){}$/;"	f	struct:StringAlignment
~TranscriptionLayer	.\src\TranscriptionLayer.hpp	/^	virtual ~TranscriptionLayer()$/;"	f	struct:TranscriptionLayer
~Val	.\src\DataExporter.hpp	/^	virtual ~Val(){}$/;"	f	struct:Val
